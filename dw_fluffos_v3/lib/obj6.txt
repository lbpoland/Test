
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/food.c ===
#include <bits_controller.h>
#include <drinks.h>
#include <weapon.h>
#include <move_failures.h>
#include <playtesters.h>
inherit "/obj/cont_medium";
inherit "/std/basic/virtual_update";
#define DEFAULT_DECAY 7200
#define STATE_CHANGE ("/obj/handlers/state_change")
private int _liquid;
private int _dried, _cured;
private int _bites_gone;
private int _weight_per_bite;
private int _in_pieces;
private int _decay_level;
private int _decay_speed;
private int _splashable;
private int _applicable;
private int _external_pk_check;
private float _divisor = to_float(DEFAULT_DECAY) / to_float(6 * TIME_OUT);
private mixed _eat_mess;
private string _eat_object;
private string _eat_func;
private string _piece_desc;
private string _piece_short;
private string _piece_plural;
private string _piece_substance;
private mixed _eat_piece_mess;
private mixed _eat_amt_mess;
private mixed _eat_last_mess;
private mapping _eat_effects = ([ ]);
private mapping _external_effects = ([ ]);
varargs int do_cut(int num);
varargs int do_eat(int no_mess);
int do_mince();
void set_decay_speed(int decay);
int check_for_container();
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   reset_continuous();
   _eat_effects = ([ ]);
   set_decay_speed(DEFAULT_DECAY);
   add_help_file("food");
   if (!do_setup) {
      this_object()->setup();
   }
}
int query_liquid()
{
   return _liquid;
}
int query_edible()
{
   return !_liquid;
}
void set_liquid()
{
   set_continuous();
   _liquid = 1;
   if (environment()) {
      environment()->calc_liquid();
   }
   set_decay_speed(0);
}
void reset_liquid()
{
   reset_continuous();
   _liquid = 0;
   if (environment())
      environment()->calc_liquid();
   set_decay_speed(DEFAULT_DECAY);
   _divisor = to_float(DEFAULT_DECAY) / to_float(6 * TIME_OUT);
}
int query_food_object()
{
   return 1;
}
void init()
{
   if (query_continuous()) {
      add_command("rub", "<direct:object> <preposition> <indirect:living>");
      add_command("apply", "<direct:object> <preposition> <indirect:living>");
   }
   if (_liquid) {
      add_command("drink", "<direct:object>");
      add_command("quaff", "<direct:object>");
      add_command("splash",
                  "<direct:object> <preposition> <indirect:living>");
   } else {
      add_command("eat", "<direct:object>", (: do_eat(0) :));
      add_command("cut",
                  "<direct:object> into <number'number, eg: 3'> pieces",
                  (: do_cut($4[1]) :));
      add_command("cut", "<direct:object>", (: do_cut() :));
      add_command("slice", "<direct:object>", (: do_cut() :));
      add_command("mince", "<direct:object>", (: do_mince() :));
   }
}
int query_decays()
{
   return _decay_speed != 0;
}
int query_bites_gone()
{
   return _bites_gone;
}
int query_weight_per_bite()
{
   return _weight_per_bite;
}
string query_eat_object()
{
   return _eat_object;
}
string query_eat_func()
{
   return _eat_func;
}
string query_eat_mess()
{
   return _eat_mess;
}
string query_piece_description()
{
   return _piece_desc;
}
int query_in_pieces()
{
   return _in_pieces;
}
int query_decay_speed()
{
   return _decay_speed;
}
int query_decay_level() {
   return _decay_level;
}
void set_bites_gone(int number)
{
   _bites_gone = number;
}
void set_weight_per_bite(int number)
{
   _weight_per_bite = number;
}
void set_eat_object(string word)
{
   _eat_object = word;
}
void set_eat_func(string word)
{
   _eat_func = word;
}
void set_eat_mess(mixed word)
{
   _eat_mess = word;
}
void setup_eat_piece_messages(mixed piece,
                              mixed amt,
                              mixed last) {
   _eat_piece_mess = piece;
   _eat_amt_mess = amt;
   _eat_last_mess = last;
}
void set_piece_description(string word) {
   _piece_desc = word;
}
void set_piece_short(string short) {
   _piece_short = short;
}
void set_piece_plural(string plural) {
   _piece_plural = plural;
}
void set_piece_substance(string substance) {
   _piece_substance = substance;
}
void set_in_pieces(int number) {
   int p;
   _in_pieces = p;
}
void set_decay_level(int level) {
   _decay_level = level;
}
void set_decay_speed(int decay) {
   float tmp;
   if(decay != _decay_speed && !_dried && !_cured) {
      BITS_CONTROLLER->remove_bit(this_object());
      _decay_speed = decay;
      if (decay && !_dried && !_cured) {
         tmp = _divisor;
         _divisor = to_float(decay) / to_float(6 * TIME_OUT);
         _decay_level = to_int(_decay_level * _divisor / tmp);
         BITS_CONTROLLER->add_bit(this_object());
      }
   }
}
void do_decay() {
  if(_dried || _cured) {
    BITS_CONTROLLER->remove_bit(this_object());
    return;
  }
  if ( environment() && environment()->query_property( "no decay" ) )
    return;
  _decay_level++;
  if (_decay_level > (2 * _divisor) -1 ) {
    remove_adjective( "fresh" );
  }
  if (_decay_level > 6 * _divisor) {
    tell_room(environment(this_object()),
              capitalize(the_short()) + " crumbles to dust.\n");
    move("/room/rubbish");
  }
}
int query_weight() {
  if (query_liquid())
    return 0;
  return ::query_weight() - _bites_gone * _weight_per_bite;
}
string query_short_rotten_adjective() {
    string ret;
    ret = "";
    switch (to_int(_decay_level / _divisor)) {
    case 2:
      ret = "slightly rotten ";
      break;
    case 3:
      ret = "half rotten ";
      break;
    case 4:
      ret = "mostly rotten ";
      break;
    case 5:
      ret = "almost rotten ";
      break;
    case 6:
      ret = "rotten ";
      break;
    }
    return ret;
}
string short(int dark) {
  string ret;
  ret = ::short(dark);
  if (_decay_speed) {
     ret = query_short_rotten_adjective() + ret;
  }
  return ret;
}
string query_long_eat_level() {
   int twelfths;
   string ret;
    twelfths = (_bites_gone * _weight_per_bite * 12) / ::query_weight();
    switch (twelfths) {
        case 0..1:
            ret = "It has just been nibbled on.\n";
        break;
        case 2:
            ret = "It is about one sixth gone.\n";
        break;
        case 3:
            ret = "It is about one quarter gone.\n";
        break;
        case 4:
            ret = "It is about one third gone.\n";
        break;
        case 5:
            ret = "It is just under half gone.\n";
        break;
        case 6:
            ret = "It is about half gone.\n";
        break;
        case 7:
            ret = "It is just over half gone.\n";
        break;
        case 8:
            ret = "It is about two thirds gone.\n";
        break;
        case 9:
            ret = "It is about three quarters gone.\n";
        break;
        case 10:
            ret = "It is about five sixths gone.\n";
        break;
        case 11:
            ret = "It is almost all gone.\n";
        break;
        default:
            ret = "Schroedinger's cat has been at it.\n";
        break;
    }
    return ret;
}
string query_long_decay_level() {
    string ret;
    ret = "";
    switch (to_int(_decay_level / _divisor)) {
    case 0..1:
      if(query_collective() && query_amount() > 1)
        ret += "They look nice and fresh.\n";
      else
       ret += "It looks nice and fresh.\n";
      break;
    case 2:
      if(query_collective() && query_amount() > 1)
        ret += "They look a bit rotten.\n";
      else
        ret += "It looks a bit rotten.\n";
      break;
    case 3:
      if(query_collective() && query_amount() > 1)
        ret += "They are half rotten.\n";
      else
        ret += "It is half rotten.\n";
      break;
    case 4:
      if(query_collective() && query_amount() > 1)
        ret += "They are mostly rotten.\n";
      else
        ret += "It is mostly rotten.\n";
      break;
    case 5:
      if(query_collective() && query_amount() > 1)
        ret += "They are almost completely rotten.\n";
      else
        ret += "It is almost completely rotten.\n";
       break;
    case 6:
      if(query_collective() && query_amount() > 1)
        ret += "They are completely rotten.\n";
      else
        ret += "It is completely rotten.\n";
      break;
    }
    return ret;
}
string long(string words, int dark) {
   string ret;
   ret =::long(words, dark);
   if (_liquid) {
      return ret;
   }
   if (_weight_per_bite && _bites_gone) {
       ret += query_long_eat_level();
   }
   if (_decay_speed) {
       ret += query_long_decay_level();
   }
   else {
       if(_dried) {
           if(query_collective() && query_amount() > 1) {
              ret += "They are all dry and shrivelled up.\n";
           }
           else {
              ret += "It is all dry and shrivelled up.\n";
           }
        }
        else {
            if(_cured) {
                if(query_collective() && query_amount() > 1) {
                    ret += "They seem to have been pickled.\n";
                }
                else {
                    ret += "It seems to have been pickled.\n";
                }
            }
        }
   }
   return ret;
}
void setup_eat(string ob, string func) {
   _eat_object = ob;
   _eat_func = func;
}
mapping query_eat_effects() {
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   }
   return copy( _eat_effects );
}
void set_eat_effects(mapping map) {
   if (mapp(map)) {
      _eat_effects = map;
   }
}
int add_eat_effect(mixed word,
                   int number)
{
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   }
   if (mapp(word)) {
      int num;
      string name;
      foreach(name, number in word) {
         num += add_eat_effect(name, number);
      }
      return num;
   }
   if (_eat_effects[word]) {
      _eat_effects[word] += number;
   } else {
      _eat_effects[word] = number;
   }
   return _eat_effects[word];
}
void remove_eat_effect(string word)
{
   if (!undefinedp(_eat_effects[word])) {
      _eat_effects = m_delete(_eat_effects, word);
   }
}
void set_external_pk_check()
{
   _external_pk_check = 1;
}
void unset_external_pk_check()
{
   _external_pk_check = 0;
}
mapping query_external_effects()
{
   if (undefinedp(_external_effects))
      _external_effects = ([ ]);
   return _external_effects + ([ ]);
}
void set_external_effects(mapping map)
{
   _external_effects = map;
}
int add_external_effect(string word,
                        int number)
{
   if (undefinedp(_external_effects))
      _external_effects = ([ ]);
   if (_external_effects[word])
      _external_effects[word] += number;
   else
      _external_effects[word] = number;
   return _external_effects[word];
}
void remove_external_effect(string word)
{
   if (!undefinedp(_external_effects[word])) {
      _external_effects = m_delete(_external_effects, word);
   }
}
void set_splashable()
{
   _splashable = 1;
}
void unset_splashable()
{
   _splashable = 0;
}
int query_splashable(object splasher,
                     object splashee)
{
   if (splasher == splashee || !_external_pk_check) {
      return (_splashable && _liquid);
   }
   return (_splashable && _liquid && !(pk_check(splasher, splashee)));
}
void set_applicable()
{
   _applicable = 1;
}
void unset_applicable()
{
   _applicable = 0;
}
int query_applicable(object applier,
                     object appliee)
{
   if (applier == appliee || !_external_pk_check) {
      return _applicable;
   }
   return (_applicable && !(pk_check(applier, appliee)));
}
void being_joined_by(object thing)
{
   int i,
     that,
     this;
   string *words;
   mapping new_effects;
   that = (int) thing->query_amount();
   this = query_amount();
   if (!(this + that))
      return;
   if (thing->query_splashable(0, 0) && !_splashable)
      set_splashable();
   if (thing->query_applicable(0, 0) && !_applicable)
      set_applicable();
   if (thing->query_external_pk_check() && !_external_pk_check)
      set_external_pk_check();
   new_effects = (mapping) thing->query_eat_effects();
   words = m_indices(_eat_effects);
   for (i = 0; i < sizeof(words); i++) {
      if (new_effects[words[i]]) {
         new_effects[words[i]] *= that;
         new_effects[words[i]] += this * _eat_effects[words[i]];
      } else {
         new_effects[words[i]] = this * _eat_effects[words[i]];
      }
   }
   words = m_indices(new_effects);
   for (i = 0; i < sizeof(words); i++) {
      new_effects[words[i]] /= this + that;
   }
   _eat_effects = new_effects;
   new_effects = (mapping) thing->query_external_effects();
   words = m_indices(_external_effects);
   for (i = 0; i < sizeof(words); i++) {
      if (_external_effects[words[i]]) {
         new_effects[words[i]] *= that;
         new_effects[words[i]] += this * _external_effects[words[i]];
      } else {
         new_effects[words[i]] = this * _external_effects[words[i]];
      }
   }
   words = m_indices(new_effects);
   for (i = 0; i < sizeof(words); i++) {
      new_effects[words[i]] /= this + that;
   }
   _external_effects = new_effects;
}
varargs void consume(object consumer, int amount, string type) {
  int i, denominator, numerator, wholes;
  string *words;
  switch (type) {
  case "splash":
  case "apply":
  case "external":
    words = m_indices(_external_effects);
    break;
  default:
    words = m_indices(_eat_effects);
    break;
  }
  if (!amount && query_continuous()) {
    amount = query_amount();
  }
  if (amount) {
    if (query_continuous() && (amount > query_amount()))
      amount = query_amount();
    numerator = amount * query_weight_unit()[0];
    denominator = query_weight_unit()[1];
    if (type != "apply" && type != "splash" && type != "external") {
      if (_liquid) {
        consumer->adjust_volume(D_DRINK, (50 * numerator) / denominator);
      } else {
        consumer->adjust_volume(D_FOOD, (50 * numerator) / denominator);
      }
    }
    if (!this_object()->query_property("playtester") ||
        PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
        consumer->query_creator()) {
      for (i = 0; i < sizeof(words); i++) {
        switch (type) {
        case "splash":
        case "apply":
        case "external":
          numerator = _external_effects[words[i]] * amount *
            query_weight_unit()[0];
          break;
        default:
          numerator = _eat_effects[words[i]] * amount *
            query_weight_unit()[0];
          break;
        }
        wholes = numerator / denominator;
        numerator %= denominator;
        if (random(denominator) < numerator) {
          wholes++;
        }
        consumer->add_effect(words[i], wholes);
      }
    }
    adjust_amount(-amount);
  } else {
    if (_weight_per_bite) {
      _bites_gone++;
      if (type != "apply" && type != "splash" && type != "external") {
        consumer->adjust_volume(D_FOOD, 50 * _weight_per_bite);
      }
      if (!this_object()->query_property("playtester") ||
          PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
          consumer->query_creator()) {
        for (i = 0; i < sizeof(words); i++) {
          switch (type) {
          case "splash":
          case "apply":
          case "external":
            this_player()->add_effect(words[i],
                                      _external_effects[words[i]] *
                                      _weight_per_bite);
            break;
          default:
            this_player()->add_effect(words[i], _eat_effects[words[i]] *
                                      _weight_per_bite);
            break;
          }
        }
      }
    } else {
      consumer->adjust_volume(D_FOOD, 50 * weight);
      if (!this_object()->query_property("playtester") ||
          PLAYTESTER_HAND->query_playtester(consumer->query_name()) ||
          consumer->query_creator()) {
        for (i = 0; i < sizeof(words); i++) {
          switch (type) {
          case "apply":
          case "splash":
          case "external":
            consumer->add_effect(words[i],
                                 _external_effects[words[i]] * weight);
            break;
          default:
            consumer->add_effect(words[i],
                                 _eat_effects[words[i]] * weight);
            break;
          }
        }
      }
    }
  }
  if (type != "apply" && type != "splash" && type != "external") {
    if (_eat_func) {
      if (_eat_object) {
        call_other(_eat_object, _eat_func, this_object(), consumer);
      } else {
        call_other(this_object(), _eat_func, this_object(), consumer);
      }
    }
  }
}
varargs int do_eat(int no_mess) {
   int ret;
   if ((weight <= 0) && !query_continuous()) {
      if (_eat_mess && !no_mess) {
         add_succeeded_mess(_eat_mess, ({ }));
      }
      move("/room/rubbish");
      return 1;
   }
   if ((weight <= (_bites_gone + 1) * _weight_per_bite) || !_weight_per_bite) {
      if (!no_mess) {
         if (!query_continuous()) {
            if (_weight_per_bite) {
               if (_eat_last_mess) {
                  add_succeeded_mess(_eat_last_mess, ({ }));
               } else {
                  add_succeeded_mess("$N $V the last of $D.\n", ({ }));
               }
            } else if (_eat_mess) {
               add_succeeded_mess(_eat_mess, ({ }));
            }
         } else {
            if (_eat_amt_mess) {
               add_succeeded_mess(replace_string(_eat_amt_mess, "$amt$",
                                                 amount_size() ), ({ }));
            } else {
               add_succeeded_mess("$N $V " + amount_size() + " of $D.\n",
                                  ({ }));
            }
         }
      }
      ret = 2;
      move("/room/rubbish");
   } else {
      if (!no_mess) {
         if (_eat_piece_mess) {
            add_succeeded_mess(_eat_piece_mess, ({ }));
         } else {
            add_succeeded_mess("$N $V a piece of $D.\n", ({ }));
         }
      }
      ret = 1;
   }
   consume(this_player(), 0);
   return ret;
}
int check_sharp(object weapon)
{
   mixed *data;
   int i;
   if (!weapon) {
      return 0;
   }
   data = weapon->query_attack_data();
   for (i = W_TYPE; i < sizeof(data); i += W_ARRAY_SIZE) {
      if (data[i] == "sharp") {
         return 1;
      }
   }
   return 0;
}
varargs int do_cut(int num_pieces) {
  object bing, *obs, with;
  string name, *exploded_short;
  int i, j, k, size_of_each, gone;
  int portion_of_whole;
  int portion_of_parent;
  string temp_short, temp_plural;
  mixed rabbit;
  if (query_liquid()) {
    add_failed_mess("You cannot $V $D.\n");
    return -1;
  }
  obs = this_player()->query_holding();
  for (i = 0; i < sizeof(obs); i++) {
    if (check_sharp(obs[i])) {
      if (!with || (with && with->query_weight() > obs[i]->query_weight())) {
        with = obs[i];
      }
    }
  }
  if (!with) {
    add_failed_mess("You have to be holding a sharp object to $V $D.\n");
    return -1;
  }
  if (undefinedp(num_pieces))
    num_pieces = 2;
  if (query_continuous())
    return (do_mince());
  if (num_pieces <= 1 || !_weight_per_bite) {
    add_failed_mess("$D cannot be cut up.\n");
    return -1;
  } else if (num_pieces >
             ((query_weight() / _weight_per_bite) - _bites_gone)) {
    if (num_pieces == 2 || ((query_weight() / _weight_per_bite) -
                            _bites_gone) < 2) {
      add_failed_mess("$D cannot be cut up.\n");
    } else
      add_failed_mess("You can't $V $D into that many pieces.\n");
    return -1;
  }
  name = file_name(this_object());
  sscanf(name, "%s#%*d", name);
  size_of_each = (query_weight() - _weight_per_bite * _bites_gone) /
    num_pieces;
  gone = (::query_weight() - size_of_each) / _weight_per_bite;
  for (i = 0; i < num_pieces; i++) {
    bing = clone_object(name);
    bing->init_static_arg(query_static_auto_load());
    bing->init_dynamic_arg(query_dynamic_auto_load());
    bing->set_weight(size_of_each);
    bing->set_value(0);
    bing->add_property("whole:weight", query_property("whole:weight")
                       || query_weight());
    bing->add_property("whole:short", query_property("whole:short")
                       || this_player()->convert_message(a_short()));
    portion_of_whole = bing->query_property("whole:weight") / size_of_each;
    portion_of_parent = query_weight() / size_of_each;
    if (!_in_pieces) {
      if (_piece_desc) {
        bing->set_long(_piece_desc);
        if (!_in_pieces) {
          if (!_piece_short) {
            if (portion_of_whole == 1)
              temp_short = "piece";
            else if (portion_of_whole == 2)
              temp_short = "half";
            else if (portion_of_whole == 4)
              temp_short = "quarter";
            else
              temp_short = word_ordinal(portion_of_whole);
          }
          if (!_piece_plural) {
            if (_piece_short)
              _piece_plural = _piece_short + "s";
            else {
              if (temp_short == "half")
                temp_plural = "halves";
              else
                temp_plural = temp_short + "s";
            }
          }
          if (_piece_substance)
            rabbit = _piece_substance;
          else
            rabbit = bing->query_property("whole:short");
          bing->set_short((_piece_short || temp_short) +
                          " of " + rabbit);
          bing->set_main_plural((_piece_plural || temp_plural) +
                                " of " + rabbit);
        }
      }
    } else {
      bing->set_bites_gone(gone);
    }
    bing->add_alias(_piece_short || temp_short);
    bing->add_plural(_piece_plural || temp_plural);
    exploded_short = explode(bing->query_short(), " ");
    j = sizeof(exploded_short);
    bing->set_name(exploded_short[j - 1]);
    for (k = 0; k < sizeof(exploded_short) - 1; k++) {
      bing->add_adjective(exploded_short[k]);
    }
    bing->set_in_pieces(1);
    if (bing->move(environment((this_object())))!= MOVE_OK ) {
      bing->move(environment(this_player()));
    }
  }
  move("/room/rubbish");
  if (with->query_weight() < 20) {
    add_succeeded_mess(({ sprintf("$N $V $D into %s pieces with %s%s.\n",
                                  query_num(num_pieces), with->poss_short(),
                                  (num_pieces * size_of_each) <
                                  query_weight()?
                                  ", carelessly dribbling a bit while you do "
                                  "so" : ""),
                            sprintf("$N $V $D into %s pieces with %s.\n",
                                    query_num(num_pieces),
                                    with->poss_short()) }));
  } else {
    add_succeeded_mess(({sprintf("$N stand back and hack $D into %s pieces "
                                 "with %s%s.\n", query_num(num_pieces),
                                 with->poss_short(),
                                 (num_pieces * size_of_each) < query_weight()?
                                 ", carelessly obliterating a bit when you do "
                                 "so" : ""),
                           sprintf("$N stands back and hacks $D into %s "
                                   "pieces with %s.\n",
                                   query_num(num_pieces),
                                   with->poss_short()) }));
  }
  return 1;
}
varargs int do_mince()
{
   object *obs,
     with,
     transformed;
   int i,
     rem_pieces;
   if (query_liquid()) {
      add_failed_mess("You cannot $V $D.\n");
      return -1;
   }
   obs = this_player()->query_holding();
   for (i = 0; i < sizeof(obs); i++) {
      if (check_sharp(obs[i])) {
         if (!with || (with && with->query_weight() > obs[i]->query_weight())) {
            with = obs[i];
         }
      }
   }
   if (!with) {
      add_failed_mess("You have to be holding a sharp object to $V " "$D.\n");
      return -1;
   }
   transformed = STATE_CHANGE->transform(this_object(), "slice");
   if (!objectp(transformed)) {
      if (query_continuous()) {
         add_failed_mess("$D cannot be cut up any further.\n");
         return -1;
      }
      if (_weight_per_bite) {
         rem_pieces = (query_weight() / _weight_per_bite) - _bites_gone;
         return (do_cut(rem_pieces));
      }
      return -1;
   }
   this_object()->move("/room/rubbish");
   if (transformed->move(this_player()) != MOVE_OK) {
      call_out("tell_object", 0, this_player(), "You drop " +
               transformed->the_short() + ".\n");
      call_out("tell_room", 0, environment(this_player()),
               this_player()->the_short() + " drops " +
               transformed->the_short() + ".\n");
      transformed->move(environment(this_player()));
   }
   add_succeeded_mess("$N $V $D with " + with->the_short() +
                      " into $I.\n", ({ transformed }));
   return 1;
}
int do_drink()
{
   if (!check_for_container()) {
      add_failed_mess("You go to try and $V $D, but it suddenly "
                      "remembers what happens when it is not in a "
                      "container and drains away to dust.\n");
      move("/room/rubbish");
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D.\n", ({ }));
   consume(this_player(), 0);
   return 1;
}
int do_quaff()
{
   if (!check_for_container()) {
      add_failed_mess("You go to try and $V $D, but it suddenly "
                      "remembers what happens when it is not in a "
                      "container and drains away to dust.\n");
      move("/room/rubbish");
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() +
                                     " of $D spilling most of "
                                     "it of course.\n", ({ }));
   consume(this_player(), query_amount() * 6 / 10, "splash");
   consume(this_player(), query_amount() * 4 / 10);
   return 1;
}
int do_apply(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D to one person alone.\n", ({ }));
      return 0;
   }
   if (!_applicable) {
      add_failed_mess("You cannot $V $D to anybody.\n");
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to rub $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D to $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "apply");
   return 1;
}
int do_rub(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D on one person alone.\n", ({ }));
      return 0;
   }
   if (!_applicable) {
      add_failed_mess("You cannot $V $D on anybody.\n");
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to rub $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D on $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "apply");
   return 1;
}
int do_splash(object * things)
{
   if (sizeof(things) > 1) {
      add_failed_mess("You must $V $D on one person alone.\n", ({ }));
      return 0;
   }
   if (!_splashable || !_liquid) {
      add_failed_mess("You cannot $V $D on anybody.\n", ({ }));
      return 0;
   }
   if (_external_pk_check && pk_check(this_player(), things[0])) {
      add_failed_mess("You feel it would be wrong to splash $D on $I.\n",
                      things);
      return 0;
   }
   this_player()->add_succeeded_mess(this_object(), "$N $V " +
                                     amount_size() + " of $D on $I.\n",
                                     ({ things[0] }));
   consume(things[0], 0, "splash");
   return 1;
}
mapping int_query_static_auto_load() {
   return ([ "::" : ::int_query_static_auto_load(),
             "liquid" : _liquid,
             "weight_per_bite" : _weight_per_bite,
             "eat_object" : _eat_object,
             "eat_func" : _eat_func,
             "eat_mess" : _eat_mess,
             "splashable" : _splashable,
             "applicable" : _applicable,
             "external_pk_check" : _external_pk_check ]);
}
mapping query_static_auto_load()
{
   if ((explode(file_name(this_object()), "#")[0] != "/obj/food")
       && !query_continuous()) {
      return 0;
   }
   return int_query_static_auto_load();
}
void init_static_arg(mapping map)
{
   if (!mapp(map)) {
      return;
   }
   if (map["::"]) {
      ::init_static_arg(map["::"]);
   }
   _liquid = map["liquid"];
   _weight_per_bite = map["weight_per_bite"];
   _eat_object = map["eat_object"];
   _eat_func = map["eat_func"];
   _eat_mess = map["eat_mess"];
   _splashable = map["splashable"];
   _applicable = map["applicable"];
   _external_pk_check = map["external_pk_check"];
}
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "bites_gone" : _bites_gone,
             "eat_effects" : _eat_effects,
             "external_effects" : _external_effects,
             "in pieces" : _in_pieces,
             "piece desc" : _piece_desc,
             "piece short" : _piece_short,
             "piece plural" : _piece_plural,
             "piece substance" : _piece_substance,
             "decay speed" : _decay_speed,
             "decay level" : _decay_level,
             "dried" : _dried,
             "cured" : _cured,
             "divisor" : _divisor, ]);
}
void init_dynamic_arg(mapping map, object)
{
   if (!mapp(map)) {
      return;
   }
   if (map["::"]) {
      ::init_dynamic_arg(map["::"]);
   }
   _bites_gone = map["bites_gone"];
   if (undefinedp(_eat_effects)) {
      _eat_effects = ([ ]);
   } else {
      if (mapp(map["eat_effects"])) {
         _eat_effects = map["eat_effects"];
      }
   }
   if (undefinedp(_external_effects)) {
      _external_effects = ([ ]);
   } else {
      _external_effects = map["external_effects"];
   }
   _in_pieces = map["in pieces"];
   _piece_desc = map["piece desc"];
   _piece_short = map["piece short"];
   _piece_plural = map["piece plural"];
   _piece_substance = map["piece substance"];
   if (_in_pieces && _piece_desc) {
      set_long(_piece_desc);
   }
   set_decay_speed(map["decay speed"]);
   _decay_level = map["decay level"];
   _divisor = map["divisor"];
   _dried = map["dried"];
   _cured = map["cured"];
   init_virtual_object();
}
mixed *stats()
{
   int i;
   string *words;
   mixed *args;
   args =::stats() + ({ ({ "liquid", _liquid }),
                        ({ "bites gone", _bites_gone }),
                        ({ "weight per bite", _weight_per_bite }),
                        ({ "eat object", _eat_object }),
                        ({ "eat function", _eat_func }),
                        ({ "eat message", _eat_mess }),
                        ({ "in pieces", _in_pieces }),
                        ({ "decay speed", _decay_speed }),
                        ({ "decay level", _decay_level }),
                        ({ "dried", _dried }),
                        ({ "cured", _cured }) });
   words = m_indices(_eat_effects);
   for (i = 0; i < sizeof(words); i++) {
      args += ({ ({ "eat effect#" + i, words[i] + " (" +
                    _eat_effects[words[i]] + ")" }) });
   }
   args += ({ ({ "applicable", _applicable }) });
   args += ({ ({ "splashable", _splashable }) });
   if (_splashable && !_liquid) {
      args += ({ ({ "***not splashable***", "because not a liquid" }) });
   }
   args += ({ ({ "external_pk_check", _external_pk_check }) });
   if (_external_effects) {
      words = keys(_external_effects);
      for (i = 0; i < sizeof(words); i++) {
         args += ({ ({ "external effect#" + i, words[i] + " (" +
                       _external_effects[words[i]] + ")" }) });
      }
   }
   return args;
}
int check_for_container()
{
   if (query_liquid()) {
      if (!environment()->query_max_volume() || living(environment())) {
         return 0;
      }
   }
   return 1;
}
private void move_check_for_container()
{
   if (!check_for_container()) {
      tell_room(environment(),
                the_short() + " dribbles all over the place and disappears "
                "into the dust.\n");
      if(move("/room/rubbish") != MOVE_OK) {
        debug_printf("Oops, failed to move us to the rubbish room.\n");
      }
   }
}
varargs int move(mixed dest, string mess1, string mess2) {
   int ret;
   ret =::move(dest, mess1, mess2);
   if (ret == MOVE_OK && dest != "/room/rubbish" && query_liquid()) {
      move_check_for_container();
   }
   return ret;
}
int query_rotten() {
    if ( _divisor ) {
        return to_int( _decay_level / _divisor ) > 1;
    }
    return 0;
}
string *query_adjectives() {
  if( query_rotten() ) {
    return ::query_adjectives() + ({ "rotten" });
  }
  return ::query_adjectives();
}
float query_decay_divisor() { return _divisor; }
int do_cure() {
  if(_dried || _liquid || _cured)
    return 0;
  _decay_speed = 0;
  _decay_level = 0;
  BITS_CONTROLLER->remove_bit(this_object());
  set_main_plural( "cured " + query_plural() );
  set_short( "cured " + query_short());
  add_adjective("cured");
  remove_adjective("fresh");
  _cured = 1;
  if( query_collective() ) {
    merge();
  }
  return 1;
}
int query_cured() { return _cured; }
int do_dry() {
  int new_weight;
  if(_dried || _liquid || _cured)
    return 0;
  _decay_speed = 0;
  _decay_level = 0;
  BITS_CONTROLLER->remove_bit( this_object() );
  set_main_plural("dried " + query_plural(0));
  set_short( "dried " + query_short());
  add_adjective("dried");
  remove_adjective("fresh");
  new_weight = ::query_weight() / 10;
  if ( new_weight ) {
    set_weight( new_weight );
  }
  else {
    set_weight( 1 );
  }
  if( query_collective() ) {
    merge();
  }
  _dried = 1;
  return 1;
}
int query_dried() { return _dried; }
int merge_criteria(object ob) {
  return ::merge_criteria(ob) &&
    _decay_speed == ob->query_decay_speed() &&
    _bites_gone == ob->query_bites_gone() &&
    ((to_int(_decay_level / _divisor) < 2 &&
     to_int(ob->query_decay_level() / ob->query_decay_divisor()) < 2) ||
     to_int(_decay_level / _divisor) ==
     to_int(ob->query_decay_level() / ob->query_decay_divisor()));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/clothing.c ===
#include <move_failures.h>
#include <virtual.h>
inherit "/std/container";
inherit "/std/basic/wearable";
inherit "/std/basic/close_lock";
string pocket_mess;
mixed *pockets;
nosave int biggest;
int _is_pair = 0;
void create() {
   do_setup++;
   container::create();
   wearable::create();
   close_lock::create();
   set_stuck(1);
   set_can_export_inventory();
   pocket_mess = "a pocket in $ob_short$";
   pockets = ({ });
   add_alias( "clothing" );
   add_plural( "clothes" );
   add_immune_to( "blunt" );
   add_help_file("clothing");
   set_opaque();
   set_open();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "haberdashery" );
   }
   do_setup--;
   if ( !do_setup ) {
      this_object()->setup();
   }
}
int query_clothing() { return 1; }
string query_pronoun()  {
   if (!_is_pair)
      return "it";
   return "they";
}
string query_objective()  {
   if (!_is_pair)
      return "it";
   return "them";
}
void set_is_pair(int comes_in_pairs)  {
   _is_pair = comes_in_pairs;
   if (_is_pair)
      add_adjective(({ "pair", "of" }));
}
int query_is_pair() { return _is_pair; }
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
   ret = container::long( word, dark );
   if ( sizeof( pockets ) && !dark ) {
      types = ([ ]);
      for ( i = 0; i < sizeof( pockets ); i += 2 ) {
         types[ pockets[ i ] ]++;
      }
      sizes = m_indices( types );
      for ( i = 0; i < sizeof( sizes ); i++ ) {
         sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
               " pocket"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
      }
      ret += "$C$"+ the_short() +" has "+ query_multiple_short( sizes ) +".\n"+
            query_contents( "It contains: " );
      ret += close_lock::long_status();
   }
   return ret + wearable::long( word, dark );
}
varargs string pretty_short( object thing ) {
   mixed pshort = ::pretty_short( thing );
   string short_stat = close_lock::short_status();
   if( arrayp( pshort ) ) {
      for( int i = 0; i < sizeof( pshort ); ++i ) {
         pshort[i] = short_stat + pshort[i];
      }
   } else {
      pshort = short_stat + pshort;
   }
   return pshort;
}
varargs string pretty_plural( object thing ) {
   mixed plural = ::pretty_plural( thing );
   string short_stat = close_lock::short_status();
   if( arrayp( plural ) ) {
      for( int i = 0; i < sizeof( plural ); ++i ) {
         plural[i] = short_stat + plural[i];
      }
   } else {
      plural = short_stat + plural;
   }
   return plural;
}
string query_pocket_mess() { return pocket_mess; }
void set_pocket_mess( string words ) { pocket_mess = words; }
mixed *query_pockets() { return pockets; }
void remove_pockets() {
  for( int i = 0; i < sizeof( pockets ); i+=2 ) {
    set_max_weight( query_max_weight() - pockets[ i+1 ] );
  }
  pockets = ({ });
}
void add_pocket( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   pockets += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > biggest ) {
      biggest = amount;
   }
}
int test_add( object thing, int flag ) {
   int i;
   if ( !sizeof( pockets )  || flag ) {
      return 0;
   }
   if ( !environment( thing ) ) {
      return 1;
   }
   if ( !biggest ) {
      for ( i = 0; i < sizeof( pockets ); i+= 2 ) {
         if ( pockets[ i + 1 ] > biggest ) {
            biggest = pockets[ i + 1 ];
         }
      }
   }
   if ( (int)thing->query_complete_weight() > biggest ) {
      return write( (string)thing->the_short() +" is too big "+
            "to fit in any of "+ the_short() +"'s pockets.\n" );
   }
   return ::test_add(thing, flag);
}
int can_find_match_recurse_into(object looker) {
   if (query_closed()) {
      return 0;
   }
   return ::can_find_match_recurse_into(looker);
}
int query_ac( string type, int amount ) {
   do_damage( type, amount );
   return 0;
}
void setup_clothing( int number ) {
   set_max_cond( number );
   set_cond( number );
   set_lowest_cond( number );
}
int query_value() {
   return modify_value( container::query_value() );
}
int query_full_value() { return container::query_value(); }
int drop(mixed stuff) {
   if ( worn_by ) {
      if ( living( worn_by ) ) {
         return 1;
      }
   }
   return container::drop(stuff);
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   object from;
   from = environment();
   flag = container::move( dest, messin, messout );
   if ( ( flag == MOVE_OK ) && worn_by ) {
      set_worn_by( 0 );
      if (from) {
         from->remove_inventory_container(this_object());
      }
      if (environment()) {
         environment()->add_inventory_container(this_object());
      }
   }
   return flag;
}
string *parse_command_adjectiv_id_list() {
    return container::parse_command_adjectiv_id_list() +
        close_lock::parse_command_adjectiv_id_list();
}
void dest_me() {
   set_worn_by( 0 );
   container::dest_me();
}
void break_me() {
   if ( worn_by ) {
      all_inventory()->move( environment( worn_by ), "$N fall$s from "+
            a_short() +"." );
   } else {
      all_inventory()->move( environment(), "$N fall$s out of "+
            a_short() +"." );
   }
   ::break_me();
}
mixed *stats() {
   int i;
   mixed *ret;
   ret = container::stats() + wearable::stats();
   for ( i = 0; i < sizeof( pockets ); i += 2 ) {
      ret += ({ ({ pockets[ i ] +" pocket", pockets[ i + 1 ] }) });
   }
   return ret;
}
mapping int_query_static_auto_load() {
   return ([
      "::" : container::int_query_static_auto_load(),
      "wear" : wearable::query_static_auto_load(),
      "pocket mess" : pocket_mess,
      "pockets" : pockets,
      "trans" : query_transparent(),
      "difficulty" : query_difficulty(),
      "key" : query_key(),
      "trap open func" : query_open_trap_func(),
      "trap lock func" : query_lock_trap_func(),
      "trap open ob" : query_open_trap_ob(),
      "trap lock ob" : query_lock_trap_ob(),
      "stuck" : query_stuck(),
      "pair" : _is_pair
   ]);
}
mapping query_static_auto_load() {
   if ( base_name(this_object()) != __FILE__[0..<3]) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : container::query_dynamic_auto_load(),
      "wear" : wearable::query_dynamic_auto_load(),
      "locked" : query_locked(),
      "closed" : query_closed(),
   ]);
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      container::init_static_arg( map[ "::" ] );
   }
   if ( map[ "wear" ] ) {
      wearable::init_static_arg( map[ "wear" ] );
   }
   if ( !undefinedp( map[ "pocket mess" ] ) ) {
      pocket_mess = map[ "pocket mess" ];
   }
   if ( !undefinedp( map[ "pockets" ] ) ) {
      pockets = map[ "pockets" ];
   }
   if (!undefinedp(map["pair"]))
      _is_pair = map["pair"];
   if (!undefinedp(map["trans"])) {
      if (map["trans"]) {
         set_transparent();
      } else {
         set_opaque();
      }
   }
   if (!undefinedp(map["difficulty"])) {
      set_difficulty(map["difficulty"]);
   }
   if (!undefinedp(map["key"])) {
      set_key(map["key"]);
   }
   if (!undefinedp(map["trap open func"])) {
      set_open_trap(map["trap open ob"], map["trap open func"]);
   }
   if (!undefinedp(map["trap lock func"])) {
      set_lock_trap(map["trap lock ob"], map["trap lock func"]);
   }
   if ( !undefinedp( map[ "stuck" ] ) ) {
      set_stuck(map["stuck"]);
   }
}
void replace_me(){
  object receipt;
  receipt = clone_object( "/std/object" );
  receipt->set_name( "receipt" );
  receipt->set_short( "destructed item receipt" );
  receipt->add_adjective( ({ "destructed", "item" }) );
  receipt->set_long( "This seems to be a small piece of paper.\n" );
  receipt->set_read_mess( "According to our sources, your "+query_short()+" was not "
                          "allowed to exist.  Have a nice day." );
  receipt->move( environment() );
  receipt->set_weight( 1 );
  destruct( this_object() );
}
void init_dynamic_arg( mapping map, object ob ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] ) {
      container::init_dynamic_arg( map[ "::" ], ob );
   }
   if ( map[ "wear" ] ) {
      wearable::init_dynamic_arg( map[ "wear" ], ob );
   }
   if ( !undefinedp( map[ "locked" ] ) ) {
      if ( map[ "locked" ] ) {
         set_locked();
      } else {
         set_unlocked();
      }
   }
   if ( !undefinedp( map[ "closed" ] ) ) {
      if (map["closed"]) {
         set_closed();
      } else {
         set_open();
      }
   }
   if( virt_name = query_property( VIRTUAL_NAME_PROP ) ) {
      if( file_size( virt_name ) == -1 ) {
         new_name = ( CLONER )->other_file( virt_name );
         if( stringp( new_name ) && ( new_name != virt_name ) ) {
            add_property( VIRTUAL_NAME_PROP, new_name );
            virt_name = new_name;
         } else {
            if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
               call_out( "replace_me", 1 );
            } else {
               VIRTUAL_HANDLER->add_missing( virt_name );
            }
         }
      }
      if( file_size( virt_name ) != -1 &&
          query_property( "virtual time" ) < stat( virt_name )[1] ) {
         stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
         if( mapp( stat_temp ) ) {
            init_static_arg( stat_temp );
            add_property( "virtual time", time() );
         }
      }
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/key.c ===
inherit "std/object";
string type;
void set_type(string str) {
  remove_adjective(type);
  type = str;
  add_adjective(type);
  set_main_plural(type + " keys");
  set_short(type + " key");
}
string query_type() {
  return type;
}
void create() {
  ::create();
  set_name("key");
  set_main_plural("normal keys");
  add_plural("keys");
  type = "normal";
  set_short(query_type() + " key");
  set_long("A key.  Wonder where it fits?\n");
  set_weight(1);
  adjust_money(1, "brass");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/potions/perception.ob ===
::#Class:: "/obj/potions/potion.c"
::Name:: "perception"
::$set_min_level:: 40
::$set_max_level:: 160
::$set_advance_chance:: 10
::$set_backfire_chance:: 50
::$set_reagent_alias:: "TransientPerception"
::$set_backfire_alias:: "TransientPanic"
::$set_rel_strength:: 1
::$set_potion_verb:: "chant"
::$set_chant:: "Wubba!\nWubba!\nWubba!\n"
::$set_recipe:: "     Granny Whitlow's Perseptione Inhansement Tonic\n" +
    "Tayk a handful of grounds that have beene used to makke coffee " +
    "in a stronge majical feild.  " +
    "Adde one pynte of watre and three pynches of " +
    "dedly nyteshayde.  When a chaynge is notticed, chant ovre the " +
    "myxture.\n\nWarnning: can caus nervussness."
::$set_skills:: ({
    ({"magic.methods.physical.chanting", 3, 40, 1}),
    ({"magic.methods.physical.enchanting", 1, 40, 1})
})


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/potions/panic.ob ===
::#Class:: "/obj/potions/potion.c"
::Name:: "panic"
::$set_min_level:: 5
::$set_max_level:: 20
::$set_advance_chance:: 80
::$set_backfire_chance:: 0
::$set_reagent_alias:: "TransientPanic"
::$set_rel_strength:: 1
::$set_potion_verb:: "mix"
::$set_recipe:: "     Granny Whitlow's Panic Brew\n" +
    "Tayk a handful of grounds that have beene used to mayke coffee " +
    "in a stronge majical feild.  " +
    "Adde one pynte of watre and three pynches of " +
    "dedly nyteshayde.  When a chaynge is notticed, mix welle.\n"
::$set_skills:: ({
    ({"magic.methods.physical.enchanting", 1, 20, 1})
})


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/potions/troll.ob ===
::#Class:: "/obj/potions/potion.c"
::Name:: "troll"
::$set_min_level:: 40
::$set_max_level:: 400
::$set_advance_chance:: 10
::$set_backfire_chance:: 0
::$set_reagent_alias:: "TransientTroll"
::$set_rel_strength:: 1
::$set_potion_verb:: "mix"
::$set_recipe:: "     Making Trolls for Fun and Profit\n" +
    "Mix dry cement and water in a 2:1 ratio.  Add a pinch of " +
    "diamond dust for every 20 pounds of cement.  Mix before it " +
    "completely hardens.\n"
::$set_skills:: ({
    ({"magic.methods.elemental.earth", 1, 400, 1}),
    ({"magic.methods.mental.animating", 1, 400, 1})
})


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/potions/index ===
"perception potion" "/obj/potions/perception.ob"
"granny whitlow's perseptione inhansement tonic" "/obj/potions/perception.ob"
"granny whitlow's perception enhancement tonic" "/obj/potions/perception.ob"
"panic potion" "/obj/potions/panic.ob"
"granny whitlow's panic brew" "/obj/potions/panic.ob"
"troll" "/obj/potions/troll.ob"
"second sight potion" "/obj/potions/second_sight.ob"


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/potions/second_sight.ob ===
::#Class:: "/obj/potions/potion.c"
::Name:: "second_sight"
::$set_min_level:: 100
::$set_max_level:: 500
::$set_advance_chance:: 50
::$set_backfire_chance:: 0
::$set_reagent_alias:: "TransientSecondSight"
# Still need to write this...
::$set_backfire_alias:: "TransientBlindBoom"
::$set_rel_strength:: 1
::$set_potion_verb:: "chant"
::$set_chant:: "Through the darkness, through the haze,\n" +
               "Through the forest's twisted maze,\n" +
               "Through the sky with stars ablaze,\n" +
               "Let mine eyes on others gaze.\n"
::$set_recipe:: "     A mixture to endow a person with second sight\n" +
        "Obtain the left eye of a Basilisk.  Extract ten drops of ichor " +
        "from said eye.  Mix with ten drops of molten beeswax from a " +
        "candle dedicated to the Blind god, and five pinches of ground " +
        "carrot.  Chant the words over the mixture before the wax hardens. " +
        "Mix one drop of the resultant concoction in a quantity of water, " +
        "and picture the desired location in the container."
::$set_skills:: ({
    ({"magic.methods.elemental.water", 1, 100, 1}),
    ({"magic.methods.physical.chanting", 2, 100, 1})
})


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/potions/potion.c ===
inherit "/std/object";
#include <tasks.h>
#define SKILL_WGT 0
#define SKILL_MAX 1
#define SKILL_LVL 2
#define SKILL_ADV 3
#define REAGENTS "/obj/reagents/"
int min_level, max_level, advance_chance, backfire_chance, rel_strength;
mapping skills = allocate_mapping(1);
string *skill_str, reagent_alias, backfire_alias, potion_verb, recipe;
string chant;
void set_min_level(int l) { min_level = l; }
void set_max_level(int l) { max_level = l; }
int query_min_level() { return min_level; }
int query_max_level() { return max_level; }
void set_advance_chance(int c) { advance_chance = c; }
int query_advance_chance() { return advance_chance; }
void set_backfire_chance(int c) { backfire_chance = c; }
int query_backfire_chance() { return backfire_chance; }
void set_reagent_alias(string s) { reagent_alias = s; }
string query_reagent_alias() { return reagent_alias; }
void set_backfire_alias(string s) { backfire_alias = s; }
string query_backfire_alias() { return backfire_alias; }
void set_rel_strength(int s) { rel_strength = s; }
int query_rel_strength() { return rel_strength; }
void set_potion_verb(string s) { potion_verb = s; }
string query_potion_verb() { return potion_verb; }
void set_recipe(string s) { recipe = s; }
string query_recipe() { return recipe; }
void set_chant(string s) { chant = s; }
string query_chant() { return chant; }
void set_skills(mixed s) {
    int i;
    for (i = 0; i < (sizeof(s)); i++) {
        skills[s[i][0]] = ({s[i][SKILL_WGT+1], s[i][SKILL_MAX+1],
                            s[i][SKILL_LVL+1], 0});
    }
    skill_str = keys(skills);
}
mapping query_skills() { return skills; }
object clone_reagent(string given_verb) {
    int result, i, sum, x;
    string s;
    object ob;
    if (potion_verb != given_verb) return 0;
    for (i = 0; i < sizeof(skill_str); i++) {
        s = skill_str[i];
        skills[s][SKILL_ADV] = 0;
        if (skills[s][SKILL_LVL]) {
            if ((x = (int)this_player()->query_skill(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        } else {
            if ((x = (int)this_player()->query_skill_bonus(s))
                > skills[s][SKILL_MAX]) {
                x = skills[s][SKILL_MAX];
            } else {
                skills[s][SKILL_ADV] = 1;
            }
        }
        sum += x * skills[s][SKILL_WGT];
    }
    result = TASKER->attempt_task(min_level, sum, advance_chance,
                          (max_level - min_level));
    if ((result == FAIL) || (result == BARF)) {
        if (random(100) < backfire_chance) {
            ob = clone_object(REAGENTS+"brew_reagent.ob");
            ob->set_medium_alias(backfire_alias);
            ob->set_amount(sum*rel_strength/min_level);
            return ob;
        }
        return 0;
    }
    if (result == AWARD) {
        for (i = 0; i < sizeof(skill_str); i++) {
            s = skill_str[i];
            if (skills[s][SKILL_ADV]) {
                this_player()->add_skill_level(s, 1, 0);
            }
        }
    }
    ob = clone_object(REAGENTS+"brew_reagent.ob");
    ob->set_medium_alias(reagent_alias);
    ob->set_amount(sum*rel_strength/min_level);
    return ob;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/fungi/rust_fungus.c ===
inherit "/obj/fungus";
void setup() {
  set_adjs( "rust" );
  set_type( "fungus" );
  set_extra( "It looks like a lump of rust, only soft and a bit squishy." );
  set_messages( ({
    "A small $type$ sprouts on the metal.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ silently releases a red dust into the air.\n",
    "The $type$ collapses in on itself and falls apart.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/strength_boost", 2000 +
        random( 1000 ) );
  ::next_stage();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/fungi/glow_toadstool.c ===
inherit "/obj/fungus";
void setup() {
  set_adjs( "yellow spotted" );
  set_type( "toadstool" );
  set_extra( 0 );
}
void next_stage() {
  if ( stage == 8 ) {
    tell_room( environment(), "The yellow spots on the toadstool begin to "+
        "glow.\n" );
    set_light( 5 );
    set_long( query_long() +"The yellow spots are glowing.\n" );
  }
  ::next_stage();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/fungi/fire_mushroom.c ===
inherit "/obj/fungus";
void setup() {
  set_adjs( "red stalked" );
  set_type( "mushroom" );
  set_extra( "It seems to be gently smoking." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ swells and suddenly releases a cloud of smoke.\n",
    "There is a flash at the base of the $type$ and with a small roar, it "+
        "rockets into the sky.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/basic_charging", 20 +
        random( 11 ) );
  ::next_stage();
}
int query_charging_power() {
  int denominator, numerator, wholes;
  mapping eat_effects;
  eat_effects = query_eat_effects();
  if ( !query_continuous() )
    return eat_effects[ "/std/effects/ingested/basic_charging" ] *
      (int)this_object()->query_weight();
  denominator = query_weight_unit()[ 1 ];
  numerator = eat_effects[ "/std/effects/ingested/basic_charging" ] *
    query_amount() * query_weight_unit()[ 0 ];
  wholes = numerator / denominator;
  numerator %= denominator;
  if ( random( denominator ) < numerator )
    wholes++;
  return wholes;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/fungi/magic_mushroom.c ===
inherit "/obj/fungus";
void setup() {
  set_adjs( "checkered" );
  set_type( "mushroom" );
  set_extra( "The checks are nice pastel shades of peach and mauve." );
  set_messages( ({
    "A small $type$ pushes up through the soil.\n",
    "The $type$ seems to be a bit larger now.\n",
    "The $type$ looks nice and large now.\n",
    "The $type$ jumps up and down very quickly, and then burps.\n",
    "You hear a small voice say: Goodbye, cruel world!\nThe $type$ "+
        "falls over and disintegrates.\n"
  }) );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/hallucination", 150 +
        random( 150 ) );
  ::next_stage();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/fungi/blue_nightcap.c ===
inherit "/obj/fungus";
void setup() {
  set_adjs( "blue capped" );
  set_type( "mushroom" );
  set_extra( "The shape of it reminds you of someone wearing a nightcap." );
}
void next_stage() {
  if ( stage == 8 )
    add_eat_effect( "/std/effects/ingested/tranquil_sleep", 60 +
        random( 60 ) );
  ::next_stage();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/reagents/ketchup.ob ===
::#Debug:: 1
::#Class:: "/obj/food.c"
::Name:: "ketchup"
::Short:: "ketchup"
::Long:: "This is some ketchup, $amount_size$.  So where's the rats?\n"
::Adjective:: "some"
::Plural:: "ketchup"
::$set_medium_alias:: "TomatoKetchup"
::$set_amount_types:: ([ "drop": ({ 1, "drops" }),
			 "teaspoon": ({ 20, "teaspoons" }),
			 "tablespoon": ({ 60, "tablespoons" }),
			 "ounce": ({ 120, "ounces" }),
			 "cup": ({ 960, "cups" }),
			 "pint": ({ 2400, "pints" }),
                         "quart": ({ 4800, "quarts" }),
                         "gallon": ({ 19200, "gallons" }) ])
::Adjective:: ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",
                 "tablespoons", "ounce", "ounces", "cup", "cups", "pint",
                 "pints", "quart", "quarts", "gallon", "gallons", "of" })
::$set_amount:: 2400
::$set_continuous::
::$set_liquid::
::$set_pile_types:: ({ 50, "small", 100, "medium", "large" })
::Property:: "determinate", ""


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/reagents/.generic_liquid.ob_virtual_.c ===
#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/reagents/generic_liquid.ob#1" );
  call_other( clone, "add_adjective",  "some"  );
  call_other( clone, "add_alias",  "liquid"  );
  call_other( clone, "set_amount_types",  ([ "drop": ({ 1, "drops" }),              "teaspoon": ({ 20, "teaspoons" }),              "tablespoon": ({ 60, "tablespoons" }),              "ounce": ({ 120, "ounces" }),              "cup": ({ 960, "cups" }),              "pint": ({ 2400, "pints" }),                          "quart": ({ 4800, "quarts" }),                          "gallon": ({ 19200, "gallons" }) ])  );
  call_other( clone, "add_adjective",  ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",                "tablespoons", "ounce", "ounces", "cup", "cups", "pint",                "pints", "quart", "quarts", "gallon", "gallons", "of" })  );
  call_other( clone, "set_pile_types",  ({ 50, "small", 100, "medium", "large" })  );
  call_other( clone, "set_continuous",   );
  call_other( clone, "set_liquid",   );
  call_other( clone, "add_property",  "determinate", "" );
   return clone;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/reagents/.generic_liquid.ob_virtual_.c.old ===
#include <virtual.h>

void dest_me() { destruct( this_object() ); }

void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
} /* create() */

object create_virtual_ob() {
   object clone;

  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( "virtual name", "/obj/reagents/generic_liquid.ob#1" );
  call_other( clone, "add_adjective",  "some"  );
  call_other( clone, "add_property",  "determinate", "some "  );
  call_other( clone, "set_amount_types",  ([ "drop": ({ 1, "drops" }), 			 "teaspoon": ({ 20, "teaspoons" }), 			 "tablespoon": ({ 60, "tablespoons" }), 			 "ounce": ({ 120, "ounces" }), 			 "cup": ({ 960, "cups" }), 			 "pint": ({ 2400, "pints" }),                          "quart": ({ 4800, "quarts" }),                          "gallon": ({ 19200, "gallons" }) ])  );
  call_other( clone, "add_adjective",  ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",                  "tablespoons", "ounce", "ounces", "cup", "cups", "pint",                  "pints", "quart", "quarts", "gallon", "gallons", "of" })  );
  call_other( clone, "set_pile_types",  ({ 50, "small", 100, "medium", "large" })  );
  call_other( clone, "set_continuous",   );
  call_other( clone, "set_liquid",  );
   return clone;
} /* create_virtual_ob() */


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/reagents/generic_liquid.ob ===
::#Class:: "/obj/food.c"
::Adjective:: "some"
::Alias:: "liquid"
::$set_amount_types:: ([ "drop": ({ 1, "drops" }),
             "teaspoon": ({ 20, "teaspoons" }),
             "tablespoon": ({ 60, "tablespoons" }),
             "ounce": ({ 120, "ounces" }),
             "cup": ({ 960, "cups" }),
             "pint": ({ 2400, "pints" }),
                         "quart": ({ 4800, "quarts" }),
                         "gallon": ({ 19200, "gallons" }) ])
::Adjective:: ({ "drop", "drops", "teaspoon", "teaspoons", "tablespoon",
               "tablespoons", "ounce", "ounces", "cup", "cups", "pint",
               "pints", "quart", "quarts", "gallon", "gallons", "of" })
::$set_pile_types:: ({ 50, "small", 100, "medium", "large" })
::$set_continuous::
::$set_liquid::
::Property:: "determinate", ""



=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/b_day/happy ===
:takes a deep breath...
sing "Happy Birthday to you"
sing "Happy Birthday to you"
sing "Happy Birthday, dear $N"
:pauses for breath...
sing "Happy Birthday to yoooou."
sing "The End!"
hug $n in a way that only a tiny paper demon could
:waves a minute pointed hand.
:frowns, then folds itself into nothingness...


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/b_day/demon.c ===
#define SONG "/obj/b_day/happy"
inherit "/obj/monster";
int line;
object owner;
string owner_name;
string* act_lines = ({
  ":takes a deep breath...",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday to you\"",
  "sing \"Happy Birthday, dear $N\"",
  ":pauses for breath...",
  "sing \"Happy Birthday to yoooou.\"",
  "sing \"The End!\"",
  "hug $n in a way that only a tiny paper "
    "demon could",
  ":waves a minute pointed hand.",
  ":frowns, then folds itself into nothingness..."
});
void setup()
{
  set_name("demon");
  set_short("origami demon");
  add_adjective("tiny");
  add_adjective("pink");
  add_adjective("paper");
  add_adjective("origami");
  set_main_plural("origami demons");
  add_plural("demons");
  set_long("This is a tiny, pink, paper demon. Looking closely you see "
           "that it has been made by someone with a black belt in "
           "Origami!\n");
  set_race("demon");
  set_level(1);
  line = 1;
}
void set_owner(string person_name)
{
  owner = find_living(lower_case(person_name));
  owner_name = person_name;
}
void do_the_act(int i)
{
  string line_to_act;
  if(i >= sizeof(act_lines)) {
    dest_me();
    return;
  }
  if(environment(owner) != environment()) {
    tell_room(environment(), "The origami demon rustles after "
              + owner_name + ".\n");
    move(environment(owner));
    tell_room(environment(), "The origami demon rustles in.\n" );
    do_command("'Hey "+owner_name+"! I hadn't finished!\n");
    return;
  }
  line_to_act = act_lines[i];
  line_to_act = replace(line_to_act, ({"$N", owner_name,
                                       "$n", lower_case(owner_name) }));
  if(!strlen(line_to_act)) {
    set_heart_beat(0);
    dest_me();
    return;
  }
  do_command(line_to_act);
  i++;
  if(owner) {
    call_out("do_the_act", 2, i);
  }
  return;
}
void attack_by( object thing ){
  if( !thing) return;
  if( environment( thing ) != environment() ) return;
  this_object()->stop_fight (thing);
  thing->stop_fight (this_object());
  init_command("say Meanie!  Shame on you!  I shall finish what I "
               "started and then I shall be off.  You don't really "
               "deserve this, you know.", 1);
  return;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/b_day/card.c ===
#define DEMON "/obj/b_day/demon"
#include <player_handler.h>
inherit "/std/object";
int creator_status, is_open = 0;
int opened_before = 0;
string owner_name, owner_language;
string* colour_array = ({
  "%^RED%^", "%^BOLD%^%^RED%^",
  "%^MAGENTA%^", "%^BOLD%^%^MAGENTA%^",
  "%^ORANGE%^", "%^YELLOW%^",
  "%^GREEN%^", "%^BOLD%^%^GREEN%^",
  "%^WHITE%^", "%^BOLD%^%^WHITE%^",
  "%^CYAN%^", "%^BOLD%^%^CYAN%^"
  });
void setup_card(string name, string language, int status);
mapping init_query_static_auto_load() {
  return ([ "::" : ::int_query_static_auto_load(),
          "owner_name":owner_name,
          "owner_language":owner_language,
          "is_open":is_open,
          "opened_before":opened_before]);
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] ) {
    ::init_static_arg( map[ "::" ] );
  }
  if ( !undefinedp( map[ "owner_name" ] ) ) {
    owner_name = map[ "owner_name" ];
  }
  if ( !undefinedp( map[ "owner_language" ] ) ) {
    owner_language = map[ "owner_language" ];
  }
  if ( !undefinedp( map[ "is_open" ] ) ) {
    is_open = map[ "is_open" ];
  }
  if ( !undefinedp( map[ "opened_before" ] ) ) {
    opened_before = map[ "opened_before" ];
  }
}
mapping query_static_auto_load()
{
  if ( explode( file_name( this_object() ), "#" )[ 0 ] ==
       "/obj/b_day/card" ) {
    return init_query_static_auto_load();
  }
  return 0;
}
mixed *query_read_mess()
{
  if(!is_open) {
    return ({ ({ "The card is addressed to " + owner_name +
                   ".  Maybe you should open it?  Then again, if "
                   "you're not " + owner_name + ", maybe you "
                   "shouldn't.\n",
                   0, owner_language, 1 }) });
  }
  return ::query_read_mess();
}
void set_closed_mesg()
{
    set_long("The closed card has been carefully handmade from pink "
        "cardboard. There is a rather vague illustration of a "
        "non-identifiable piece of flora on the front.\n");
}
void set_open_mesg()
{
    set_long("The open card has been carefully handmade from pink "
        "cardboard.\n");
}
void setup_card(string own_name, string own_language, int cre_status)
{
  string *wizards, list;
  int i;
  owner_name = own_name;
  owner_language = own_language;
  creator_status = cre_status;
  set_short(owner_name + "'s birthday card");
  add_adjective( ({ owner_name, owner_name + "'s"}) );
  wizards = get_dir("/w/");
  if(creator_status) {
    int start = member_array(lower_case(owner_name), wizards);
    wizards = wizards[0..start-1] + wizards[start+1..];
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
      "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += colour_array[random(sizeof(colour_array))] +
          capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += "%^RESET%^.\n\n";
        else if(i == sizeof(wizards)-2) list += "%^RESET%^ and ";
        else list += ",%^RESET%^ ";
      }
    }
    list += "... and thanks for all your work and time, and let's hope "
      "next year will be even more magical and fun, fun, fun!\n";
  } else {
    list =
      "\n    Have a wonderful birthday, " + owner_name + "!!!  \n"
        "    LOVE AND KISSES FROM...                \n\n";
    for(i=0;i<sizeof(wizards);i++) {
      if(PLAYER_HANDLER->test_user(wizards[i])) {
        list += capitalize(wizards[i]);
        if(i == sizeof(wizards)-1) list += ".\n";
        else if(i == sizeof(wizards)-2) list += " and ";
        else list += ", ";
      }
    }
  }
  add_read_mess(list, "various hands", owner_language, 1);
}
void setup()
{
  set_name("card");
  set_short("birthday card");
  add_adjective("birthday");
  set_main_plural("birthday cards");
  add_property("determinate", "");
  add_property("no recycling", 1);
  set_closed_mesg();
  if(owner_name && owner_language) {
    setup_card(owner_name, owner_language, creator_status);
  }
}
void init()
{
    this_player()->add_command("open", this_object());
    this_player()->add_command("close", this_object());
}
int do_open()
{
    object demon;
    if(is_open) {
        write("It is already open.\n");
        return 1;
    }
    if(lower_case(owner_name) != this_player()->query_name()) {
      add_succeeded_mess( ({
        "*** POP ***\n"
          "An Origami Demon peers out from the card, sees you're not "
          + owner_name + ", mutters about that not being very "
          "low-temperature, and vanishes back into the card.\n",
        "*** POP ***\n"
          "An Origami Demon peers out from " + owner_name + "'s "
          "birthday card at " + this_player()->query_cap_name() +
          ", smirks and crawls back into the card.\n"
      }) );
      return 1;
    }
    is_open = 1;
    set_open_mesg();
    if(opened_before) return 1;
    opened_before = 1;
    demon = clone_object(DEMON);
    demon->move(environment(this_player()));
    demon->set_owner(owner_name);
    demon->add_language(owner_language);
    demon->set_language(owner_language);
    add_succeeded_mess( ({
      "*** POP ***\n"
        "An Origami Demon explodes from your card as you open it!\n",
      "*** POP ***\n"
        "An Origami Demon explodes from " + owner_name + "'s birthday "
        "card as " + owner_name +" opens it!\n"
    }) );
    call_out("start_demon", 2, demon);
    return 1;
}
void start_demon(object thing) {
  thing->do_the_act(0);
}
int do_close()
{
    if(!is_open) {
        write("It is not open for you to close!\n");
        return 1;
    }
    is_open = 0;
    set_closed_mesg();
    return 1;
}
mixed *stats()
{
  return ::stats() + ({ ({ "owner name",owner_name }),
                          ({ "owner language",owner_language }), });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/examples/exa3.c ===
#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("third simple room");
  set_long("This is the third example room. Will you ever get to the end? " +
           "Directly above your head is a plaque, nailed to the wall.\n");
  set_light(90);
  add_sign("The plaque is made of bronze.\n",
           "'Don't read me, I'm only an example sign you know!'\n",
           0,
           "plaque");
  add_exit("west", ROOM + "exa2", "door");
  add_exit("east", ROOM + "exa4", "door");
  set_zone("examples");
}
void reset()
{
  object bar;
  if(sizeof(match_objects_for_existence("copper bar", ({ this_object() }) )))
    return;
  bar = clone_object("/std/object");
  bar->set_name("bar");
  bar->add_adjective("copper");
  bar->set_main_plural("copper bars");
  bar->add_plural("bars");
  bar->set_short("copper bar");
  bar->set_long("This is just a treasure thingie to show you how to use " +
                  "such fun things.\n");
  bar->set_weight(80);
  bar->set_value(2000);
  bar->move(this_object());
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/examples/response_mon.c ===
inherit "/w/pinkfish/tmp/response_mon";
object weapc;
string *tale;
void setup() {
    set_name("guard");
    add_adjective(({ "big", "gate" }));
    set_short("Big gate guard");
    set_long("This is one of the common guards of Amber.  "+
     "He looks quite big, maybe you shouldn't upset him...\n");
    set_race("human");
    set_class("fighter");
    set_level(45);
    set_al(250);
    set_gender(1);
    tale = ({ "There once was a frog with 5 legs.\n",
              "This frog was very very unhappy.\n",
              "All other frogs made fun of him.\n",
              "And no lady frog wanted to marry him.\n",
              "One day, a womble appeared, and bit one of his legs off.\n",
              "Since then the frog had 4 legs, and lived happily ever after.\n"
            });
    set_respond_to_with(([ ({ "help", "me" }) : "'I can't help you." ,
                         ({ ({ "hi","hello","greetings" }) }) :
                                      ({ "'Hello $hcname$.",
                                         "emote salutes you." }),
                            ({ ({ "remove","unwield","unhold" }),
                               ({ "axe","weapon" }) }) :
                                       "#remov",
                            ({ ({ "wield","hold" }),
                               ({ "axe","weapon" }) }) :
                                       "#wiel",
                            ({ "tell" , "story" }) :
                                      "#story" ]));
  weapc = clone_object("/obj/weapons/axe.wep");
  weapc->move(this_object());
  do_equip();
}
int remov() {
  init_command("unhold axe");
}
int wiel() {
 init_command("hold axe");
}
void story(object tpl) {
  command("'Very well, "+tpl->query_cap_name()+ " I will tell you a story.\n");
  set_stop_responding(1);
  call_out("tell_story",2,0);
}
void tell_story(int arg) {
  remove_call_out("tell_story");
  if (arg == sizeof(tale)) {
    set_stop_responding(0);
    return ;
  }
  command("'"+tale[arg]);
  call_out("tell_story",2,arg+1);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/examples/path.h ===
#define ROOM "/obj/examples/"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/examples/exa2.c ===
#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("second simple room");
  set_long("This is the second example room. It introduces items, and " +
           "aliasing - again use 'more here' to look at it. Over by the " +
           "north wall you can see a table.\n");
  set_light(90);
 add_item("table",
          "The table is one step away from being firewood. Upon it rests " +
          "a blotter.\n");
 add_item( ({ "north wall", "wall" }),
          "It is very flat and is holding up rather a ricketty table.\n");
 add_item("blotter",
          "It is covered in random ink blots.\n");
  add_exit("west", ROOM + "exa1", "door");
  add_exit("east", ROOM + "exa3", "door");
  set_zone("examples");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/examples/exa1.c ===
#include "path.h"
inherit "/std/room";
void setup()
{
  set_short("first simple room");
  set_long("This is a simple room, have fun with it. To read the code " +
           "simply type 'more here'. For help with more, type 'h' in it.\n");
  set_light(90);
  add_exit("east", ROOM + "exa2", "door");
  set_zone("examples");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/scabbards/.belt_loop.sca_virtual_.c ===
#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/belt_loop.sca#1" );
  call_other( clone, "set_name", "loop"  );
  call_other( clone, "add_adjective", ({ "belt", "belt loop" })  );
  call_other( clone, "add_alias", "belt loop"  );
  call_other( clone, "set_short", "belt loop"  );
  call_other( clone, "set_long", "This loop is made from the finest leather, designed to "         "hold axes or hammers safely.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_value", 800  );
  call_other( clone, "set_type", "belt scabbard"  );
  call_other( clone, "add_property", "no recycling", 1  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "axe","hammer" }) );
   return clone;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/scabbards/dagger_scabbard.sca ===
::Name::"scabbard"
::Adjective::"dagger"
::Short::"dagger scabbard"
::Long::"Similar in design to the scabbard made for longer bladed weapons."
        "  In fact you could say they were the same, except for the size.\n"
::Weight::3
::Value::30
::Type::"small scabbard"
::Setup::10000
::Damage Chance::15
::Types::({ "dagger", "knife" })


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/scabbards/bone_knife_scabbard.sca ===
::Name::"scabbard"
::Adjective::({ "bone", "knife", "bone knife" })
::Short::"bone knife scabbard"
::Long::"This is a white scabbard made fromn the bone of some poor"
        "beast that was killed long ago by someone.  The bone is "
        "roughly cut and shapped.\n" 
::Weight::3
::Value::100
::Type::"small scabbard"
::Setup::10000
::Damage Chance::15
::Types::({ "bone knife" })


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/scabbards/.dagger_scabbard.sca_virtual_.c ===
#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/scabbard.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/scabbards/dagger_scabbard.sca#1" );
  call_other( clone, "set_name", "scabbard"  );
  call_other( clone, "add_adjective", "dagger"  );
  call_other( clone, "set_short", "dagger scabbard"  );
  call_other( clone, "set_long", "Similar in design to the scabbard made for longer bladed weapons."         "  In fact you could say they were the same, except for the size.\n"  );
  call_other( clone, "set_weight", 3  );
  call_other( clone, "set_value", 30  );
  call_other( clone, "set_type", "small scabbard"  );
  call_other( clone, "setup_scabbard", 10000  );
  call_other( clone, "set_damage_chance", 15  );
  call_other( clone, "set_types", ({ "dagger", "knife" }) );
   return clone;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/scabbards/belt_loop.sca ===
::Name::"loop"
::Adjective::({ "belt", "belt loop" })
::Alias::"belt loop"
::Short::"belt loop"
::Long::"This loop is made from the finest leather, designed to "
        "hold axes or hammers safely.\n"
::Weight::8
::Value::800
::Type::"belt scabbard"
::property::"no recycling", 1
::Setup::10000
::Damage Chance::15
::Types::({ "axe","hammer" })


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/media/sand.c ===
inherit "/obj/cont_medium";
void setup()
{
  set_name("sand");
  set_short("sand");
  set_main_plural( "sand" );
  add_adjective( ({ "some", "grain", "pinch", "measure", "handful",
    "hatful", "beach", "of" }) );
  set_long("This is some lovely soft sand, the type that you'd find on "
    "a beach.\n");
  add_property("determinate", "some ");
  set_weight_unit( ({ 1, 1000 }) );
  set_value_scale( 0.00001 );
  set_medium_alias("BeachAndDesertSand");
  set_pile_name("pile");
  set_continuous();
  set_amount_types( ([
    "grain": ({ 1, "grains" }),
    "pinch": ({ 40, "pinches" }),
    "measure": ({ 200, "measures" }),
    "handful": ({ 10000, "handfuls" }),
    "hatful": ({ 50000, "hatfuls" }),
    "beach": ({ 1000000, "beaches" }),
    ]) );
  set_pile_types( ({
    40, "tiny",
    10000, "small",
    50000, "medium",
    200000, "large",
    "huge"
    }) );
  set_amount(12000);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/team.c ===
#define CREATOR "Ceres"
#include <login_handler.h>
#define SHADOW "/std/shadows/misc/team"
#define MAX_GROUP_SIZE 5
class group {
  object leader;
  int policy;
  object *members;
  int locked;
}
mapping groups,
        members;
private void check_group(string g_name);
private void disband_group(string g_name, string p_name);
private void tidy_members(string g_name);
void create() {
  members = ([ ]);
  groups = ([ ]);
}
void dest_me() {
  destruct(this_object());
}
void leaving(string p_name, string type) {
  class group record;
  string g_name;
  if((type != "logout") || (!members[p_name]))
    return;
  g_name = members[p_name];
  record = (class group)groups[g_name];
  map_delete(members, p_name);
  if(!record)
    return;
  if((record->leader == 0) || ((record->leader)->query_name() == p_name)) {
     disband_group(g_name, p_name);
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s has left the game, the %s has been "
                             "disbanded.\n", ctime(time()), p_name, g_name));
#endif
  } else {
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left the game while a member of the %s\n",
                             ctime(time()), p_name, g_name));
#endif
    record->members = delete(record->members,
                             member_array(0, record->members), 1);
  }
  return;
}
int new_group(string g_name, object leader, int policy) {
  class group record;
  if(!undefinedp(groups[g_name]))
    return 0;
  record = new(class group);
  record->leader = leader;
  record->policy = policy;
  record->members = ({ leader });
  groups[g_name] = record;
  members[leader->query_name()] = g_name;
  leader->set_title( "TEAM", "Team Leader of "+ g_name );
   clone_object( SHADOW )->setup_shadow( leader );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s created by %s\n", ctime(time()),
                           g_name, leader->query_name()));
#endif
  return 1;
}
int end_group(string g_name) {
  class group record;
  object player;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
   foreach( player in record->members )
      if ( player ) {
         map_delete( members, player->query_name() );
         player->remove_title( "TEAM" );
         player->destruct_team_shadow();
      }
  map_delete(groups, g_name);
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s disbanded\n", ctime(time()), g_name));
#endif
  return 1;
}
int join_group(string g_name, object player) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  record->members += ({ player });
  members[player->query_name()] = g_name;
   player->set_title( "TEAM", "Team Member of "+ g_name );
   clone_object( SHADOW )->setup_shadow( player );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s joined by %s\n", ctime(time()),
                           g_name, player->query_name()));
#endif
  return 1;
}
int leave_group(string g_name, object player) {
  class group record;
  if(player) {
    map_delete(members, player->query_name());
      player->remove_title( "TEAM" );
      player->destruct_team_shadow();
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left by %s\n", ctime(time()), g_name,
                             player->query_name()));
#endif
  }
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  if(member_array(player, record->members) == -1)
    return -1;
  record->members = delete(record->members,
                           member_array(player, record->members), 1);
  return 1;
}
object query_owner(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return record->leader;
}
object *query_members(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = groups[g_name];
  return (object *)record->members;
}
int query_policy(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  return (int)record->policy;
}
string query_group(object player) {
  if(undefinedp(members[player->query_name()]))
    return 0;
  return members[player->query_name()];
}
int test_group(string g_name) {
  if(undefinedp(groups[g_name]))
    return 0;
  return 1;
}
int query_full(string g_name) {
  class group record;
  object member;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = (class group)groups[g_name];
  if(sizeof(record->members) >= MAX_GROUP_SIZE)
    return 1;
  return 0;
}
int query_locked(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return (record->locked);
}
int set_locked(string g_name, int lock) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  record->locked = lock;
  return 1;
}
string *list_groups() {
  string frog;
  foreach (frog in keys(groups)) {
    check_group(frog);
  }
  return keys(groups);
}
private void disband_group(string g_name, string p_name) {
  class group record;
  object person;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members) {
    if(!member)
      break;
    map_delete(members, member->query_name());
    foreach(person in member->query_protectors())
      member->remove_protector(person);
    foreach(person in member->query_followers())
      member->remove_follower(person);
    tell_object(member, p_name+" has left the game and so the "+g_name+
                " has been disbanded.\n");
  }
  map_delete(groups, g_name);
}
private void check_group(string g_name) {
  class group record;
  record = (class group)groups[g_name];
  if (record->leader == 0) {
    disband_group(g_name, "Your leader");
  } else {
    record->members -= ({ 0 });
  }
}
private void tidy_members(string g_name) {
  class group record;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members)
    if(!member)
      record->members -= ({ 0 });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/cmr_library.c ===
#define RESTORE_PATH "/save/cmr_library/"
inherit "/std/object";
string player_name, *materials;
void init_data( string pname ) {
  player_name = pname;
  materials = ({ });
}
int get_data_file( string pname ) {
  if ( player_name != pname ) {
    if ( file_size( RESTORE_PATH + pname +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + pname :));
    else {
      init_data( pname );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
string *query_known_materials( string pname ) {
  get_data_file( pname );
  if ( !materials ) {
    return ({ });
  }
  return materials + ({ });
}
int query_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( !materials ) return 0;
  return ( member_array( material, materials ) != -1 );
}
int add_known_material( string pname, string material ) {
  get_data_file( pname );
  if ( member_array( material, materials ) != -1 ) {
    return 0;
  }
  materials += ({ material });
  save_data_file( player_name );
  return 1;
}
