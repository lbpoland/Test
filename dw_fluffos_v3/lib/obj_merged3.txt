
==================================================
FILE: handlers/nmoney_handler.c
==================================================

#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#undef USE_VAULT
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = values[ where ];
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   m_array = (mixed *)money->query_money_array();
   money->dest_me();
   return filter_legal_money_array(m_array, where);
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   int i;
   object good, no_good;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ 0, 0 });
   }
   if (!(poss_values = values[where])) {
      poss_values = ({ });
   }
   if (!where || where == "") {
     where = "default";
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   if (sizeof(good_array) == 0) {
      good = 0;
   }
   else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(good_array);
   }
   if (sizeof(no_good_array) == 0) {
      no_good = 0;
   }
   else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(no_good_array);
   }
   return ({ good, no_good });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[0]) < m_array[1]) {
            return NO_MATCH;
         }
      }
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      m_array = ({ });
      foreach (thing in things)  {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if (monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#endif
   }
   else
      m_array = ({ });
   if (monies[0])  {
      m_array2 = copy(monies[0]->query_money_array());
      for (i = 0; i < sizeof(m_array2); i += 2)
         m_array2[i + 1] = -m_array2[i + 1];
      merge_money_arrays(m_array, m_array2);
      this_player()->adjust_money(m_array);
      return monies[0];
   }
   else return NO_LEGAL;
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   for ( i = 1; i < sizeof( values ); i += 2 ) {
      if ( !smallest || ( values[i] < smallest ) ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r];
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

==================================================
FILE: handlers/non_refuelling_lantern.c
==================================================

#include <fuel_handler.h>
inherit "/std/object";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
int  fuel_left;
int  is_lit;
void create(){
  ::create();
}
string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
  return ::short( 0 );
}
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
}
int do_dowse() {
   return do_extinguish();
}
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}
void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}
void out_of_fuel() {
   object env;
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else
      say( poss_short() +" burns out.\n" );
}
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
   }
}
string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
  return ::pretty_plural(thing);
}
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
}
void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
}
int query_fuel_left() {
    return fuel_left;
}
void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }
    fuel_left = i;
}
int query_max_fuel() {
    return MAX_FUEL;
}

==================================================
FILE: handlers/nquest_handler.c
==================================================

#include <player_handler.h>
#define LIBRARY "/obj/handlers/nlibrary"
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}

==================================================
FILE: handlers/nroff.c
==================================================

#include <nroff.h>
mixed *nroffed_file;
string nroffed_file_name;
int modified_time;
nosave int new_string;
nosave int force_string;
void create() {
  nroffed_file = ({ });
  seteuid("Root");
}
#define do_bounds(bing) (bing<0?bing+cols:bing)
string cat_file(string fname, int update) {
   int i;
   int k;
   int cols;
   string ret;
   string pat;
   mixed* tmp;
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname))
      return 0;
   if (!nroffed_file_name && update)
      return 0;
   if (update) {
      mixed *something;
      if (!master()->valid_read(nroffed_file_name,
                                geteuid(previous_object()),
                                "restore_object"))
         return 0;
      if (file_size(nroffed_file_name) <= 0)
         return 0;
      something = stat(nroffed_file_name);
      if (something[1] > modified_time)
         return 0;
   }
   ret = "";
   if (this_player()) {
      cols = (int)this_player()->query_cols();
   } else {
      cols = 79;
   }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += nroffed_file[i];
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += sprintf("%%^BOLD%%^%s%%^RESET%%^\n", nroffed_file[i+1]);
            i++;
            break;
          case V_CENTER :
            ret += sprintf("%|=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_ALL :
            ret += "%^BOLD%^\n" + sprintf("%-s%*|s%*s\n",
                           nroffed_file[i+2],
                           cols - nroffed_file[i+1]*2,
                           nroffed_file[i+3],
                           nroffed_file[i+1],
                           nroffed_file[i+4]) + "%^RESET%^\n";
            i += 4;
            break;
          case V_INDENT :
            ret += sprintf( "%*=s%-=*s", nroffed_file[ i + 1 ], "",
                           cols - nroffed_file[ i + 1 ], nroffed_file[ i + 2 ] );
            i += 2;
            break;
          case V_PARA :
            if (nroffed_file[i+1])
            ret += sprintf("%*=s%-=*s%=*s\n", nroffed_file[i+1], "",
                           cols-nroffed_file[i+1]-
                           nroffed_file[i+2], nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else if (nroffed_file[i+2])
            ret += sprintf("%-=*s%=*s\n", cols-nroffed_file[i+2],
                           nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else
            ret += sprintf("%-=*s\n", cols, nroffed_file[i+3]);
            i += 3;
            break;
          case V_LEFT :
            ret += sprintf("%-=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_TABLE :
            ret += sprintf("%-#*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_COLUMN : {
             int j;
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s\n", do_bounds(nroffed_file[i+1][0]),
                                  nroffed_file[i+2][j],
                                  do_bounds(nroffed_file[i+1][1]),
                                  nroffed_file[i+3][j]);
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s%*-=s\n",
                               do_bounds(nroffed_file[i+1][0]),
                               nroffed_file[i+2][j],
                               do_bounds(nroffed_file[i+1][1]),
                               nroffed_file[i+3][j],
                               do_bounds(nroffed_file[i+1][2]),
                               nroffed_file[i+4][j]);
                }
                i += 4;
                break;
             default :
                pat = implode(allocate(sizeof(nroffed_file[i+1]), "%*-=s"), "");
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   tmp = ({ });
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      tmp += ({ do_bounds(nroffed_file[i+1][k]),
                                nroffed_file[i+2+k][j] });
                   }
                   ret += sprintf(pat + "\n", tmp ... );
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             break;
          }
         }
      }
   }
   return " \n"+ret;
}
private string htmlify(string  str) {
  return replace(str, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;"}));
}
string html_file(string file, string title) {
   int i, j, cols, in_bold, in_italic;
   int k;
   string ret, *bits;
   if (!master()->valid_read(file, geteuid(previous_object()),
                             "restore_object"))
      return 0;
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(file))
      return 0;
   ret = "";
   cols = 78;
   for (i=0;i<sizeof(nroffed_file);i++)
     if (stringp(nroffed_file[i]))
       nroffed_file[i] = htmlify(nroffed_file[i]);
     else if(arrayp(nroffed_file[i])) {
       for (j=0;j<sizeof(nroffed_file[i]);j++)
         if(stringp(nroffed_file[i][j]))
           nroffed_file[i][j] = htmlify(nroffed_file[i][j]);
     }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += "<h3>"+nroffed_file[i]+"</h3>";
#ifdef UNUSED
         if(strsrch(nroffed_file[i], "See also") > -1) {
           for(j=i+1; j < sizeof(nroffed_file); j++) {
             if(stringp(nroffed_file[j])) {
               nroffed_file[j] = make_links(nroffed_file[j]);
             }
           }
         }
#endif
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += "<h3>"+replace_string(nroffed_file[i+1], "\n", "<br>")+
              "</h3>";
            i++;
            break;
          case V_CENTER :
            ret += "<center>"+replace(nroffed_file[i+1], "\n", "<br>")+
            "</center>";
            i++;
            break;
          case V_ALL :
            ret += "\n<table width=100%><tr>\n" +
                   "<td nowrap width=* align=left><h2>" +
                   nroffed_file[i+2] + "</h2></td>\n" +
                   "<td nowrap align=center><h2>" +
                   nroffed_file[i+3] + "</h2></td>\n" +
                   "<td nowrap width=* align=right><h2>" +
                   nroffed_file[i+4] + "</h2></td>\n" +
                   "</tr></table>\n";
            i += 4;
            break;
          case V_INDENT :
            ret += replace(nroffed_file[i+2], ({"<", "&lt;", ">",
               "&gt;", "\n", "<br>"}));
            i += 2;
            break;
          case V_PARA :
            ret += replace(nroffed_file[i+3], "\n", "<p>");
            i += 3;
            break;
          case V_LEFT :
            ret += "<left>"+nroffed_file[i+1]+"</left>";
            i++;
            break;
          case V_TABLE :
            ret += "<ul><li>"+replace(nroffed_file[i+1], "\n", "<li>")+"</ul>";
            i++;
            break;
          case V_COLUMN : {
             ret += "<table cellpadding=10>";
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+3][j] + "</td>";
                  ret += "</tr>";
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td nowrap>"+nroffed_file[i+3][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+4][j] + "</td>";
                  ret += "</tr>";
                }
                i += 4;
                break;
             default :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += "<tr>\n";
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      ret += "<td nowrap>" + nroffed_file[i+2+k][j] + "</td>\n";
                   }
                   ret += "</tr>\n";
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             ret += "</table>";
             break;
          }
         }
      }
   }
   bits = explode(ret, "%^");
   ret = "";
   for (i=0;i<sizeof(bits);i+=2) {
      ret += bits[i];
    if (i+1 < sizeof(bits)) {
       switch (bits[i+1]) {
        case "BOLD" :
          if (!in_bold)
             ret += "<strong>";
          else
             ret += "</strong>";
          in_bold = !in_bold;
          break;
        case "RESET" :
          if (in_bold)
             ret += "</strong>";
          if (in_italic)
             ret += "</i>";
          in_bold = 0;
          in_italic = 0;
          break;
        default :
          if (!in_italic)
             ret += "<i>";
          else
             ret += "</i>";
          in_italic = !in_italic;
          break;
       }
    }
   }
   return ret;
}
private void add_array(mixed *i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
}
private void add_int(int i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
}
private void add_string(string s) {
  if (!sizeof(nroffed_file) || new_string) {
    nroffed_file += ({ s });
  } else if (stringp(nroffed_file[<1])) {
    nroffed_file[<1] += s;
  } else {
    nroffed_file += ({ s });
  }
  new_string = 0;
  force_string = 0;
}
int create_nroff(string in_file, string out_file) {
  string text,
         tmp,
         *bits;
  string *bing;
  mixed  *cols;
  int strip_crs,
      col_mode,
      conv_tabs,
      i, j, k, fluff,
      num_cols;
  if (!master()->valid_read(in_file, geteuid(previous_object()),
                            "read_file"))
    return 0;
  nroffed_file_name = in_file;
  modified_time = time();
  text = read_file(in_file);
  if (!text) {
    return 0;
  }
  bits = explode("#\n"+text, "\n.");
  bits[0] = bits[0][1..];
  nroffed_file = ({ 0 });
  if (strlen(bits[0])) {
    add_string(bits[0]);
  }
  for (i=1;i<sizeof(bits);i++) {
     if (sscanf(bits[i], "%s\n%s", tmp, bits[i]) != 2) {
        tmp = bits[i];
        bits[i] = "";
        fluff = 1;
     } else {
        fluff = 0;
     }
     switch (tmp[0..1]) {
      case "SH" :
        add_int(V_HEADER);
        add_string(tmp[3..]);
        new_string = 1;
        break;
      case "SI" :
        add_int(V_INDENT);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        force_string = 1;
        break;
      case "EI" :
        add_string("");
        new_string = 1;
        break;
      case "SP" :
        add_int(V_PARA);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        j = 0;
        sscanf(tmp, " %d%s", j, tmp);
        add_int(j);
        force_string = 1;
        strip_crs = 1;
        break;
      case "EP" :
        add_string("");
        new_string = 1;
        strip_crs = 0;
        break;
      case "SC" :
        add_int(V_CENTER);
        force_string = 1;
        break;
      case "EC" :
        new_string = 1;
        break;
      case "SL" :
        add_int(V_LEFT);
        force_string = 1;
        break;
      case "EL " :
        new_string = 1;
        break;
      case "ST" :
        add_int(V_TABLE);
        force_string = 1;
        conv_tabs = 1;
        break;
      case "ET" :
        new_string = 1;
        conv_tabs = 0;
        break;
      case "DT" :
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 3) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .DT directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0;
        }
        add_int(V_ALL);
        if (strlen(bing[0]) > strlen(bing[2]))
           add_int(strlen(bing[0]));
        else
           add_int(strlen(bing[2]));
        new_string = 1;
        add_string(bing[0]);
        new_string = 1;
        add_string(bing[1]);
        new_string = 1;
        add_string(bing[2]);
        new_string = 1;
        bits[i] = implode(bing[3..], "\n");
        break;
      case "SO" :
        num_cols = 0;
        tmp = tmp[2..];
        cols = ({ });
        while (sscanf(tmp, "%d%s", j, tmp) == 2) {
           cols += ({ j });
           num_cols++;
           while (strlen(tmp) && tmp[0] == ' ')
           tmp = tmp[1..];
        }
        add_int(V_COLUMN);
        if (sscanf(tmp, "%d", j) == 1) {
           cols += ({ j });
           num_cols++;
        }
        add_array(cols);
        cols = allocate(num_cols);
        for (j=0;j<num_cols;j++) {
           cols[j] = ({ });
        }
        col_mode = 1;
        break;
      case "EO" :
        for (j=0;j<num_cols;j++) {
           add_array(cols[j]);
        }
        col_mode = 0;
        break;
      case "NF" :
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 1) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .NF directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0;
        }
        text = read_file(bing[ 0 ]);
        if (!text) {
          return 0;
        }
        bits = explode("#\n"+text, "\n.");
        bits[0] = bits[0][1..];
        nroffed_file = ({ 0 });
        if (strlen(bits[0])) {
           add_string(bits[0]);
        }
        strip_crs = col_mode = conv_tabs = fluff = num_cols = i = 0;
        break;
     }
     if (fluff) {
        continue;
     }
     if (conv_tabs) {
        bits[i] = replace(bits[i], "\t", "\n");
     }
     if (col_mode) {
        string *frog;
        frog = explode(bits[i], "\n");
        for (k = 0; k < sizeof(frog); k++) {
           bing = explode("#"+frog[k], "\t");
           bing[0] = bing[0][1..];
           for (j = 0; j < num_cols && j < sizeof(bing); j++) {
              cols[j] += ({ bing[j] });
           }
           for (j = sizeof(bing);j < num_cols; j++) {
              cols[j] += ({ "\n" });
           }
        }
     } else if (strip_crs) {
        bits[i] = replace_string(bits[i], "\n\n", "$%^NeW_LiNe^%$");
        bits[i] = replace_string(bits[i], ".\n", ".  ");
        bits[i] = replace_string(bits[i], "\n", " ");
        bits[i] = replace_string(bits[i], "$%^NeW_LiNe^%$", "\n\n");
        add_string(bits[i]+" ");
     } else {
        add_string(bits[i]+"\n");
     }
  }
  new_string = 0;
  force_string = 0;
  unguarded((: save_object, out_file :));
  return 1;
}
string query_file_name( string fname ) {
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname)) {
      return 0;
   }
   return nroffed_file_name;
}

==================================================
FILE: handlers/options_handler.c
==================================================

#include <cmds/options.h>
#include <cmds/teach.h>
#include <colour.h>
#include <clubs.h>
#include <ls.h>
#include <obj_parser.h>
#include <player.h>
#include <creator.h>
#include <terrain_map.h>
#include <error_handler.h>
class option {
   mixed type;
   int restriction;
   function set;
   function query;
   mapping suboptions;
   string help;
}
private mapping _options;
private string* _colours;
private mapping _cache_input;
protected int add_option(string path, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help);
private int set_player_brief(object player, string variable, int value);
private int query_player_brief(object player, string variable);
private mapping get_inform_colours(object player);
private mapping get_club_colours(object player);
private int change_bool_property(string prop, object player, int new_value);
private int change_earmuffs(object player, string ear, int new_value);
private int setup_earmuffs(object player, string value);
private int valid_birthday(string str);
private string convert_birthday(string birthday);
private int change_error_reports(object player, string ear, int new_value);
void create() {
   string womble;
   _options = ([ ]);
   _cache_input = ([ ]);
   _colours = ({
    "BOLD",
    "FLASH",
    "BLACK",
    "RED",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "ORANGE",
    "YELLOW",
    "GREEN",
    "WHITE",
    "B_RED",
    "B_ORANGE",
    "B_YELLOW",
    "B_BLACK",
    "B_CYAN",
    "B_WHITE",
    "B_GREEN",
    "B_MAGENTA" });
   add_option("output look", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display room descriptions briefly or in full");
   add_option("output combat", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display all combat messages or only those involving damage");
   add_option("output errors", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display errors in the error handler briefly");
   add_option("output score", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Amount of detail to be displayed by the 'score' command");
   add_option("output accent", ({ "mangle", "unadulterated" }),
              OPTIONS_TYPE_ALL,
              (: $1->set_mangle_accent($3 == "mangle"), 1 :),
              (: $1->query_mangle_accent() ? "mangle" : "unadulterated" :),
              "Show others speech with or without regional accents");
   add_option("output names", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display player names with or without title and surname");
   add_option("output htell", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Cause the 'htell' command to display times for tells or not");
   add_option("output msgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgout($3) :),
              (: $1->query_msgout() :),
              "The message that is displayed when you walk out of a room");
   add_option("output msgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgin($3) :),
              (: $1->query_msgin() :),
              "The message that is displayed when you walk into a room");
   add_option("output mmsgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgout($3) :),
              (: $1->query_mmsgout() :),
              "The message that is displayed when you trans out of a room");
   add_option("output mmsgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgin($3) :),
              (: $1->query_mmsgin() :),
              "The message that is displayed when you trans into of a room");
   add_option("output usercolour",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_ALLOW_COLOURED_SOULS, 1):
                    $1->remove_property(PLAYER_ALLOW_COLOURED_SOULS), 1 :),
              (: $1->query_property(PLAYER_ALLOW_COLOURED_SOULS) :),
              "Display user chosen colours in souls");
   add_option("output plainmaps",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_PLAIN_MAPS, 1):
                    $1->remove_property(PLAYER_PLAIN_MAPS), 1 :),
              (: $1->query_property(PLAYER_PLAIN_MAPS) :),
              "Display terrain maps without colour");
   add_option("output lookmap", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3?$1->add_property(TERRAIN_MAP_IN_LOOK_PROP, 1):
                    $1->remove_property(TERRAIN_MAP_IN_LOOK_PROP), 1 :),
              (: $1->query_property(TERRAIN_MAP_IN_LOOK_PROP) :),
              "Display room a map in the terrain long or not");
   add_option( "output tabstops", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_CRE_ONLY,
              (: $1->add_property( TABSTOP_PROP, $3 ) :),
              (: $1->query_property( TABSTOP_PROP ) :),
               "Show tabstops as <TAB> or as spaces");
   add_option( "output shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_OUTPUT_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_OUTPUT_PROP ) :),
               "Convert others shorthand text into long form");
   foreach (womble in USER_COLOUR_LIST) {
      add_option("colour " + womble, OPTIONS_TYPE_COLOUR, 0,
                 (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                 "The colour for " + womble + " messages");
   }
   foreach (womble in ADDITIONAL_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   foreach (womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   add_option("colour inform", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_inform_colours :),
              "The colours of various informational messages");
   add_option("colour club", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_club_colours :),
              "The colour for club messages");
   add_option("terminal type", OPTIONS_TYPE_TERMINAL, 0,
              (: $1->set_term_type($3), 1 :),
              (: $1->query_term_name() :),
              "The type of terminal you are using");
   add_option("terminal rows", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_rows($3), 1 :),
              (: $1->query_rows() :),
              "The number of rows in your terminal");
   add_option("terminal cols", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_cols($3), 1 :),
              (: $1->query_cols() :),
              "The number of coloumns in your terminal");
    add_option("combat wimpy", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_wimpy($3) :),
              (: $1->query_wimpy() :),
               "The percentage of your hitpoints at which you will run away");
   add_option("combat monitor", MONITOR_OPTIONS, 0,
              (: $1->set_monitor(member_array($3, MONITOR_OPTIONS)), 1 :),
              (: MONITOR_OPTIONS[$1->query_monitor()] :),
              "The frequency of display of your combat monitor");
   add_option("combat tactics attitude",
              ({ "insane", "offensive", "neutral", "defensive", "wimp" }), 0,
              (: $1->set_combat_attitude($3), 1 :),
              (: $1->query_combat_attitude() :),
              "Your combat attitude (see help tactics)");
   add_option("combat tactics response",
              ({ "dodge", "neutral", "parry" }), 0,
              (: $1->set_combat_response($3), 1 :),
              (: $1->query_combat_response() :),
              "Your combat response (see help tactics)");
   add_option("combat tactics parry",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_parry($3), 1 :),
              (: $1->query_combat_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics unarmed_parry",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $1->set_unarmed_parry($3), 1 :),
              (: $1->query_unarmed_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics attack",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_attack($3), 1 :),
              (: $1->query_combat_attack() :),
              "Which hand you will attack with (see help tactics)");
#ifdef USE_SURRENDER
   add_option("combat tactics mercy",
              ({ "always", "ask", "never" }), 0,
              (: $1->set_combat_mercy($3), 1 :),
              (: $1->query_combat_mercy() :),
              "Whether or not you will show mercy to opponents");
#endif
   add_option("combat tactics focus",
              ({"upper body", "lower body", "head", "neck", "chest",
                  "abdomen", "arms", "hands", "legs", "feet", "none"}), 0,
              (: $1->set_combat_focus($3), 1 :),
              (: $1->query_combat_focus() :),
              "Which body part you will focus on in combat (see help tactics)");
#ifdef USE_DISTANCE
   add_option("combat tactics distance",
              ({"long", "medium", "close", "hand-to-hand", "none" }), 0,
              (: $1->set_combat_distance($3), 1 :),
              (: $1->query_combat_distance() :),
              "Your ideal combat distance (see help tactics)");
#endif
   add_option("combat killer",
              OPTIONS_TYPE_BOOLEAN, 1,
              (: $1->set_player_killer($3) :),
              (: $1->query_player_killer() :),
              "Whether or not you are a registered player killer");
   add_option("input ambiguous", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_AMBIGUOUS_PROP, $1, !$3) :),
              (: !$1->query_property(OBJ_PARSER_AMBIGUOUS_PROP) :),
              "Should the parser notify you of ambiguities");
   add_option("input andascomma", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP, $1, !$3) :),
          (: !$1->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP) :),
              "Should 'and' be treated as a comma (an inclusive list)");
   add_option("input editor", ({ "menu", "magic", "command", "ed" }), 0,
              (: $1->set_editor($3) :),
              (: $1->query_editor() :),
              "Your preferred editor");
   add_option( "input shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_PROP ) :),
               "Convert your shorthand typing into long form");
   foreach (womble in ({ "shout", "newbie", "cryer", "remote-soul",
                           "multiple-soul", "multiple-tell",  "teach",
                           "tell", "remote", "multiple-remote" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, 0,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ADDITIONAL_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ({ "lord", "intermud-all", "intercre",
                          "intergossip", "dwcre", "dwchat", "remote-spam" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   add_option("earmuff state",
              ({ "on", "off", "allowfriends" }), 0,
              (: setup_earmuffs($1, $3) :),
              (: $1->query_earmuffs()? ($1->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF ? "allowfriends" : "on") : "off" :),
              "Enable or disable earmuffs always or just for friends");
   add_option("earmuff cut-through", ({ "off", "ask", "auto"}), 1,
              (: $1->add_property("cut earmuffed tells",
                    member_array($3, ({ "off", "ask", "auto"}))) :),
              (: ({ "off", "ask", "auto" })[$1->query_property(
                                             "cut earmuffed tells")] :),
              "Cut through a players tell earmuffs");
   add_option("command ls use_nickname", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
              (: $3 ? change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 1 ) : change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 0 ) :),
              (: $1->query_property( LS_COMMAND_NICKNAME_PROPERTY ) :),
              "Should 'ls' check for nicknames");
   foreach(womble in ERROR_TYPE) {
      womble = lower_case(womble);
      add_option("command look error " + womble, OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_CRE_ONLY,
              (: change_error_reports($1, $2[<1], $3) :),
              (: member_array(upper_case($2[<1]), ($1->query_property(PLAYER_SHOW_ERRORS_PROP)?$1->query_property(PLAYER_SHOW_ERRORS_PROP):({}))) != -1 :),
              "Show the errors of type " + lower_case(womble) +
              " when doing a look.");
   }
   add_option("personal description", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_desc($3 == "none"?0:$3), 1) :),
              (: (($1->query_desc())?($1->query_desc()):"none") :),
              "Ain't you perdy");
   add_option("personal real_name", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_real_name($3 == "none"?0:$3), 1) :),
              (: (($1->query_real_name())?($1->query_real_name()):"none") :),
              "The real name displayed in your finger information");
   add_option("personal location", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_where($3 == "none"?0:$3), 1) :),
              (: (($1->query_where())?($1->query_where()):"none") :),
              "The location displayed in your finger information");
   add_option("personal home_page", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_homepage($3 == "none"?0:$3), 1) :),
              (: (($1->query_homepage())?($1->query_homepage()):"none") :),
              "The url displayed in your finger information");
   add_option("personal email", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_email($3 == "none"?0:$3), 1) :),
              (: (($1->query_email())?($1->query_email()):"none") :),
              "The email address displayed in your finger information");
   add_option("personal birthday", OPTIONS_TYPE_STRING, 0,
              (: (!valid_birthday($3) || $1->query_birthday())? 0:($1->set_birthday($3 == "none"?0:convert_birthday($3)), 1) :),
              (: (($1->query_birthday())?($1->query_birthday()):"none") :),
              "Your birthday");
   add_option("personal execinclude", OPTIONS_TYPE_STRING, 0,
              (: ($3=="none"?$1->remove_property(OPTION_EXEC_INCLUDE):$1->add_property(OPTION_EXEC_INCLUDE, $3)), 1 :),
              (: ($1->query_property(OPTION_EXEC_INCLUDE)?$1->query_property(OPTION_EXEC_INCLUDE):"none") :),
              "The path of files to be included in exec commands?");
   add_option("personal auto teach", OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(TEACH_COMMAND_AUTO_PROPERTY,$3):$1->remove_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              (: $1->query_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              "Are you available to auto-teach");
   add_option("personal travel",
              ({ "walk", "journey" }), 0,
              (: $3 == "walk" ?$1->remove_property(TERRAIN_MAP_LONG_JUMP_PROPERTY):$1->add_property(TERRAIN_MAP_LONG_JUMP_PROPERTY,1), 1 :),
              (: $1->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)?"journey":"walk" :),
              "By default should you walk or journey across terrains");
   add_option("playtester protection", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3 ? $1->enable_personal_pt_protection() : $1->disable_personal_pt_protection() :),
              (: $1->query_pt_protection() :),
              "Enable or disable playtester protection");
   add_option("personal roleplaying", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $1->set_role_playing($3), 1 :),
              (: $1->query_role_playing() :),
              "Enable or disable roleplaying mode");
}
protected void add_option_to_mapping(mapping array, string name, mixed type,
                                     int cre_only, function set_function,
                                     function query_function, string help) {
   class option fluff;
   fluff = new(class option);
   fluff->type = type;
   fluff->set = set_function;
   fluff->query = query_function;
   fluff->restriction = cre_only;
   fluff->suboptions = ([ ]);
   fluff->help = help;
   array[name] = fluff;
}
protected int add_option(string name, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help) {
   string option;
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = _options;
   foreach (option in path[0..<2]) {
      if (!stuff[option]) {
         add_option_to_mapping(stuff, option, OPTIONS_TYPE_GROUP, cre_only,
                               0, 0, help);
      } else if (((class option)stuff[option])->type != OPTIONS_TYPE_GROUP) {
         return 0;
      }
      stuff = stuff[option]->suboptions;
   }
   add_option_to_mapping(stuff, path[<1], type, cre_only, set_function,
                         query_function, help);
   return 1;
}
private mixed query_sub_option(object player, string name, mapping tree) {
   mixed tmp;
   if (mapp(tree[name])) {
      return tree[name];
   }
   if (classp(tree[name])) {
      switch (tree[name]->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_DYNAMIC_GROUP) {
         tmp = evaluate(tree[name]->query, player, name);
         return tmp;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_GROUP) {
         return tree[name]->suboptions;
      }
      return tree[name];
   }
   return 0;
}
private mixed query_bottom_sub_option(object player, string* path) {
   string option;
   mixed stuff;
   if (!sizeof(path)) {
      return _options;
   }
   stuff = _options;
   foreach (option in path[0..<2]) {
      stuff = query_sub_option(player, option, stuff);
      if (!mapp(stuff)) {
         return 0;
      }
   }
   stuff = query_sub_option(player, path[<1], stuff);
   if (classp(stuff)) {
      switch (stuff->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
   }
   return stuff;
}
int is_option(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!classp(stuff)) {
      return 0;
   }
   return 1;
}
int is_option_group(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!mapp(stuff)) {
      return 0;
   }
   return 1;
}
string *query_sub_options(object player, string name) {
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (mapp(stuff)) {
      return filter(keys(stuff),
                    (: query_bottom_sub_option($2, $3 + ({ $1 })) :),
                    player, path);
   }
   return ({ });
}
string* query_option_values(object player, string name) {
   mixed stuff;
   class option opt;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (classp(stuff)) {
      opt = stuff;
      if (intp(opt->type)) {
         switch (opt->type) {
         case OPTIONS_TYPE_BOOLEAN :
            return ({ "on", "off" });
         case OPTIONS_TYPE_BRIEF :
            return ({ "brief", "verbose" });
         case OPTIONS_TYPE_INTEGER :
            return ({ "integer" });
         case OPTIONS_TYPE_STRING :
            return ({ "string" });
         case OPTIONS_TYPE_PERCENTAGE :
            return ({ "0..100" });
         case OPTIONS_TYPE_COLOUR :
            return ({ "none", "default", "colour" });
         }
      } else {
         return opt->type;
      }
   }
   return ({ });
}
string query_option_value(object player, string path) {
   string* bits;
   mixed value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      value = evaluate(stuff->query, player, bits);
      if (intp(stuff->type)) {
         switch (stuff->type) {
         case OPTIONS_TYPE_BRIEF:
            if (value) {
               value = "verbose";
            } else {
               value = "brief";
            }
            break;
         case OPTIONS_TYPE_BOOLEAN :
            if (value) {
               value = "on";
            } else {
               value = "off";
            }
            break;
         case OPTIONS_TYPE_COLOUR :
            if (value == "") {
               value = "[none]";
            } else if (value == "default") {
               value = "[default]";
            } else {
               value = "[" + value + "" +
                       lower_case(replace(value, ({ "%^%^", " ", "%^", "" }))) +
                       "%^RESET%^]";
            }
            break;
         default :
         }
      }
      return value + "";
   }
}
string query_option_help(object player, string path) {
  string *bits;
  mixed stuff;
  bits = explode(path, " ");
  stuff = query_bottom_sub_option(player, bits);
  if (classp(stuff)) {
    return copy(stuff->help);
  }
  return "";
}
int set_option_value(object player, string path, string value) {
   string* bits;
   string* bad;
   mixed set_value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      if (pointerp(stuff->type)) {
         if (member_array(value, stuff->type) == -1) {
            add_failed_mess("You must set your type to one of " +
                            query_multiple_short(stuff->type) + ".\n");
            return 0;
         }
         set_value = value;
      } else switch (stuff->type) {
      case OPTIONS_TYPE_BRIEF:
         if (value == "verbose") {
            set_value = 1;
         } else if (value == "brief") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_BOOLEAN :
         if (value == "on" || value == "true") {
            set_value = 1;
         } else if (value == "off" || value == "false") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PERCENTAGE :
      case OPTIONS_TYPE_INTEGER :
         if (sscanf(value, "%d", set_value) != 1) {
            return 0;
         }
         if (stuff->type == OPTIONS_TYPE_PERCENTAGE &&
             (set_value < 0 || set_value > 100)) {
            add_failed_mess("Value must be between 0 and 100.\n");
            return 0;
         }
         break;
      case OPTIONS_TYPE_COLOUR :
         if (value == "none" || value == "default") {
            set_value = value;
         } else {
            set_value = map(explode(value, " "),
                         (: upper_case($1) :));
            bad = filter(set_value, (: member_array($1, _colours) == -1 :));
            if (sizeof(bad)) {
               add_failed_mess("Bad colours " + implode(bad, " ") + ".\n");
               return 0;
            }
            set_value = "%^" + implode(set_value, (: $1 + "%^ %^" + $2 :)) + "%^";
         }
         break;
      default :
         set_value = value;
         break;
      }
      return evaluate(stuff->set, player, bits, set_value);
   }
   return 0;
}
private mapping get_inform_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   if (player->query_creator()) {
      index = "colour 1";
   } else if (player->query_lord()) {
      index = "colour 2";
   } else {
      index = "colour 0";
   }
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = player->query_inform_types();
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours($2[<1], $3), 1 :),
                            (: $1->colour_event($2[<1], "default") :),
                            "The colour of " + womble + " informs");
   }
   _cache_input[index] = ret;
   return ret;
}
private mapping get_club_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   index = "colour " + player->query_name();
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = map(this_player()->query_player_clubs(),
                 (: CLUB_HANDLER->normalise_name($1) :) );
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours("club_" + $2[<1], $3), 1 :),
                            (: $1->colour_event("club_" + $2[<1], "default") :),
                            "The colour for " + womble + " club messages");
   }
   _cache_input[index] = ret;
   call_out((: map_delete(_cache_input, $1) :), 5 * 60, index);
   return ret;
}
private int change_bool_property(string prop, object player, int new_value) {
   if (new_value) {
      player->add_property(prop, 1);
   } else {
      player->remove_property(prop);
   }
   return 1;
}
private int setup_earmuffs(object player, string ear) {
   switch (ear) {
   case "on" :
      if (!player->query_earmuffs()) {
         player->toggle_earmuffs();
      } else if (player->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         player->toggle_earmuffs();
         player->toggle_earmuffs();
      }
      break;
   case "off" :
      if (player->query_earmuffs()) {
         player->toggle_earmuffs();
      }
      break;
   case "allowfriends" :
      player->set_allow_friends_earmuffs();
      break;
   }
   return 1;
}
private int change_error_reports(object player, string error, int new_value) {
   string *on;
   on = player->query_property(PLAYER_SHOW_ERRORS_PROP);
   if (!on) {
      on = ({ });
   }
   error = upper_case(error);
   if (new_value) {
      if (member_array(error, on) == -1) {
         on += ({ error });
         player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
      }
   } else {
      on -= ({ error });
      player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
   }
   return 1;
}
private int change_earmuffs(object player, string ear, int new_value) {
   string *on;
   on = player->query_property("earmuffs");
   if (!on) {
      on = ({ });
   }
   if (new_value) {
      if (member_array(ear, on) == -1) {
         on += ({ ear });
         player->add_property("earmuffs", on);
      }
   } else {
      on -= ({ ear });
      player->add_property("earmuffs", on);
   }
   return 1;
}
private int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}

==================================================
FILE: handlers/parcel.c
==================================================

#define BASE_PATH "/save/parcels/"
#define SAVE_PATH BASE_PATH + location + "/" + name[0..0]
#define SAVE_FILE BASE_PATH + location + "/" + name[0..0] + "/" + name + ".o"
#define POST_LOG "PARCEL_LOG"
inherit "/global/auto_load";
#undef USE_COMPRESSION
#include <player_handler.h>
class parcel {
  string from;
  string *autoloadinfo;
  int exp_time;
}
mapping parcels;
private nosave string _current_name, _current_location;
nosave class parcel *_parcels;
int test_expire( class parcel temp );
void create() {
  string dir;
  seteuid( master()->creator_file( base_name( this_object() ) ) );
  parcels = ([ ]);
  if(parcels) {
    parcels = copy(parcels);
    parcels = ([ ]);
  }
  _parcels = ({ });
}
private void save_file(string name, string location) {
  string str;
  map_delete(parcels, name);
  if(sizeof(keys(parcels)))
    unguarded( (: save_object, SAVE_PATH, 2 :));
  if(file_size(SAVE_PATH) == -1)
    unguarded( (: mkdir, SAVE_PATH :) );
  if(_parcels != ({ })) {
    str = save_variable(_parcels);
#ifdef USE_COMPRESSION
    if(!ungarded( (: write_buffer, SAVE_FILE + ".gz", 0, compress(str) :) ))
#else
    if(!unguarded((: write_file, SAVE_FILE, str, 1 :) ))
#endif
      log_file(POST_LOG, "%s: error writing to %s\n",
               ctime(time()), SAVE_FILE);
  } else {
    if(file_size(SAVE_FILE) > 0)
      unguarded( (: rm, SAVE_FILE :));
    if(file_size(SAVE_FILE+".gz") > 0)
      unguarded( (: rm, SAVE_FILE + ".gz" :));
  }
}
private void load_file( string name, string location ) {
  if(_current_name == name && _current_location == location)
    return;
#ifdef USE_COMPRESSION
  if(file_size(SAVE_FILE + ".gz") > 0) {
    _parcels = restore_variable(uncompress(read_file(SAVE_FILE)));
  } else
#endif
  if(file_size(SAVE_FILE) > 0) {
    debug_printf("%s", SAVE_FILE);
    _parcels = restore_variable(unguarded( (: read_file, SAVE_FILE :) ));
  } else if (file_size(SAVE_PATH+ ".o.gz") > 0) {
    unguarded( (: restore_object, SAVE_PATH+".o.gz" :));
    _parcels = parcels[name];
  } else if(file_size(SAVE_PATH+".o") > 0) {
    unguarded( (: restore_object, SAVE_PATH :) );
    _parcels = parcels[name];
  } else {
    parcels = ([ ]);
    _parcels = ({ });
  }
  _current_name = name;
  _current_location = location;
}
public int deposit(string to, string from, string location, object *obs) {
  class parcel temp;
  object boxy;
  string obsstuff, tmp;
  obsstuff = "/global/events"->convert_message(query_multiple_short (obs));
  if(!PLAYER_HANDLER->test_user(to))
    return 0;
#ifndef __DISTRIBUTION_LIB__
    if("/secure/alist"->query_alt(from, to) == 100) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her alt " + capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(from, to) > 40) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her POSSIBLE alt "+ capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  load_file(to, location );
  if(undefinedp(_parcels) || !arrayp(_parcels))
    _parcels = ({ });
  boxy = clone_object("/obj/baggage");
  boxy->set_name("boxy");
  boxy->set_max_weight(100000);
  obs->move( boxy );
  temp = new( class parcel,
              from : from,
              exp_time: time() + ( 14 * 24 * 60 * 60));
  temp->autoloadinfo = create_auto_load( ({ boxy }), 0 );
  _parcels += ({ temp });
  save_file(to, location);
  boxy->dest_me();
  log_file (POST_LOG, "%s: %s deposited %s at %s for %s.\n", ctime(time()),
      from, obsstuff, location, to);
}
public int collect(string name, string location, object target, int copy) {
  class parcel temp;
  object *box_array = ({ });
  object *obs = ({ });
  string tmp;
  load_file(name, location );
  if(!_parcels || _parcels == ({ }))
    return 0;
  foreach(temp in _parcels) {
    box_array += load_auto_load_to_array(temp->autoloadinfo, this_player());
#ifndef __DISTRIBUTION_LIB__
    obs = all_inventory(box_array[<1]);
    if("/secure/alist"->query_alt(name, temp->from) == 100) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her alt " + capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(name, temp->from) > 40) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her POSSIBLE alt "+ capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  }
  foreach( object box in box_array ) {
    obs += all_inventory (box);
    all_inventory( box )->move( target );
    box->dest_me();
  }
  if ( !copy )
    _parcels = ({ });
  log_file (POST_LOG, "%s: %s collected %s at %s.\n", ctime(time()),
            name, "/global/events"->convert_message(query_multiple_short(obs)),
            location);
  save_file(name, location);
  return 1;
}
class parcel *queryparcels_for(string name, string location) {
  load_file(name, location);
  return _parcels;
}
void do_migrate(int letter, string location) {
  string name;
  class parcel temp2;
  tell_creator("ceres", "Processing %c in %s\n", letter, location);
  load_file(sprintf("%c", letter), location);
  foreach(name, temp2 in parcels) {
    _parcels = filter(temp2, (: test_expire :));
    save_file(name, location);
  }
  if(!sizeof(keys(parcels))) {
    name = BASE_PATH + location + "/" + sprintf("%c", letter) + ".o.gz";
    unguarded((: rm, name :));
  }
  if(letter < 'z') {
    letter++;
    call_out("do_migrate", 15 + random(30), letter, location);
  }
}
int test_expire(class parcel temp ) {
  if ( temp->exp_time > time() )
    return 1;
  return 0;
}
void player_refreshed(mixed name, int total ) {
  string location;
  string *dirs = map( filter( get_dir( BASE_PATH, -1 ),
                              (: $1[1] == -2 :) ), (: $1[0] :) );
  if (objectp(name))
    name = name->query_name();
  foreach(location in dirs) {
    load_file(name, location);
    map_delete(parcels, name);
    save_file(name, location);
  }
}

==================================================
FILE: handlers/pattern_compiler.c
==================================================

#include <user_parser.h>
#define PATTERN_CACHE_SIZE 200
nosave mapping patterns;
nosave mapping pattern_short;
nosave string *pattern_order;
nosave int hits, reqs, cache_callout;
nomask mixed *compile_pattern(string str);
void create() {
   patterns = ([ "" : ({ 100 }) ]);
   pattern_short = ([ "" : "" ]);
}
void clean_cache() {
  int i;
  for(i=0; i<(sizeof(pattern_order)-PATTERN_CACHE_SIZE); i++) {
    map_delete(patterns, pattern_order[i]);
    map_delete(pattern_short, pattern_order[i]);
  }
  pattern_order = pattern_order[i..];
  cache_callout = 0;
}
nomask mixed *query_pattern(string pattern) {
  if (!patterns[pattern]) {
    patterns[pattern] = compile_pattern(pattern);
  }
  return patterns[pattern];
}
nomask mixed *compile_pattern(string str) {
   mixed *pattern;
   mixed *bits;
   int i;
   int failed;
   int type;
   int weight;
   mixed env;
   string short;
   string short_bit;
   int pos;
   int pos2;
   int j;
   int k;
   bits = explode(str, " ") - ({ 0, "" });
   pattern = ({ });
   short = "";
   for (i = 0; i < sizeof(bits) && !failed; i++) {
      switch (bits[i][0]) {
      case '<' :
         pos = strsrch(bits[i], "'");
         if (pos != -1) {
             pos2 = strsrch(bits[i][pos + 1..], "'", pos + 1);
             if (pos2 == -1) {
                for (j = i + 1; j < sizeof(bits); j++) {
                   pos2 = strsrch(bits[j], "'");
                   if (pos2 != -1) {
                      break;
                   }
                }
                if (j < sizeof(bits)) {
                   for (k = i + 1; k <= j; k++) {
                      bits[i] += " " + bits[k];
                   }
                   bits[j] = bits[i];
                   i = j;
                   pos2 = strsrch(bits[i], "'", -1);
                }
             } else {
                pos2 += pos + 1;
             }
             if (pos2 != -1) {
                short_bit = bits[i][pos+1..pos2-1];
                bits[i] = bits[i][0..pos-1] + bits[i][pos2+1..];
             } else {
                short_bit = 0;
             }
         } else {
             short_bit = 0;
         }
         bits[i] = bits[i][1..<2];
         bits[i] = explode(bits[i], ":");
         if (!bits[i]) {
            bits[i] = ({ "" });
         }
         switch (bits[i][0]) {
         case "direct" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of direct (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                   short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ DIRECT_OBJECT, type, env });
            break;
         case "indirect" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               case "wiz-present" :
                  type = WIZ_PRESENT_TARGET;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of indirect (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                  short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ INDIRECT_OBJECT, type, env });
            break;
         case "string" :
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "small" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 6;
                  pattern += ({ SHORT_STRING });
                  break;
               case "long" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 5;
                  pattern += ({ STRING });
                  break;
               case "quoted" :
                  if (!short_bit) {
                     short += "\"<string>\" ";
                  } else {
                     short += "\"<" + short_bit + ">\" ";
                  }
                  weight += 8;
                  pattern += ({ QUOTED_STRING });
                  break;
               default :
                  printf("Invalid type of string (%s).\n", bits[i][1]);
                  failed = 1;
                  break;
               }
            } else {
               if (!short_bit) {
                  short += "<string> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               weight += 5;
               pattern += ({ STRING });
            }
            break;
         case   "number" :
            if (!short_bit) {
               short += "<number> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ NUMBER });
            break;
         case "word" :
            if (!short_bit) {
               short += "<word> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 7;
            pattern += ({ SINGLE_WORD });
            break;
         case "fraction" :
            if (!short_bit) {
               short += "<fraction> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ FRACTION });
            break;
         default :
            weight += 10;
            bits[i] = implode(bits[i], ":");
            if (master()->query_word_list(bits[i])
                  || this_player()->query_word_list(bits[i])) {
               if (!short_bit) {
                  short += "<"+bits[i]+"> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               pattern += ({ WORD_LIST, bits[i] });
            } else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
            }
            break;
         }
         break;
      case '{' :
         weight += 10;
         if (bits[i][<1] == '}') {
            pattern += ({ WORD_LIST, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != '}'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ WORD_LIST_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      case '[' :
         weight += 4;
         if (bits[i][1] == '<') {
            if (MASTER->query_word_list(bits[i][2..<3])
                  || this_player()->query_word_list(bits[i][2..<3]))
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            }
            short += bits[i]+" ";
         } else if (bits[i][1] == '{') {
            if (bits[i][<1] == ']') {
               pattern += ({ OPTIONAL, explode(bits[i][2..<3], "|") });
               short += bits[i]+" ";
            } else {
               int old = i;
               string elm, *res;
               for (++i; bits[i][<1] != ']'; i++);
               res = ({});
               foreach (elm in explode(implode(bits[old..i], " ")[2..<3], "|"))
                  res += ({ explode(elm, " ") });
               pattern += ({ OPTIONAL_SPACES, res });
               short += implode(bits[old..i], " ")+" ";
            }
         } else if (bits[i][<1] == ']') {
            pattern += ({ OPTIONAL, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != ']'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ OPTIONAL_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      default :
         weight += 10;
         short += bits[i]+" ";
         pattern += ({ WORD_LIST, ({ bits[i] }) });
         break;
      }
   }
   if (failed) {
      return 0;
   }
   pattern_short[str] = short;
   return ({ weight }) + pattern;
}
string query_short_pattern(string str) {
  reqs++;
  if(!pattern_short[str])
    compile_pattern(str);
  else
    hits++;
  return pattern_short[str];
}
mixed *stats() {
  return  ({
    ({ "patterns", sizeof(keys(pattern_short)), }),
        ({ "requests", reqs, }),
          ({ "cache hit percent", (hits * 100) / reqs, }),
            });
}

==================================================
FILE: handlers/peopler.c
==================================================

#include <peopler.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
string *de_names,
       *abbrev,
       *var_names;
void create() {
  de_names = DE_NAMES;
  abbrev = ABBREV;
  var_names = ({
      "dirs",
      "netstat",
      "people",
      "qpeople",
      "terms",
      "netdups",
    });
}
object *get_people(string str) {
  object *ob;
  int i;
  string s1;
  ob = users();
  for(i = 0; i<sizeof(ob); i++) {
    if (str && (sscanf(ob[i]->query_name(),str+"%s", s1) != 1)) {
      ob = ob[0..i - 1] + ob[i+1..];
      i--;
    }
  }
  return ob;
}
private string create_title(mixed *bits) {
  int i, pos;
  string str;
  str = "";
  for (i=0;i<sizeof(bits);i+=2) {
    if ((pos = (bits[i]&~MASK)) == STRING)
      str += bits[i+1];
    else
      if (strlen(de_names[pos]) > bits[i+1])
        str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", "");
      else
        switch (bits[i]&MASK) {
          case CENTER :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"|s", de_names[pos]);
            break;
          case RIGHT :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", de_names[pos]);
            break;
          default :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"-s", de_names[pos]);
            break;
        }
  }
  return str;
}
private string review_thingy(mixed *bing) {
  int i;
  string str;
  str = "";
  for (i = 0; i < sizeof(bing); i += 2) {
    if (bing[i] == STRING) {
      str += bing[i+1];
    } else {
      switch (bing[i]&MASK) {
        case CENTER :
          str += "%|"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        case RIGHT :
          str += "%"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        default :
          str += "%-"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
      }
    }
  }
  return str;
}
private void print_entrys(object *obs, mixed *format, int with_dups,
                          string constraint) {
  int age, j;
  mixed g;
  string form, str, mess, *not_allowed;
  object ob, env, *dups;
  mapping per_ip;
  reset_eval_cost();
  if (with_dups) {
    per_ip = unique_mapping(obs, (: query_ip_number($1) :));
  }
  mess = sprintf("%s\n", create_title(format));
  foreach(ob in obs) {
    str = "";
    for (j=0;j<sizeof(format);j+=2) {
      switch (format[j]&MASK) {
        case RIGHT :
          form = "%"+format[j+1]+"."+format[j+1];
          break;
        case CENTER :
          form = "%|"+format[j+1]+"."+format[j+1];
          break;
        default :
          form = "%-"+format[j+1]+"."+format[j+1];
          break;
      }
      switch (format[j]&~MASK) {
        case STRING :
          str += format[j+1];
          break;
        case C_NAME :
          str += sprintf(form+"s", capitalize( (string)ob->query_name() ) );
          break;
        case GENDER :
          str += sprintf(form+"s", ob->query_gender_string());
          break;
        case NAME :
          str += sprintf(form+"s", (ob->query_in_editor()?"*":"")+
              ( ob->query_invis() ? "("+ (string)ob->query_name() +")" :
              (string)ob->query_name() ) );
          break;
        case GUILD :
          if(ob)
            str += sprintf(form+"s",
                           ((g=(object)ob->query_guild_ob())?
                            g->query_name():"No guild"));
          else
            str += sprintf(form+"s", "Broken guild");
          break;
        case LEVEL :
          str += sprintf(form+"s", ""+ ob->query_level());
          break;
        case ROWS :
          str += sprintf(form+"s", ""+ ob->query_rows());
          break;
        case COLS :
          str += sprintf(form+"s", ""+ ob->query_cols());
          break;
        case TERMINAL :
          str += sprintf(form+"s",
                         ((g = ob->query_term_name()) ?
                          g + (g == "network" ? " (" +
                               ob->query_cur_term() + ")" : "") : ""));
          break;
        case IP_NUMBER :
          str += sprintf(form+"s", query_ip_number(ob));
          break;
        case IP_NAME :
          str += sprintf(form+"s",
                           (query_ident(ob)?query_ident(ob)+"@":"")+
                           query_ip_name(ob));
          break;
        case TYPE :
          str += sprintf(form+"s", ob->query_object_type()+"");
          break;
        case AGE :
          age = (int)ob->query_time_on();
          if (age < -86400)
            str += sprintf(form+"s", (age/-86400)+"D");
          else if (age < -3600)
            str += sprintf(form+"s", (age/-3600)+"h");
          else if (age < -60)
            str += sprintf(form+"s", (age/-60)+"m");
          else
            str += sprintf(form+"s", (age/-1)+"s");
          break;
        case ROOM :
          env = environment(ob);
          str += sprintf(form+"s",env?file_name(env):"No environment");
          break;
        case EUID :
          env = environment(ob);
          str += sprintf(form+"s",env?geteuid(env):"No environment");
          break;
        case UID :
          env = environment(ob);
          str += sprintf(form+"s",env?getuid(env):"No environment");
          break;
        case CFILE :
          env = environment(ob);
          str += sprintf(form+"s",env?"/secure/master"->creator_file(env)
                         :"No environment");
          break;
        case CUR_DIR :
          str += sprintf(form+"s", (ob->query_current_path()?
                                    ob->query_current_path():"No dir"));
          break;
        case ND_ALLOWED :
          dups = per_ip[query_ip_number(ob)] - ({ ob });
          not_allowed = MULTIPLAYER->check_allowed(ob, dups);
          str += sprintf(form+"s", (sizeof(not_allowed) ?
                                    query_multiple_short(not_allowed) :
                                    ""));
          break;
      }
    }
    if(!constraint || strsrch(str, constraint) != -1)
      mess += sprintf("%s\n", str);
  }
  this_player()->more_string( mess );
}
int do_command(mixed *pattern, string constraint, function sort_func,
               int only_duplicates) {
   object *obs;
   object *tmpobs;
   int i;
   obs = get_people("");
   if (!sizeof(obs)) {
      notify_fail("Nobody seems to start with '" + constraint + "'.\n");
      return 0;
   }
   if (!sort_func) {
      sort_func = (: strcmp($1->query_name(), $2->query_name()) :);
   }
   obs = sort_array(obs, sort_func);
   if (only_duplicates) {
      tmpobs = ({ });
      for (i = 1; i <sizeof(obs); i++) {
         if (!evaluate(sort_func, obs[i - 1], obs[i])) {
            if (member_array(obs[i - 1], tmpobs) == -1) {
               tmpobs += obs[i - 1..i];
            } else {
               tmpobs += ({ obs[i] });
            }
         }
      }
      if (!sizeof(tmpobs)) {
         notify_fail("Unable to find any duplicates.\n");
         return 0;
      }
      obs = tmpobs;
   }
   print_entrys(obs, pattern, only_duplicates, constraint);
   return 1;
}
int review() {
  mixed *bing;
  bing = (mixed *)this_player()->query_property("people list");
  if (!bing)
    bing = P_DEFAULT;
  write("People : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("qpeople list");
  if (!bing)
    bing = QP_DEFAULT;
  write("Qpeople: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netstat list");
  if (!bing)
    bing = N_DEFAULT;
  write("Netstat: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("term list");
  if (!bing)
    bing = T_DEFAULT;
  write("Terms  : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("dir list");
  if (!bing)
    bing = D_DEFAULT;
  write("Dirs   : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netdup list");
  if (!bing)
    bing = ND_DEFAULT;
  write("Netdups: "+review_thingy(bing)+"\n");
}
private mixed *create_review(string str) {
  string *bits, rest;
  int i, bing, width, tmp;
  mixed *ret;
  bits = explode("$"+str, "%");
  bits[0] = bits[0][1..];
  if (!strlen(bits[0]))
    ret = ({ });
  else
    ret = ({ STRING, bits[0] });
  for (i=1;i<sizeof(bits);i++) {
    bing = RIGHT;
    rest = bits[i];
    if (rest[0] == '|') {
      bing = CENTER;
      rest = rest[1..];
    } else if (rest[0] == '-') {
      bing = 0;
      rest = rest[1..];
    }
    if (sscanf(rest, "%d%s", width, rest) == 2) {
      tmp = member_array(rest[0..0], abbrev);
      if (tmp == -1) {
        write("Unknown thingy '"+rest[0..0]+"'\n");
        return 0;
      }
      ret += ({ tmp+bing, width });
      rest = rest[1..];
      if (strlen(rest))
        ret += ({ STRING, rest });
    } else {
      ret += ({ STRING, bits[i] });
    }
  }
  return ret;
}
private void list_matches() {
  int i;
  for (i=0;i<sizeof(de_names);i++) {
    if (i == STRING) continue;
    printf("%s: %s\n", abbrev[i], de_names[i]);
  }
}
int set_var(string str) {
  string name, type;
  mixed *bing;
  if (str == "help") {
    write("The non helpful help.\nThis is the list of things that go after "+
          "the %'s in the value.\n");
    list_matches();
    return 1;
  }
  if (!str || sscanf(str, "%s %s", name, type) != 2) {
    notify_fail("Syntax: "+query_verb()+" <var_name> <value>\n"+
                "        "+query_verb()+" help\n");
    return 0;
  }
  if (member_array(name, var_names) == -1) {
    notify_fail("You cannot set the var "+name+", it has to be one of "+
                implode(var_names[0..<2], ", ")+" or " + var_names[<1] +
                ".\n");
    return 0;
  }
  bing = create_review(type);
  if (!bing)
    return 1;
  this_player( 1 )->add_property( name +" list", bing );
  write("Ok, set var "+name+" to "+type+".\n");
  return 1;
}

==================================================
FILE: handlers/philosophies.c
==================================================

#define SAVE_FILE "/save/philosophies"
#define SAVE_DIR "/save/philosophies/"
#define PHILOSOPHY_TYPE 0
#define PHILOSOPHY_BONUS 1
#define PHILOSOPHY_NEEDED 2
#define PHILOSOPHY_EFFECT 3
#define PHILOSOPHY_ARGUMENTS 4
nosave string current_person, current_philosophies;
mapping philosophies;
void create() {
  seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   philosophies = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_philosophies() { return philosophies; }
string *query_philosophy_names() { return keys( philosophies ); }
int query_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return 1;
}
void add_philosophy( string name, string type, int bonus, string needed,
      string effect ) {
   philosophies[ name ] = ({ type, bonus, needed, effect, ([ ]) });
   save_me();
}
void remove_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   map_delete( philosophies, name );
   save_me();
}
string query_philosophy_type( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_TYPE ];
}
int query_philosophy_bonus( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_BONUS ];
}
string query_philosophy_needed( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_NEEDED ];
}
string query_philosophy_effect( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_EFFECT ];
}
mapping query_philosophy_all_arguments( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return copy( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ] );
}
mixed query_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ];
}
void add_philosophy_argument( string name, string argument, mixed args ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( !undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] = args;
   save_me();
}
void remove_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   map_delete( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ], argument );
   save_me();
}
string *query_all_known( string person ) {
   string *oldstuff, *newstuff = ({}), key;
  if ( person != current_person ) {
     if(unguarded((: file_length, SAVE_DIR + person[0..0]+"/"+person :)) < 1) {
       current_philosophies = "";
     } else {
       current_philosophies = unguarded((:read_file,
         SAVE_DIR+person[0..0]+"/"+person:));
     }
  }
  oldstuff = explode(current_philosophies, "\n");
  foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
          newstuff += ({ key });
      }
  }
  current_person = person;
  return newstuff;
}
int query_known( string person, string argument ) {
  if(person != current_person) {
    current_philosophies = "";
    if( unguarded( (: file_length,
		    SAVE_DIR + person[0..0]+"/"+person :) ) < 1 ) {
      current_person = person;
      return 0;
    }
    current_person = person;
    current_philosophies =
      unguarded( (: read_file, SAVE_DIR +  person[0..0]+"/"+person :) );
  }
  return (member_array(argument,explode(current_philosophies ,"\n")) != -1);
}
void add_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !query_known( person, argument ) ) {
      if( !current_philosophies ) {
         current_philosophies = "";
      }
      current_philosophies += argument +"\n";
   }
   current_person = person;
   oldstuff = explode(current_philosophies, "\n");
   foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
       newstuff += ({ key });
     }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int remove_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   oldstuff = query_all_known( person );
   current_person = person;
   current_philosophies = "";
   foreach ( key in oldstuff ) {
      if ( member_array( key, newstuff ) == -1 &&
        key != argument ) {
          newstuff += ({ key });
          current_philosophies += sprintf( "%s\n", key );
       }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int reset_known( string person ) {
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   current_person = person;
   current_philosophies = "";
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}

==================================================
FILE: handlers/player_council.c
==================================================

inherit "/obj/handlers/inherit/player_council";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
void load_me();
void save_me();
void create() {
   player_council::create();
   load_me();
}
void save_me() {
   unguarded( (: save_object(NOMIC_SYSTEM_SAVE_FILE) :) );
}
void load_me() {
   unguarded( (: restore_object(NOMIC_SYSTEM_SAVE_FILE, 1) :) );
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/player_handler.c
==================================================

inherit "/global/family";
inherit "/std/living/nationality";
#include <alias.h>
#include <player.h>
#include <login_handler.h>
#include <access.h>
#define MAX_CACHE_SIZE MAX_PLAYERS
#define CACHE_TIMEOUT 900
#define INACTIVE_LIMIT 1209600
#define ILLEGAL ({ "black", "blood", "cyber", "dark", "penis", "cock", "pussy",\
  "fuck", "shit", "death", "deth", "dragon", "fish", "hell", "mage", "pink", "lord",\
  "shadow", "evil", "killer", "slayer" })
private int gender;
private int creator;
private int time_on;
private int last_log_on;
private string last_on_from;
private int activity_counter;
private int start_time;
private string password;
private string deity;
private string guild_ob;
private string cap_name;
private mapping aliases;
private mapping map_prop;
private mapping new_skills;
private mapping player_info;
private mixed *guild_data;
private int _flags;
private string home_dir;
string player_ob;
class player_record {
  int cached;
  int touched;
  int deleting;
  int appealing;
  int gender;
  int creator;
  int active;
  int level;
  string cap_name;
  mapping map_prop;
  mapping player_info;
  string deity;
  string guild;
  mixed *guild_data;
  int age;
  int last;
  int flags;
  string last_on_from;
  int start_time;
  string family_name;
  string player_title;
  string password;
  mixed *project;
  mixed *plan;
  mixed *reference;
  mixed *signature;
  string home_dir;
  string nationality;
  string nationality_region;
  mixed nationality_data;
}
nosave mapping player_cache;
nosave string prev, prev_find, prev_name;
nosave int prev_count, prev_finds, delay;
int requests,
  cache_hits;
void create() {
  seteuid("Root");
  player_ob = "/global/player";
  player_cache = ([ ]);
}
object my_find_player(string player) {
  string *funs, stack = "";
  object *obs;
  int i;
  if(prev_name == player)
    return find_player(player);
  prev_name = player;
  if (base_name(previous_object()) == prev_find && delay > time() - 60 &&
      prev_name == player) {
    prev_finds++;
  } else {
    prev_finds = 1;
    delay = time();
    prev_find = base_name(previous_object());
  }
  if(!(prev_finds % 25)) {
    obs = call_stack(1);
    funs = call_stack(2);
    for(i=0; i<sizeof(obs); i++) {
      if(clonep(obs[i]))
        stack += base_name(obs[i]) + "#" + obs[i]->query_name();
      else
        stack += base_name(obs[i]);
      stack += "->" + funs[i] + "()\n";
    }
    log_file("GARBAGE", "%s %s checked %d players in %d seconds.\n%s",
             ctime(time())[4..18], prev_find, prev_finds, time() - delay,
             stack);
  }
  return find_player(player);
}
void clean_cache() {
  string name;
  foreach(name in keys(player_cache)) {
    if (player_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(player_cache, name);
    }
  }
}
void remove_cache_entry(string name) {
  map_delete(player_cache, name);
}
private int validate_name(string name) {
  if (!stringp(name) || !name || name == "logon" || name[0] == '.' ||
      (sscanf(name, "%*s %*s") == 2) || strlen(name) < 2) {
    return 0;
  }
  if (sizeof(explode(name, "..")) > 1) {
    return 0;
  }
  return 1;
}
string query_player_file_name(string name) {
#ifdef USE_RAMDISK
  if(PLAYER_RAM_DIR) {
    if(file_size(PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz") == -1) {
      if(file_size(PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz") > -1) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz" :));
      } else if((file_size(PLAYER_SAVE_DIR+name[0..0]+"/"+name+".o") >-1)) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
        unguarded((: compress_file,
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
      }
    }
    return PLAYER_RAM_DIR + name[0..0] + "/" + name;
  }
#endif
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_player_ram_file_name(string name) {
  return PLAYER_RAM_DIR + name[0..0] + "/" + name;
}
string query_player_disk_file_name(string name) {
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_delete_player_file_name(string name) {
   return PLAYER_SAVE_DIR + DELETE_DIR + "/" + name;
}
string query_appeal_player_file_name(string name) {
   return PLAYER_SAVE_DIR + APPEAL_DIR + "/" + name;
}
int load_player(string name) {
  class player_record tmp;
  mixed *file;
  int diff, deleting, appealing;
  string tstr, fname;
  object loaded_guild_ob;
  if (!validate_name(name)) {
    return 0;
  }
  requests++;
  if (player_cache[name]) {
    if (10 * (time() - player_cache[name]->cached) <
        (time() - player_cache[name]->touched)) {
      cache_hits++;
      return 1;
    }
  }
  if(file = unguarded((: get_dir, query_player_ram_file_name(name) + ".o.gz",
                       -1 :)))
    fname = query_player_ram_file_name(name);
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o.gz", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if(!file || !sizeof(file) || file[0][1] < 0)
    return 0;
  if(player_cache[name] && player_cache[name]->touched == file[0][2]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  gender = 0;
  creator = 0;
  time_on = 0;
  last_log_on = 0;
  last_on_from = 0;
  activity_counter = 0;
  start_time = 0;
  password = 0;
  deity = 0;
  guild_ob = 0;
  cap_name = 0;
  player_info = ([ ]);
  aliases = ([ ]);
  new_skills = ([ ]);
  map_prop = ([ ]);
  guild_data = 0;
  if (base_name(previous_object()) == prev && delay > time() - 60) {
    prev_count++;
  } else {
    prev_count = 1;
    delay = time();
    prev = base_name(previous_object());
  }
  if (!(prev_count % 25)) {
    tstr = prev;
    if (tstr == "/secure/login" && sizeof(previous_object(-1)) > 1) {
      tstr = base_name(previous_object(-1)[1]);
    }
    log_file("GARBAGE", "%s %s loaded %d player files in %d seconds.\n",
             ctime(time())[4..18], tstr, prev_count, time() - delay);
  }
#ifdef DEBUG
  string ob;
  if (base_name(previous_object()) != "/secure/login") {
    ob = base_name(previous_object());
  } else {
    ob = base_name(previous_object(-1)[1]);
  }
  log_file("CDEBUG", "%s: %O:%O\n", ob, call_stack(1), call_stack(2));
#endif
  if(!unguarded((: restore_object, fname, 1 :)))
    return 0;
  if(fname == query_appeal_player_file_name(name)) {
    appealing = file[0][2];
  } else if(fname == query_delete_player_file_name(name)) {
    deleting = file[0][2];
  }
  tmp = new (class player_record,
             cached: time(),
             touched: file[0][2],
             deleting: deleting,
             appealing: appealing,
             gender: gender,
             creator: creator,
             active: 0,
             level: 0,
             cap_name: cap_name,
             player_info: player_info,
             map_prop: map_prop,
             deity: deity,
             guild: guild_ob,
             guild_data: guild_data,
             flags: _flags,
             age: time_on,
             last: last_log_on,
             last_on_from: last_on_from,
             start_time: start_time,
             family_name: query_family_name(),
             player_title: query_player_title(),
             nationality: query_nationality(),
             nationality_region: query_nationality_region(),
             nationality_data: query_nationality_data(),
             password: password);
  if(aliases) {
    if (aliases[".project"])
      tmp->project = aliases[".project"][0..1023];
    if (aliases[".plan"])
      tmp->plan = aliases[".plan"][0..1023];
    if (aliases[".reference"])
      tmp->reference = aliases[".reference"][0..1023];
    if (aliases[".signature"])
      tmp->signature = aliases[".signature"][0..240];
  }
  diff = (time() - last_log_on) / (3600 * 24 * 7);
  diff *= 10;
  tmp->active = (activity_counter - diff) > -50 ? 1 : 0;
  if (guild_ob) {
    loaded_guild_ob = load_object( guild_ob );
    if ( loaded_guild_ob ) {
        tmp->level = (int) guild_ob->query_level(this_object());
    }
    else {
        tmp->level = 0;
    }
  }
  player_cache[name] = tmp;
  if ((sizeof(player_cache) > MAX_CACHE_SIZE) &&
      (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  return 1;
}
string make_string(mixed *al, int max) {
  string str;
  int i;
  int lines;
  str = ALIAS_CMD->alias_string(al);
  sscanf(str, "%s $*$", str);
  str = replace(str, sprintf("%c", 7), "^G");
  str = replace(str, ({ "@@", "@ @ ", "\\;", "$escaped$", ";", "\n",
                          "$escaped$", ";" }));
  for (i = lines = 0; i < sizeof(str) && i < max*80 && lines < max; i++) {
    if (str[i] == '\n' || str[i] == ';') {
      lines++;
    }
  }
  return str[0..i - 1];
}
int test_user(string str) {
  if (player_cache[str])
    return 1;
  if (!validate_name(str))
    return 0;
  return file_size(query_player_disk_file_name(str) + ".o.gz") > 0 ||
    file_size(query_player_disk_file_name(str) + ".o") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o.gz") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o") > 0;
}
int test_deleting(string str) {
  if (player_cache[str])
    return player_cache[str]->deleting;
  if (!validate_name(str))
    return 0;
  if (file_size(query_delete_player_file_name(str) + ".o") > 0)
    return stat(query_delete_player_file_name(str) + ".o")[1];
  if(file_size(query_delete_player_file_name(str) + ".o.gz") > 0)
    return stat(query_delete_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_appealing(string str) {
  if (player_cache[str])
    return player_cache[str]->appealing;
  if (!validate_name(str))
    return 0;
  if (file_size(query_appeal_player_file_name(str) + ".o") > 0)
    return stat(query_appeal_player_file_name(str) + ".o")[1];
  if(file_size(query_appeal_player_file_name(str) + ".o.gz") > 0)
    return stat(query_appeal_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_gender(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_gender();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->gender;
}
varargs int test_active(string player, int noload) {
  mixed *file;
  if (find_player(player)) {
    map_delete(player_cache, player);
    return 1;
  }
  if (noload) {
    if (player_cache[player])
      return player_cache[player]->active;
    file =
      unguarded((: stat,
                 query_player_disk_file_name(player) + ".o" :));
    if (!file || !sizeof(file)) {
      file =
        unguarded((: stat,
                   query_player_disk_file_name(player) + ".o.gz" :));
    }
    return (sizeof(file) && file[1] > time() - INACTIVE_LIMIT);
  }
  if (!load_player(player))
    return 0;
  return player_cache[player]->active;
}
string query_cap_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_cap_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->cap_name;
}
int test_level(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_level();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->level;
}
mixed query_guild_data() {
    return guild_data;
}
int query_skill(string skill) {
  if (mapp(new_skills)) {
    return new_skills[skill];
  }
  return 0;
}
int test_banished(string name) {
  return file_size(BANISH_DIR + name[0..0] + "/" + name + ".o") != -1;
}
varargs int test_valid(string name) {
  string *bits, bit, tname;
  name = lower_case(name);
  tname = replace(name, ({ "'", "", "_", " " }));
  bits = explode(tname, " ");
  name = replace(name, ({ "'", " ", "_", " " }));
  bits += explode(name, " ");
  foreach(bit in bits) {
    if (bit == "the" || bit == "von" || bit == "sto" || bit == "here" ||
    bit == "there" || bit == "time") {
      continue;
    }
    if (test_banished(bit))
      return 0;
  }
  name = replace(name, ({ " ", "" }));
  if (test_banished(name))
    return 0;
  foreach(bit in ILLEGAL) {
    if (strsrch(name, bit) != -1)
      return 0;
  }
  return 1;
}
string test_real_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_real_name();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["real_name"];
}
string test_email(string str) {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..12] != "/secure/login" &&
     file_name(previous_object())[0..13] != "/secure/nlogin")
    return "";
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_email();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["email"];
}
string test_birthday(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_birthday();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["birthday"];
}
string test_location(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_where();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["location"];
}
string test_homepage(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_homepage();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["homepage"];
}
string test_desc(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_desc();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["desc"];
}
mixed test_player_killer(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_player_killer();
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->flags & PLAYER_KILLER_FLAG;
}
mixed test_property(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_property(str);
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->map_prop[str];
}
void special_add_property(string pname, string prop, mixed val) {
  if(player_cache[pname])
    player_cache[pname]->map_prop[prop] = val;
}
string test_deity(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_deity();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->deity;
}
string test_guild(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_ob();
  }
  if (!load_player(word))
    return "";
  return player_cache[word]->guild;
}
mixed *test_guild_data(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_data();
  }
  if (!load_player(word))
    return ({ });
  return player_cache[word]->guild_data;
}
int test_age(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_time_on();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->age;
}
int test_last(string word, int noload) {
  mixed *file;
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_last_log_on();
  }
  if (noload) {
    if (player_cache[word]) {
      return player_cache[word]->last;
    }
    word = replace(word, ({ "/", "", "\\", "" }) );
    file =
      unguarded((: stat, query_player_ram_file_name(word) + ".o" :));
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_player_disk_file_name(word)+".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o.gz" :));
    }
    if (!sizeof(file))
      return 0;
    return file[1];
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last;
}
string test_last_on_from(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return query_ip_name(find_player(word)) + " (" +
      query_ip_number(find_player(word)) + ") ";
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last_on_from;
}
int test_start_time(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_start_time();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->start_time;
}
int test_creator(string str) {
  str = lower_case (str);
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_creator();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->creator;
}
string test_home_dir(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_home_dir();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->home_dir;
}
string test_family(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_family_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->family_name;
}
string test_player_title(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_player_title();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->player_title;
}
int test_password(string name, string pass) {
  if (!load_player(name)) {
    return 0;
  }
  if (find_player(name) && player_cache[name]->password == "") {
    if(file_size(query_player_ram_file_name(name) + ".o.gz") > 0)
      unguarded((: restore_object, query_player_ram_file_name(name), 1 :));
    else
      unguarded((: restore_object, query_player_disk_file_name(name), 1 :));
    player_cache[name]->password = password;
  }
  return crypt(pass, player_cache[name]->password) ==
    player_cache[name]->password;
}
string get_password(string name) {
  if(file_name(previous_object()) != "/secure/ftp_auth")
    return "x";
  if(!load_player(name))
    return "x";
  if(find_player(name) && player_cache[name]->password == "") {
    unguarded((: restore_object,
               query_player_disk_file_name(name), 1 :));
  }
  return player_cache[name]->password;
}
string query_signature(string name) {
  string sig;
  if (find_player(name)) {
    map_delete(player_cache, name);
    sig =
      make_string(find_player(name)->query_player_alias(".signature"),
                  3);
  } else {
    if (!load_player(name))
      return "";
    sig = make_string(player_cache[name]->signature, 3);
  }
  if (sig && sig != "")
    sig = "\n--\n" + strip_colours(sig);
  return sig;
}
string query_project(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".project"))
      return make_string(find_player(name)->query_player_alias(".project"), 5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->project, 5);
}
string query_plan(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".plan"))
      return make_string(find_player(name)->query_player_alias(".plan"),
                         5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->plan, 5);
}
string query_reference(string name) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".reference"))
      return make_string(find_player(name)->
                         query_player_alias(".reference"), 20);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->reference, 20);
}
string test_nationality(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality();
  }
  if (!load_player(str)) {
    return 0;
  }
  return ((class player_record)player_cache[str])->nationality;
}
string test_nationality_region(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_region();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_region;
}
string test_nationality_data(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_data();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_data;
}
int test_ip_allowed(string name, string ip) {
  string *ips;
  if(ip == "127.0.0.1")
    return 1;
  if(find_player(name)) {
    map_delete(player_cache, name);
    ips = find_player(name)->query_rhosts();
  } else if (load_player(name))
    ips = player_cache[name]->player_info["allowed_ips"];
  if(!ips || !sizeof(ips))
    return 1;
  while(strlen(ip)) {
    if(member_array(ip, ips) != -1)
      return 1;
    ip = implode((string *)explode(ip, ".")[0..<2], ".");
  }
  return 0;
}
mixed *stats() {
  int percentage;
  if (requests)
    percentage = (cache_hits * 100) / requests;
  return ({ ({ "cache size", sizeof(player_cache) }),
              ({ "requests", requests }),
              ({ "cache hits", cache_hits }),
              ({ "cache misses", requests - cache_hits }),
              ({ "percentage hits", percentage }), });
}
nomask int query_prevent_shadow(object ob) { return 1; }

==================================================
FILE: handlers/player_shop.c
==================================================

#include <player_shop.h>
#include <mail.h>
#define REFRESH_HANDLER "/obj/handlers/refresh"
#define save_me() unguarded((:write_file, "/save/player_shops", \
                  save_variable(_shops), 1:));
private nosave mapping _shops = 0;
void create()
{
    seteuid("Root");
    if (file_size("/save/player_shops") > 0)
    {
        _shops = restore_variable(unguarded((:read_file,
              "/save/player_shops":)));
    }
}
int add_shop(string short_name, string office_path)
{
    string savedir;
    object ob;
    if (!(ob = find_object(office_path)))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    if (_shops)
    {
        if (_shops[short_name])
        {
            tell_object(this_player(), "Shop already exists.\n");
            return 0;
        }
        _shops += ([short_name:""]);
    }
    else
    {
        _shops = ([short_name:""]);
    }
    _shops[short_name] = office_path;
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    savedir = sprintf("/save/player_housing/%s/",
      lower_case(geteuid(ob)));
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/player_shops");
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/%s", short_name);
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    save_me();
    return 1;
}
int remove_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    map_delete(_shops, short_name);
    save_me();
    return 1;
}
int update_shop(string short_name, string office_path)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    if (!find_object(office_path))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    _shops[short_name] = office_path;
    save_me();
    return 1;
}
string query_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
        return "";
    if (!find_object(_shops[short_name]))
        return "No such file "+ _shops[short_name]+ ".";
    return _shops[short_name];
}
mapping query_shops() { return copy(_shops); }
void auto_mail(string to, string from, string sub, string cc, string body)
{
    if (_shops)
    {
        foreach (string shop in keys(_shops))
        {
            if (_shops[shop] == file_name(previous_object()))
            {
                return MAILER->do_mail_message(to, from, sub, cc, body, 0, 0, 1);
            }
        }
    }
    unguarded((: write_file, "/log/CHEAT",
        "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
        back_trace() :));
}

==================================================
FILE: handlers/playerinfo.c
==================================================

#include <playerinfo.h>
#include <player_handler.h>
#include <refresh.h>
#include <applications.h>
#include <newbiehelpers.h>
#define SAVE_DIR         "/save/playerinfo"
#define SAVE_FILE        ( SAVE_DIR + "/handler_data" )
#define NO_ACCESS_LOG    6
#define LIAISON_WAND       "/d/liaison/items/wand"
#define LIAISON_SCEPTRE    "/d/liaison/items/mort_sceptre"
#define LIAISON_PEN        "/d/liaison/items/quota_pen"
#define LIAISON_INTERVIEW  "/d/liaison/utils/interview"
#define MULTIPLAY          "/obj/handlers/multiplayer"
#define GAG                "/cmds/creator/gag"
#define UNGAG              "/cmds/creator/ungag"
#define METEOR             "/cmds/creator/meteor"
#define FRY                "/cmds/creator/fry"
#define REPORT_COMMAND     "/cmds/creator/playerinfo"
#define ADD_COMMAND        "/cmds/creator/addevent"
#define DELETE_COMMAND     "/cmds/creator/delevent"
#define ADDALT_COMMAND     "/cmds/creator/addalt"
#define DELALT_COMMAND     "/cmds/creator/delalt"
#define FAMILY_COMMAND     "/cmds/creator/family"
#define SUSPENDER          "/secure/bastards"
#define SHOWHELP_COMMAND   "/cmds/creator/show_help"
#define PATRICIAN_PALACE   "/d/am/patrician/patrician"
#define REFRESH_HANDLER    "/obj/handlers/refresh"
#define PRISON             "/d/sur/beta/prison/dungeon"
#define FETCH_COMMAND      "/cmds/creator/fetch"
#define REARRANGE_COMMAND  "/cmds/guild-race/rearrange"
#define PATRICIAN_PT       "/d/playtesters/handlers/applications"
#define PATRICIAN_COMPLAIN "/d/am/patrician/pat_complaints"
#define RUN_HANDLER        "/obj/handlers/guild_things/run"
#define BANISH_COMMAND     "/secure/cmds/creator/banish"
#define FAIRY_GODMOTHER    "/obj/handlers/fairy_godmothers"
#define CACHE_SIZE 150
#define CL_CREATOR      "%^CYAN%^"
#define CL_EVENT        "%^RED%^"
#define CL_RESET        "%^RESET%^"
#define CL_HEADER       "%^RED%^"
#define DEBOUNCE_PERIOD (60*30)
#define TIMEOUT_PERIOD  (60*60*24)
#define ONE_WEEK           ( 60 * 60 * 24 * 7 )
nosave inherit "/std/object";
mapping          query_timeouts();
protected string filename(string name);
string *         query_events();
protected int    query_debounced(string event);
protected int    query_lord_only(string event);
int              query_source_ok(string event, string source);
protected int    query_deleter_ok(string event, object deleter);
protected int    query_can_add(string e, object p);
protected int    query_can_delete(string e, object p);
protected int    query_can_handle_alts(object p);
protected void   do_debouncing(string player, class dbentry entry);
protected void   do_timeout();
protected void   load_player(string player);
protected void   save_player(string player);
void             player_remove(string player);
int              add_entry(object creator, string player, string event,
                   string comment, mixed *extra);
int              delete_entry(object creator, string player, string event,
                   int n);
protected string query_header(string player);
protected string query_entry(int idx, class dbentry e,
                   string display_name);
string           query_access_log(object source, string player, int lastn);
string           query_event(object source, string player, string event);
string           add_alt(object creator, string player, string alt);
string           delete_alt(object creator, string player, string alt);
mapping          query_alerts();
int              query_alerts_for( string player );
int              is_alert( string player, int idx );
int              acknowledge_alert( object creator, string player,
                   string event, int idx, string update, mixed * extra );
void             clear_alerts_for( string player );
int              increment_alerts_for( string player );
int              decrement_alerts_for( string player );
void             correct_alts_for( string player );
void player_deleted(mixed player, int deleted);
void fix_alts(mixed player);
class source {
   string *add;
   string *delete;
}
private class playerinfo    dossier;
private nosave mapping      timeouts    = ([ "replace" : (60*60*24*30) ]);
private int local_time;
private nosave mapping _sources;
nosave mapping _alerts;
nosave string * _lordonly;
private nosave int correcting_alts;
private nosave int no_recurse;
private nosave mapping _dossier_cache;
private nosave int _dossier_cache_hits;
private nosave int _dossier_total;
void save_handler_data() {
   mapping vars = ([ ]);
   string tmp;
   vars["alerts"] = _alerts;
   tmp = save_variable( vars );
   unguarded( (: write_file, SAVE_FILE, tmp, 1 :) );
}
void load_handler_data() {
   mapping vars;
   string tmp;
   if( file_size( SAVE_FILE ) <= 0 )
      return;
   tmp = unguarded( (: read_file, SAVE_FILE :) );
   vars = restore_variable( tmp );
   _alerts = vars["alerts"];
}
void create() {
    ::create();
    _sources = ([
        "cheat":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "discipline":   new(class source,
                            add : ({ ADD_COMMAND, PRISON, REPORT_COMMAND,
                                     BANISH_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "email":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "family":       new(class source,
                            add : ({ FAMILY_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "gag":          new(class source,
                            add : ({ GAG, UNGAG,
                                     ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "harassment":   new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "meteor":       new(class source,
                            add : ({ METEOR, FRY }),
                            delete : ({ DELETE_COMMAND })),
        "misc":         new(class source,
                            add : ({ ADD_COMMAND, APPLICATIONS_HANDLER,
                                     REARRANGE_COMMAND, PATRICIAN_PT,
                                     PATRICIAN_COMPLAIN, RUN_HANDLER,
                                     REPORT_COMMAND, NEWBIEHELPERS_HANDLER,
                                     LIAISON_SCEPTRE,
                                     LIAISON_PEN, FAIRY_GODMOTHER,
                                     LIAISON_INTERVIEW }),
                            delete : ({ DELETE_COMMAND })),
        "multiplay":    new(class source,
                            add : ({ MULTIPLAY, ADD_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "replace":      new(class source,
                            add : ({ LIAISON_WAND,
                                     ADD_COMMAND, FETCH_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "showhelp":     new(class source,
                            add : ({ SHOWHELP_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "suspend":      new(class source,
                            add : ({ SUSPENDER }),
                            delete : ({ })),
        "alert":        new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "refresh":      new(class source,
                            add : ({ REFRESH_HANDLER }),
                            delete : ({ DELETE_COMMAND })),
        "delete":      new(class source,
                           add : ({ REFRESH_HANDLER }),
                           delete : ({ DELETE_COMMAND }))
    ]);
    _alerts = ([ ]);
    _lordonly = ({ });
    _dossier_cache = ([ ]);
    _dossier_cache_hits = 0;
    _dossier_total = 0;
    seteuid("Room");
    load_handler_data();
}
mapping query_timeouts() {
    return timeouts;
}
string query_name() {
    return "playerinfo handler";
}
protected string filename(string name) {
    string p = lower_case(name);
    return sprintf("%s/%c/%s.o",SAVE_DIR,p[0],p);
}
string *query_events() {
    return keys(_sources);
}
protected int query_debounced(string event) {
    return (event == "replace" || event == "multiplay" ||
            event == "gag" || event == "misc" ||
            event == "discipline" || event == "showhelp" ||
            event == "suspend");
}
protected int query_lord_only(string event) {
    return ( member_array( event, _lordonly ) >= 0 ) ? 1 : 0;
}
int query_source_ok(string event, string source) {
    string *reqd;
    reqd = _sources[event]->add;
    if(reqd == 0) {
        return 1;
    }
    if(sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(source,reqd) >= 0;
}
protected int query_deleter_ok(string event, object deleter) {
    string *reqd;
    reqd = _sources[event]->delete;
    if (reqd == 0) {
        return 1;
    }
    if (sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(base_name(deleter),reqd) >= 0;
}
protected int query_can_add(string e, object p) {
    if(member_array(e,query_events()) < 0)
        return 0;
    if(!interactive(p))
        return 1;
    return !(query_lord_only(e) && !p->query_lord());
}
protected int query_can_delete(string e, object p) {
    if( !interactive(p) ) {
        return 1;
    }
    if( e == "misc" || e == "replace" ) {
        return master()->query_senior( p->query_name() ) ||
               "/d/liaison/master"->query_deputy( p->query_name() );
    }
    return p->query_lord();
}
protected int query_can_handle_alts(object p) {
    if( !interactive(p) ) {
        return 1;
    }
    return master()->query_senior( p->query_name() ) ||
           "/d/liaison/master"->query_deputy( p->query_name() );
}
protected void do_debouncing(string player, class dbentry entry) {
    int             n;
    class dbentry   last;
    if (query_debounced(entry->event)) {
        n = sizeof(dossier->data);
        if ( n ) {
            last = dossier->data[ n - 1 ];
            if( entry->event == last->event &&
                entry->creator == last->creator &&
                entry->time - last->time <= DEBOUNCE_PERIOD)
            {
                last->comment += entry->comment;
                last->time = entry->time;
                if(last->extra != 0) {
                    if(entry->extra == 0) {
                        entry->extra = ({ });
                    }
                    last->extra += entry->extra;
                }
                return;
            }
        }
    }
    dossier->data += ({ entry });
    return;
}
protected void do_timeout() {
    function not_timed_out = function(class dbentry p)
    {
        int life = timeouts[p->event];
        if(life == 0)
            return 1;
        return local_time <= (p->time + life);
    };
    local_time = time();
    dossier->data = filter(dossier->data, not_timed_out);
    dossier->last_check = time();
}
protected void load_player(string player) {
    string  p = lower_case(player);
    string  fn = filename(p);
    class playerinfo tmp;
    mixed result;
    _dossier_total++;
    if ( !undefinedp(_dossier_cache[ player ] ) ) {
        dossier = _dossier_cache[ player ];
        _dossier_cache_hits++;
        return;
    }
    if( dossier != 0 && dossier->name == p ) {
        return;
    }
    if(file_size(fn) > 0) {
        result = unguarded( (: restore_object, fn, 0 :) );
    } else {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }
    if (!classp(dossier)) {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }
    if(sizeof(dossier) == 5) {
      tmp = new(class playerinfo,
                name: dossier->name,
                last_check: dossier->last_check,
                alts: copy(dossier->alts),
                data: copy(dossier->data),
                main_alt: dossier->main_alt,
                old_alts: ({ }));
      dossier = tmp;
    }
    if(!dossier->old_alts)
      dossier->old_alts = ({ });
    if(!correcting_alts) {
        correct_alts_for( dossier->name );
    }
    _dossier_cache[ player ] = dossier;
}
protected void save_player(string player) {
    if( time() - dossier->last_check >= TIMEOUT_PERIOD ) {
        do_timeout();
    }
    unguarded( (: save_object, filename(player) :) );
}
void player_remove(string player) {
    string alt, new_main;
    string * alts;
    if ( !player ) {
        return;
    }
    player = lower_case( player );
    correcting_alts = 1;
    load_player( player );
    if ( sizeof( dossier->alts ) ) {
        alts = copy( dossier->alts );
        new_main = alts[0];
        alts -= ({ new_main });
        load_player( new_main );
        dossier->main_alt = 0;
        dossier->alts = uniq_array( alts + ({ player }) );
        save_player( new_main );
        foreach( alt in alts ) {
            load_player( alt );
            dossier->main_alt = new_main;
            save_player( alt );
        }
    }
    correcting_alts = 0;
    unguarded( (: rm, filename(player) :) );
    clear_alerts_for(player);
}
int add_entry(object creator, string player, string event, string comment,
  mixed *extra) {
    class dbentry   new_entry;
    if(!query_can_add(event,creator))
        return 0;
    if(!query_source_ok(event,base_name(previous_object())))
        return 0;
    if(!PLAYER_HANDLER->test_user(lower_case(player)))
        return 0;
    if(comment[<1..<1] != "\n") {
        comment += "\n";
    }
    load_player(player);
    new_entry = new(class dbentry,
            time:       time(),
            creator:    capitalize(creator->query_name()),
            event:      event,
            comment:    (comment == 0 ? "" : comment),
            extra:      extra);
    do_debouncing(player, new_entry);
    save_player(player);
    if( event == "alert" )
        increment_alerts_for(player);
    return 1;
}
int delete_entry(object creator, string player, string event, int n) {
   int idx = n - 1;
   class dbentry * data;
   class dbentry fluff;
   if( !query_can_delete( event, creator ) )
      return 0;
   if( !query_deleter_ok( event, previous_object() ) )
      return 0;
   load_player(player);
   if( ( idx < 0 ) || ( idx >= sizeof( dossier->data ) ) )
      return 0;
   fluff =  dossier->data[idx];
   if( fluff->event != event )
      return 0;
   data = copy( dossier->data );
   data = data[0 .. (idx - 1)] + data[(idx + 1) .. <1];
   dossier->data = data;
   save_player(player);
   log_file("DELETE", ctime(time()) + ": " + event + " added by " +
            fluff->creator + "\n");
   if( event == "alert" )
      decrement_alerts_for(player);
   return 1;
}
protected string query_header( string player ) {
  string aka, alts, str;
  string *tmp, *tmp2;
  aka = alts = str = "";
  if( sizeof( dossier->alts ) > 0 )
    alts = " aka " +
      query_multiple_short(map(dossier->alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :)));
  if(sizeof(dossier->old_alts) > 0)
    alts += " (and was " +
      query_multiple_short(map(dossier->old_alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :))) + ")";
  if( dossier->main_alt ) {
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      fix_alts(player);
      load_player(player);
    }
    aka = " (alt of " + CL_HEADER + capitalize(dossier->main_alt) + CL_RESET;
    load_player(dossier->main_alt);
    tmp = copy(dossier->alts);
    tmp2 = copy(dossier->old_alts);
    if(!tmp) {
      tmp = ({ });
      dossier->alts = ({ });
      save_player( dossier->name );
    }
    load_player(player);
    tmp -= ({ player });
    if(sizeof(tmp))
      aka += ", aka " +
        query_multiple_short(map(tmp, (: CL_HEADER+capitalize($1)+CL_RESET :)));
    if( arrayp( tmp2 ) ) {
      tmp2 -= ({ player });
      if(sizeof(tmp2)) {
        aka += " and was " +
          query_multiple_short(map(tmp2, (: CL_HEADER+capitalize($1)+CL_RESET:)));
      }
    }
    aka += ")";
  }
  return sprintf( "Report for: %s%s%s\n\n",
                  CL_HEADER + capitalize(player) + CL_RESET, alts, aka );
}
protected string query_entry( int idx, class dbentry e,
                              string display_name ) {
   string  date      = ctime( e->time );
   string  creator   = e->creator;
   string  event     = e->event;
   string  *comments = explode( e->comment, "\n" );
   string  line, str;
   int     lines = 0;
   if( display_name )
      display_name = sprintf( "%-31s ",
        "(" + CL_CREATOR + display_name + CL_RESET + ")" );
   else
      display_name = "";
   str = sprintf( "%2d. %s%s %s%|14s%s (by %s%s%s)\n",
     idx + 1, display_name, date, CL_EVENT, event, CL_RESET,
     CL_CREATOR, creator, CL_RESET );
   foreach( line in comments ) {
      if( sizeof(line) != 0 ) {
         str += sprintf( "    %s\n", line );
         lines++;
      }
   }
   if( !lines ) {
      str += sprintf( "    (no comments)\n" );
   }
   return str;
}
varargs string query_dossier( object source, string player, int lastn ) {
   int             i;
   class dbentry   * list;
   string          msg, str;
   mapping         log;
   load_player(player);
   str = query_header(player);
   list = dossier->data;
   if ( sizeof( dossier ) == NO_ACCESS_LOG ) {
    dossier = new ( class playerinfo,
        name: dossier->name,
        last_check: dossier->last_check,
        alts: dossier->alts,
        data: dossier->data,
        main_alt: dossier->main_alt,
        old_alts: dossier->old_alts,
        access_log: ([ ]) );
   }
   if ( mapp( dossier->access_log ) )
     log = dossier->access_log;
   else
     log = ([ ]);
   if( !lastn ||
       sizeof(list) <= lastn ||
       source->query_property(VERBOSE_PI) )
   {
      i = 0;
   } else {
      i = sizeof(list) - lastn;
      msg = "%^RED%^NOTE:%^RESET%^ Only displaying this player's most "
        "recent " + lastn + " entries.  Use 'playerinfo "
        + player + " verbose' to see their entire dossier.\n";
      str += msg + "\n";
   }
   for( ; i < sizeof( list ); i++ ) {
      str += query_entry( i, list[i], 0 );
   }
   if( msg ) {
      str += "\n" + msg;
   }
   log = filter( log, (: $2 > time() - ONE_WEEK :) );
   if ( interactive( source ) )
     log[ source->query_name() ] = time();
  dossier->access_log = log;
  save_player( player );
  return str;
}
string query_event( object source, string player, string event ) {
   int             i;
   class dbentry   *list;
   string          str;
   load_player(player);
   str = query_header(player);
   list = dossier->data;
   for( i = 0; i < sizeof(list); i++ ) {
      if( list[i]->event == event )
         str += query_entry( i, list[i], 0 );
   }
   return str;
}
string query_interleaved( object source, string player, string event ) {
   class playerinfo * dossiers;
   class dbentry * stuff;
   string str;
   string * alts;
   int i, size, done, earliest, earliestt, count;
   int * earliests;
   load_player(player);
   if( dossier->main_alt ) {
      player = dossier->main_alt;
      load_player(player);
   }
   str = query_header(player);
   alts = ({ player }) + copy( dossier->alts );
   size = sizeof(alts);
   if( size == 1 ) {
      if(event) {
        str = query_event( source, player, event );
      } else {
        str = query_dossier( source, player );
      }
      return str;
   }
   dossiers = allocate(size);
   earliests = allocate(size);
   for( i = 0; i < size; i++ ) {
     load_player( alts[i] );
     if( sizeof( dossier->data ) ) {
       dossiers[i] = copy(dossier);
     } else {
       dossiers[i] = 0;
     }
     earliests[i] = 0;
   }
   count = 0;
   while( !done ) {
      done = 1;
      earliestt = 0;
      for( i = 0; i < size; i++ ) {
         if( !dossiers[i] ) {
            continue;
         }
         done = 0;
         stuff = dossiers[i]->data;
         if( !earliestt || stuff[ earliests[i] ]->time < earliestt ) {
            earliest = i;
            earliestt = stuff[ earliests[i] ]->time;
         }
      }
      if(done) {
         continue;
      }
      stuff = dossiers[earliest]->data;
      if( !event ||
          stuff[ earliests[earliest] ]->event == event )
      {
         str += query_entry( count, stuff[ earliests[earliest] ],
                             alts[earliest] );
         count++;
      }
      earliests[earliest]++;
      if( earliests[earliest] >= sizeof(stuff) ) {
         dossiers[earliest] = 0;
      }
   }
   return str;
}
string query_alt_of(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return 0;
  load_player(player);
  return dossier->main_alt;
}
string *query_alts(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return ({ });
  load_player(player);
  return dossier->alts;
}
string add_alt(object creator, string player, string alt) {
  class dbentry new_entry;
  int is_deleted;
  string *alts, tmp;
  if((base_name(previous_object()) != "/cmds/player/register") &&
     !query_can_handle_alts(this_player()))
    return "You are not allowed to add players' alts.\n";
  alt = lower_case(alt);
  if(!find_player(alt) && !PLAYER_HANDLER->test_user(alt)) {
    if(!creator)
      return "No such player: " + capitalize(alt) + ".\n";
    if(file_size(filename(alt)) == -1)
      return "No such player and no record for: " + capitalize(alt) + ".\n";
    is_deleted = 1;
  }
  load_player(alt);
  if(dossier->main_alt && PLAYER_HANDLER->test_user(dossier->main_alt) &&
     !is_deleted)
    return capitalize(alt) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  if(sizeof(dossier->alts)) {
    if(is_deleted)
      return capitalize(alt) + " already has alts.\n";
    else {
      alts = dossier->alts + dossier->old_alts;
    }
  }
  player = lower_case(player);
  if(!find_player(player) && !PLAYER_HANDLER->test_user(player))
    return "No such player: "+ capitalize(player) +".\n";
  correcting_alts = 1;
  load_player(player);
  if(dossier->main_alt == alt) {
    correcting_alts = 0;
    return capitalize(player) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  }
  if(dossier->alts && member_array(alt, dossier->alts) != -1) {
    correcting_alts = 0;
    return capitalize(alt) + " is already an alt of " +
      capitalize(player) + ".\n";
  }
  if(!dossier->alts)
    dossier->alts = ({ });
  dossier->alts += ({ alt });
  if(alts) {
    foreach(tmp in alts) {
      if(PLAYER_HANDLER->test_user(tmp))
        dossier->alts += ({ tmp });
      else
        dossier->old_alts += ({ tmp });
    }
  }
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered " + capitalize(alt) +
                              " as an alt.\n",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  load_player(alt);
  dossier->main_alt = player;
  dossier->alts = ({ });
  dossier->old_alts = ({ });
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered as an alt of " + player + ".\n",
                  extra:      0);
  do_debouncing(alt, new_entry);
  save_player(alt);
  correcting_alts = 0;
  return "Added " + capitalize(alt) + " as an alt of " + capitalize(player) +
    ".\n";
}
string delete_alt(object creator, string player, string alt) {
  string ret;
  class dbentry new_entry;
  if(!query_can_handle_alts(this_player()))
    return "You are not allowed to delete players' alts.\n";
  player = lower_case(player);
  alt = lower_case(alt);
  load_player(player);
  if(!dossier->alts || member_array(alt, dossier->alts) == -1)
    ret = capitalize(alt) + " was not an alt of " + capitalize(player);
  else {
    dossier->alts -= ({ alt });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed " + capitalize(alt) + " as an alt.\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(player);
  }
  load_player(alt);
  if(dossier->main_alt != player) {
    if(ret)
      return capitalize(alt) + " is not an alt of " + capitalize(player) +
        ".\n";
    else
      ret = capitalize(player) + " was not the main player for " +
        capitalize(alt);
  } else {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    dossier->old_alts = ({ });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed as an alt of " + capitalize(player) +
                    ".\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(alt);
  }
  if(ret)
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts (" + ret + ").\n";
  else
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts.\n";
}
mapping query_alerts() {
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts;
}
int query_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts[player];
}
int is_alert( string player, int idx ) {
   load_player( player );
   if( sizeof(dossier->data) < idx ) {
      return 0;
   }
   return ( dossier->data[ idx - 1 ] )->event == "alert";
}
int acknowledge_alert( object creator, string player, string event,
   int idx, string update, mixed * extra ) {
   class dbentry entry;
   string previnfo;
   player = lower_case(player);
   if( !query_can_add( event, creator ) )
      return 0;
   if( !query_source_ok( "alert", base_name( previous_object() ) ) )
      return 0;
   if( !query_source_ok( event,  base_name( previous_object() ) ) )
      return 0;
   if( !PLAYER_HANDLER->test_user(player) )
      return 0;
   if( member_array( event, keys(_sources) ) < 0 )
      return 0;
   idx--;
   load_player( player );
   entry = dossier->data[idx];
   previnfo = sprintf( "Originally added by %s%s%s at %s:\n%s\n---\n",
     CL_CREATOR, entry->creator, CL_RESET, ctime( entry->time ),
     entry->comment );
   entry->time    = time();
   entry->creator = capitalize( creator->query_name() );
   entry->event   = lower_case( event );
   entry->comment = previnfo + update;
   dossier->data[idx] = entry;
   if( event != "alert" ) {
      decrement_alerts_for(player);
   }
   save_player( player );
   return 1;
}
void clear_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   map_delete( _alerts, player );
   save_handler_data();
}
int increment_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   if( !PLAYER_HANDLER->test_user(player) ) {
      return 0;
   }
   if( undefinedp( _alerts[player] ) ) {
      _alerts[player] = 1;
   } else {
      _alerts[player] = _alerts[player] + 1;
   }
   save_handler_data();
   return _alerts[player];
}
int decrement_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   if( undefinedp( _alerts[player] ) ) {
      return 0;
   }
   _alerts[player] = _alerts[player] - 1;
   if(_alerts[player] <= 0 ) {
      map_delete( _alerts, player );
   }
   save_handler_data();
   return _alerts[player];
}
string * query_online_alerts() {
   if ( !_alerts ) {
      _alerts = ([ ]);
      return ({ });
   }
   return filter( keys(_alerts), (: find_player($1) :) );
}
private void correct_alts_for(string player) {
  string main;
  string *alts, *tmp, alt;
  if(!player)
    return;
  player = lower_case(player);
  correcting_alts = 1;
  load_player(player);
  main = dossier->main_alt;
  alts = copy(dossier->alts);
  if(main && !no_recurse) {
    if(sizeof(alts)) {
      dossier->alts = ({ });
      save_player(player);
    }
    if((!PLAYER_HANDLER->test_user(player) ||
        !PLAYER_HANDLER->test_user(main))) {
      correcting_alts = 0;
      no_recurse = 1;
      correct_alts_for(main);
      load_player(player);
    }
    return;
  }
  if(!PLAYER_HANDLER->test_user(player)) {
    if(!sizeof(alts)) {
      if(this_player()->query_name("ceres"))
        write("No alts for : " + player + "\n");
      correcting_alts = 0;
      return;
    }
    tmp = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp)) {
      main = tmp[0];
    }
  }
  if(main) {
    dossier->main_alt = main;
    dossier->alts = ({ });
    save_player(player);
  }
  if(main)
    load_player(main);
  if(sizeof(alts)) {
    tmp = filter(alts, (: !find_player($1) &&
                        !PLAYER_HANDLER->test_user($1) :));
    tmp = uniq_array(dossier->old_alts + tmp);
  } else
    alts = ({ });
  alts = uniq_array(alts + dossier->alts) - ({ main });
  alts = filter(alts, (: find_player($1) || PLAYER_HANDLER->test_user($1) :));
  if(main && (alts != dossier->alts || tmp != dossier->old_alts)) {
    dossier->alts = copy(alts);
    dossier->old_alts = copy(tmp);
    save_player(main);
    foreach(alt in alts) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
    foreach(alt in tmp) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
  }
  load_player(player);
  correcting_alts = 0;
}
void reregister_parent( string player ) {
   string main;
   string * alts;
   if ( !player ) {
      return;
   }
   player = lower_case(player);
   correcting_alts = 1;
   load_player( player );
   main = dossier->main_alt;
   if ( main ) {
      load_player(main);
      alts = dossier->alts;
      if ( !alts || !sizeof( alts ) ) {
         dossier->alts = ({ player });
      } else if ( member_array( player, alts ) == -1 ) {
         dossier->alts = alts + ({ player });
      } else {
         return;
      }
      save_player( main );
   }
}
void player_refreshed(mixed player, int totally) {
  class dbentry new_entry;
  string comment;
  if(objectp(player))
    player = player->query_name();
  switch (totally) {
  case PARTIAL_REFRESH:
    comment = "They did a partial refresh.";
    break;
  case TOTAL_REFRESH:
    comment = "They did a total and complete refresh.  (Even refreshed their "
      "breath)";
    break;
  default:
    comment = "They did some weird sort of unknown refresh.";
    break;
  }
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "refresh",
                  comment:    comment,
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
}
void player_deleted(mixed player, int deleted) {
  class dbentry new_entry;
  string *tmp, *tmp2, alt, main;
  if(objectp(player))
    player = player->query_name();
  if(file_size(filename(player)) == -1)
    return;
  clear_alerts_for(player);
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "delete",
                  comment:    "Player deleted",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  if(dossier->main_alt) {
    main = dossier->main_alt;
    dossier->main_alt = 0;
    save_player(player);
    load_player(main);
    dossier->alts -= ({ player });
    dossier->old_alts += ({ player });
    save_player(main);
    return;
  }
  if(dossier->alts && sizeof(dossier->alts)) {
    tmp = filter(dossier->alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp))
      main = tmp[0];
    tmp2 = dossier->old_alts;
    load_player(main);
    dossier->main_alt = 0;
    if(sizeof(tmp) > 1)
      dossier->alts = copy(tmp[1..]);
    dossier->old_alts = copy(tmp2 + ({ player }));
    save_player(main);
    foreach(alt in dossier->alts) {
      load_player(alt);
      dossier->main_alt = main;
      save_player(alt);
    }
    return;
  }
}
void player_created(string player) {
  if(file_size(filename(player)) == -1)
    return;
  load_player(player);
  if(dossier->main_alt) {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    save_player(player);
  }
  return;
}
void fix_alts(mixed player) {
  string *alts, alt, main;
  if(objectp(player))
    player = player->query_name();
  if(file_size(filename(player)) == -1)
    return;
  load_player(player);
  if(dossier->main_alt) {
    main = dossier->main_alt;
    load_player(dossier->main_alt);
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      if(sizeof(alts))
        main = alts[0];
    }
  } else {
    main = player;
  }
  alts = ({});
  if( dossier->alts ) {
     alts = alts + dossier->alts;
  }
  if( dossier->old_alts ) {
     alts = alts + dossier->old_alts;
  }
  alts = uniq_array( alts + ({ player }));
  alts -= ({ main });
  dossier->main_alt = 0;
  dossier->alts = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
  dossier->old_alts = filter(alts, (: !PLAYER_HANDLER->test_user($1) :));
  foreach(alt in alts) {
    load_player(alt);
    dossier->main_alt = main;
    dossier->alts = 0;
    dossier->old_alts = 0;
    save_player(alt);
  }
}
void reset() {
    if ( sizeof( _dossier_cache ) > CACHE_SIZE ) {
        _dossier_cache = ([ ]);
    }
}
string query_access_history( string player ) {
  mapping history;
  string ret = "";
  load_player(player);
  history = dossier->access_log;
  ret += sprintf( "Access log for player %s:\n", capitalize( player ) );
  foreach( string name in sort_array( keys( history ),
                                      (: $(history)[$2] - $(history)[$1] :) ))
    ret += sprintf( "%12s:\t%s.\n", capitalize(name),
                    query_time_string( time() - history[name], 2 ) + " ago");
  return ret;
}
mixed *stats() {
    return ({
        ({ "cache hits", _dossier_cache_hits }),
        ({ "total requests", _dossier_total }),
        ({ "cache hit %", to_int(_dossier_cache_hits * 100.0 /
                                 _dossier_total) }),
        ({ "current cache size", sizeof( _dossier_cache ) })
    });
}

==================================================
FILE: handlers/playtesters.c
==================================================

#include <board.h>
#include <project_management.h>
#include <player_handler.h>
#include <playtesters.h>
#include <login.h>
#define SAVE_FILE "/save/playtesters"
#define LEVEL 150
#define NORMAL_PLAYTESTER 1
#define SENIOR_PLAYTESTER 2
#define BUG_SKIP 10
private int count = 0;
private nosave int updating = 0;
private string* months = ({});
private mapping pts = ([]);
private mapping playtesters = ([]);
private mapping ages = ([]);
private mapping guilds = ([]);
private mapping bugs = ([]);
private mapping leave = ([]);
private mapping tmp_pts = ([ ]);
private mapping _jump_points;
private string *executives = ({ });
int query_leave (string);
void save_file() {
    unguarded( (: save_object, SAVE_FILE :) );
}
void create() {
   seteuid( master()->creator_file( file_name( this_object() ) ) );
   months = ({ });
   pts = ([ ]);
   ages = ([ ]);
   guilds = ([ ]);
   bugs = ([ ]);
   playtesters = ([ ]);
   leave = ([ ]);
   tmp_pts = ([ ]);
   _jump_points = ([ ]);
   executives = ({ });
   if ( file_size( SAVE_FILE + ".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE, 1 :) );
   call_out( "reset", 2 );
}
string* query_playtesters() {
    return copy( keys( pts ) );
}
int query_playtester( string name ) {
  return !undefinedp( pts[ name ] );
}
int check_playtester( string ) {
    log_file( "PLAYTESTERS", file_name( previous_object() ) + " using "
              "deprecated check_playtester() call\n" );
    return 0;
}
int query_tester( mixed person ) {
    object ob;
    string str;
    if ( stringp( person ) ) {
        ob = find_player( person );
        if ( !ob ) {
            return 0;
        }
        str = person;
    } else if ( objectp( person ) ) {
        ob = person;
        str = person->query_name();
    } else {
        return 0;
    }
    return ( ob->query_creator() ||
             ob->query_property( "test character" ) ||
             query_playtester( str ) );
}
protected int get_age_raw( string name ) {
    int fu = PLAYER_HANDLER->test_age( name );
    if ( fu < 0 )
        fu = -fu;
    return fu;
}
int get_age_cached( string name ) {
    if ( ages[ name ] < 0 )
        ages[ name ] = -ages[ name ];
    return ages[ name ];
}
int get_age_uncached( string name ) {
    if ( find_player( name ) )
        ages[ name ] = find_player( name )->query_time_on();
    return get_age_cached( name );
}
int get_age_uncached_offline( string name ) {
    ages[ name ] = get_age_raw( name );
    return get_age_cached( name );
}
int query_senior_playtester( string name ) {
    return ( pts[ name ] == SENIOR_PLAYTESTER );
}
int add_playtester( string name ) {
    if ( pts[ name ] )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " added as a playtester by %s\n", this_player()->query_name() );
    pts[ name ] = NORMAL_PLAYTESTER;
    ages[ name ] = get_age_uncached_offline( name );
    guilds[ name ] = PLAYER_HANDLER->test_guild( name );
    bugs[ name ] = ([ ]);
    if (tmp_pts[name]) {
      if (tmp_pts[name] == SENIOR_PLAYTESTER) {
        pts[name] = SENIOR_PLAYTESTER;
      }
      map_delete (tmp_pts, name);
    }
    PT_APPLICATION_HANDLER->delete_applicant (name);
    save_file();
    return 1;
}
int add_senior_playtester( string name ) {
    if ( pts[ name ] != NORMAL_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to senior playtester by %s\n",
              this_player()->query_name() );
    pts[ name ] = SENIOR_PLAYTESTER;
    save_file();
    return 1;
}
int remove_senior_playtester( string name, string reason ) {
    if ( pts[ name ] != SENIOR_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " demoted from senior playtester; Reason: " + reason +
              " by "+ this_player()->query_name() + "\n" );
    pts[ name ] = NORMAL_PLAYTESTER;
    save_file();
    return 1;
}
int remove_playtester( string name, string reason ) {
    string str;
    if ( !query_playtester( name ) )
        return 0;
    str = ctime( time() ) +": "+ name + " removed as a playtester";
    if ( reason ) {
        str += "; Reason: " + reason;
    }
    str += " by "+ this_player()->query_name() + "\n" ;
    log_file( "PLAYTESTERS", str + "\n" );
    map_delete( pts, name );
    map_delete( ages, name );
    map_delete( guilds, name );
    map_delete( bugs, name );
    PROJECT_HANDLER->clear_playtesting_projects (({name }));
    save_file();
    return 1;
}
string reason_invalid_playtester(string name) {
    if ( !PLAYER_HANDLER->test_user( name ) ) {
        return "not a user";
    }
    if ( PLAYER_HANDLER->test_creator( name ) ) {
        return "currently a creator";
    }
    if ( PLAYER_HANDLER->test_level( name ) < LEVEL ) {
        return "level is too low";
    }
    return 0;
}
int valid_playtester( string name ) {
    return ( !stringp( reason_invalid_playtester( name ) ) );
}
int hire_playtester( object thing ) {
    string name;
    if ( !objectp( thing ) )
        return 0;
    name = thing->query_name();
    if ( !stringp( name ) )
        return 0;
    if ( !valid_playtester( name ) )
        return 0;
    return add_playtester( name );
}
void adjust_quota( string name, int amount ) {
    string* bits;
    string right_now;
    int* bing;
    int age;
    bits = explode( ctime( time() ), " " ) - ({ "" });
    right_now = bits[ 1 ] + " " + bits[ 4 ];
    if (!bugs[name][right_now]) {
      bugs[name][right_now] = 0;
    }
    bing = bugs[ name ][ right_now ];
    age = get_age_uncached( name );
    if ( arrayp( bing ) && ( sizeof( bing ) == 3 ) ) {
        bing[ 0 ] += amount;
        bing[ 1 ] += age - bing[ 2 ];
        bing[ 2 ] = age;
    } else {
        bing = ({ amount, 0, age });
    }
    bugs[ name ][ right_now ] = bing;
    save_file();
}
protected void check_playtesters_one( string name ) {
    if ( !valid_playtester( name ) ) {
        remove_playtester( name, reason_invalid_playtester( name ) +
                           " [automatic]" );
    } else {
        adjust_quota( name, 0 );
    }
}
void check_playtesters( string* who ) {
    string* bits;
    string right_now;
    if ( sizeof( who ) ) {
        check_playtesters_one( who[ 0 ] );
        if ( sizeof( who ) > 1 ) {
            call_out( "check_playtesters", random( 10 ) + 5, who[ 1.. ] );
        } else {
            bits = explode( ctime( time() ), " " ) - ({ "" });
            right_now = bits[ 1 ] + " " + bits[ 4 ];
            if ( member_array( right_now, months ) < 0 ) {
                months += ({ right_now });
                save_file();
            }
        }
    }
}
void reset() {
    if ( !updating )
        call_out( "check_playtesters", 30, copy( keys( pts ) ) );
    updating++;
    updating %= 12;
}
void report_made( string name, string type, string file, string text ) {
    int post = 0;
    if ( !query_playtester( name ) )
        return;
    if ( regexp( type, "IDEA" ) ) {
        post = 1;
    } else if ( regexp( type, "BUG" ) ) {
        count = ( count + 1 ) % BUG_SKIP;
        post = ( count == 0 );
    }
    if ( post ) {
        BOARD_HAND->add_message( "playtester_bugs", capitalize( name ),
                                 type + " for " + file,
                                 sprintf( "%75-=s", text ) );
    }
    adjust_quota( name, 1 );
}
string query_show_list() {
    string result;
    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        if ( query_senior_playtester( name ) ) {
            result += "S ";
        } else {
            result += "  ";
        }
        if ( stringp( leave[ name ] ) )
            result += sprintf( "%-14s", "[" + name + "]" );
        else
            result += sprintf( " %-12s ", name );
        foreach ( string month in months[ <5.. ] ) {
            if ( sizeof( bugs[ name ][ month ] ) >= 2 )
                result += sprintf( "   %4d %4d", bugs[ name ][ month ][ 0 ],
                                   ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            else
                result += "   ---- ----";
        }
        result += "\n";
    }
    return result;
}
string query_show_list_colour() {
    string result;
    string colour;
    int online, reports;
    string temp;
    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        reports = 0;
        online = 0;
        if ( query_senior_playtester( name ) ) {
            temp = "S ";
        } else {
            temp = "  ";
        }
        temp += sprintf( "%%s%-12s%%%%^RESET%%%%^", name );
        foreach ( string month in months[ <5.. ] ) {
	          if (query_leave (name)) {
                    colour = "%%^WHITE%%^";
	          }
            else if ( sizeof( bugs[ name ][ month ] ) >= 2 ) {
                reports += bugs[ name ][ month ][ 0 ];
                online += bugs[ name ][ month ][ 1 ];
                if ( bugs[ name ][ month ][ 1 ] == 0 )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^MAGENTA%%^" :
                               "%%^BOLD%%^%%^MAGENTA%%^" );
                else if ( bugs[ name ][ month ][ 0 ] >=
                     ( bugs[ name ][ month ][ 1 ] / 7200 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^GREEN%%^" :
                               "%%^BOLD%%^%%^GREEN%%^" );
                else if ( bugs[ name ][ month ][ 0 ] <
                          ( bugs[ name ][ month ][ 1 ] / 24000 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^RED%%^" :
                               "%%^BOLD%%^%%^RED%%^" );
                else
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^ORANGE%%^" :
                               "%%^YELLOW%%^" );
                temp += sprintf( "   %s%4d %4d%%%%^RESET%%%%^",
                                 colour,
                                 bugs[ name ][ month ][ 0 ],
                                 ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            } else
                temp += "   ---- ----";
        }
        temp += "\n";
        if ( online == 0 )
            colour = ( stringp( leave[ name ] ) ?
                       "%^BOLD%^%^WHITE%^" :
                       "%^BOLD%^%^MAGENTA%^" );
        else if ( reports >= ( online / 7200 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^GREEN%^" :
                       "%^BOLD%^%^GREEN%^" );
        else if ( reports < ( online / 24000 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^RED%^" :
                       "%^BOLD%^%^RED%^" );
        else
            colour = ( stringp( leave[ name ] ) ?
                       "%^ORANGE%^" :
                       "%^YELLOW%^" );
        result += sprintf( temp, colour );
    }
    return result;
}
mapping query_playtester_guilds() {
    mapping r = ([]);
    foreach ( string pt, string guild in guilds ) {
        if ( arrayp( r[ guild ] ) )
            r[ guild ] += ({ pt });
        else
            r[ guild ] = ({ pt });
    }
    return r;
}
mapping query_guilds() {
    return copy( guilds );
}
void update_guilds() {
  string guild;
    foreach( string player, mapping data in playtesters ) {
        if ( !sizeof (data[ "guild" ]) ) {
            guild = PLAYER_HANDLER->test_guild( player );
            if (!sizeof (guild)) {
              guild = "/std/guilds/standard";
            }
            data[ "guild" ] = guild;
        }
    }
    save_file();
}
mixed query_pt_data( string name ) {
    if ( !undefinedp( playtesters[ name ] ) )
        return copy( playtesters[ name ] );
    return 0;
}
mapping query_bugs( string name ) {
    return copy( bugs[ name ] );
}
string* query_months() {
    return copy( months );
}
int set_leave( string name, string reason ) {
    if ( pts[ name ] ) {
        leave[ name ] = reason;
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " marked as "
                  "on leave: " + reason + "\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
}
int reset_leave( string name ) {
    if ( leave[ name ] ) {
        map_delete( leave, name );
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " no longer "
                  "marked as on leave\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
}
int query_leave( string name ) {
    return stringp( leave[ name ] );
}
#ifdef PLAYTESTERS_HANDLER_OLD_STYLE_CONVERSION
void transfer_data_callout( string* pts ) {
    string pt;
    mixed bing;
    int lastage;
    int nowage;
    if ( sizeof( pts ) ) {
        pt = pts[ 0 ];
        nowage = get_age_uncached_offline( pt );
        lastage = nowage - playtesters[ pt ][ "age" ];
        guilds[ pt ] = PLAYER_HANDLER->test_guild( pt );
        ages[ pt ] = nowage;
        bugs[ pt ] = ([ ]);
        foreach ( string s in keys( playtesters[ pt ] ) -
                  ({ "senior", "age", "current age", "guild" }) ) {
            bing = playtesters[ pt ][ s ];
            if ( arrayp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing[ 0 ], bing[ 1 ], nowage });
            } else if ( intp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing, lastage, nowage });
            }
        }
        tell_creator( "arienne", "Done " + pt + "!\n" );
        if ( sizeof( pts ) > 1 ) {
            call_out( "transfer_data_callout", 5, pts[ 1.. ] );
        } else {
            save_file();
            tell_creator( "arienne", "Done the transfer!\n" );
        }
    }
}
void transfer_data_to_new_system() {
    foreach ( string pt in keys( playtesters ) ) {
        if ( playtesters[ pt ][ "senior" ] )
            pts[ pt ] = SENIOR_PLAYTESTER;
        else
            pts[ pt ] = NORMAL_PLAYTESTER;
    }
    call_out( "transfer_data_callout", 5, copy( keys( playtesters ) ) );
}
#endif
mapping query_jump_points() {
   if (!_jump_points) {
      _jump_points = ([ ]);
   }
   return copy(_jump_points);
}
void add_jump_point(string from, string to) {
   if (!_jump_points[from]) {
      _jump_points[from] = ({ });
   }
   _jump_points[from] += ({ to });
   save_file();
}
void remove_jump_point_from(string from) {
   map_delete(_jump_points, from);
   save_file();
}
void remove_jump_point(string from, string to) {
   if (_jump_points[from]) {
      _jump_points[from] -= ({ to });
      if (!sizeof(_jump_points[from])) {
         map_delete(_jump_points, from);
      }
      save_file();
   }
}
string* query_jump_destination(string from) {
   return _jump_points[from];
}
int add_pt_exec( string name ) {
    if ( undefinedp (pts[ name ]))
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to playtester executive by %s\n",
              this_player()->query_name() );
    executives += ({ name });
    save_file();
    return 1;
}
int remove_pt_exec( string name ) {
    if ( !undefinedp (pts[ name ]))
        return 0;
    if (member_array (name, executives) == -1) {
      return 0;
    }
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " removed from playtester executive by %s\n",
              this_player()->query_name() );
    executives -= ({ name });
    save_file();
    return 1;
}
int query_pt_exec(string name) {
  if (member_array (name, executives) == -1) {
    return 0;
  }
  return 1;
}
int query_exec_access (string name) {
  if (master()->query_senior(name)) {
    return 1;
  }
  if (query_pt_exec (name)) {
    return 1;
  }
  if (query_senior_playtester (name)) {
    return 1;
  }
  if (load_object ("/d/playtesters/master")->query_deputy (name)) {
    return 1;
  }
  return 0;
}

==================================================
FILE: handlers/potion.c
==================================================

inherit "/std/object";
mapping paths = allocate_mapping(10);
mapping potions = allocate_mapping(10);
#define POTION_DIR "/obj/potions/"
string *directories = ({
    POTION_DIR,
});
void create() {
    string dir, s, dummy, title, path, index;
    int d, i;
    seteuid("Room");
    for (d = 0; d < sizeof(directories); d++) {
        dir = directories[d];
        index = dir + "index";
        i = 1;
        if (file_size(index) > 0) {
            while (s = read_file(index, i++, 1)) {
                if ((s == "") || (sscanf(s, "#%s", dummy))) {
                    continue;
                }
                if (sscanf(s, "\"%s\"%*s\"%s\"", title, path) != 3) {
                    continue;
                }
                paths[title] = path;
                potions[title] = 0;
            }
        }
    }
    ::create();
}
int query_min_level(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return -1;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_min_level();
}
string query_chant(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return 0;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_chant();
}
object query_potion(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
       return 0;
    }
    if (!potions[s]) {
       potions[s] = clone_object(paths[s]);
    }
    return potions[s];
}
mixed clone_reagent(string s) {
    object pot;
    string potion;
    potion = this_player()->expand_nickname(s);
    if (undefinedp(paths[potion])) {
      return -1;
    }
    pot = query_potion(s);
    printf("Verb = %O\n", query_verb());
    return pot->clone_reagent(query_verb());
}
mapping query_paths() {
    return paths;
}
mapping query_potions() {
    return potions;
}

==================================================
FILE: handlers/potion_space.c
==================================================

#define SAVE_FILE "/save/potion_space"
mixed *effect_vols;
void create() {
  seteuid("Room");
  unguarded((: restore_object, SAVE_FILE :));
}
int add_effect(string ob, int x1, int x2, int y1, int y2) {
   if (!stringp(ob)) {
      tell_object(this_player(), "Effect object must be a string.\n");
      return 0;
   }
   effect_vols = ({ ob, x1, x2, y1, y2 }) + effect_vols;
   unguarded((: save_object, SAVE_FILE :));
   return 1;
}
int remove_effect(object ob) {
   int i;
   for (i = 0; i < sizeof(effect_vols); i+=5)
      if (effect_vols[i] == ob) {
         effect_vols = effect_vols[0..i-1] + effect_vols[i+5..sizeof(effect_vols)];
         break;
      }
   unguarded((: save_object, SAVE_FILE :));
   return 1;
}
string *query_effect_at(int *coord) {
   int i;
   string *obs;
   obs = ({ });
   for (i = 0; i < sizeof(effect_vols); i+=5) {
      if (coord[0] >= effect_vols[i+1] && coord[0] <= effect_vols[i+2] &&
          coord[1] >= effect_vols[i+3] && coord[1] <= effect_vols[i+4])
         obs += ({ effect_vols[i] });
   }
   return obs;
}
mixed *query_attrs_at(int *coord){
   string *effects;
   int sum, i, pass_through;
   mixed *attrs, *temp_attrs;
   effects = query_effect_at(coord);
   if (!sizeof(effects)) return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
   attrs = effects[0]->query_attrs(coord);
   sum = 100;
   pass_through = effects[0]->query_pass_through(coord);
   i = 1;
   while (pass_through && i < sizeof(effects)) {
      if (effects[i]->backdrop()) break;
      temp_attrs = effects[i]->query_attrs(coord);
      attrs = "/obj/container"->merge_potions(attrs, temp_attrs,
                                   sum, pass_through, sum + pass_through);
      sum += pass_through;
      pass_through = effects[i]->query_pass_through(coord);
      i++;
   }
   return attrs;
}
void potion_drunk(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_drunk(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
void potion_touch(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_touch(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
void potion_smell(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_smell(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
void potion_create(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_create(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
mixed *query_effect_vols() {
   return effect_vols + ({ });
}
int *neutral_coordinate() {
   return ({ 0, 0 });
}

==================================================
FILE: handlers/project_management.c
==================================================

#include "project_management.h"
#include <playtesters.h>
#include <permissions.h>
#include <board.h>
#include <mail.h>
#include <cmds/twiki.h>
int query_project_completeness(string);
string* query_project_tasks(string);
int valid_operation (string name, string action, string project);
int find_project (string);
void do_save();
int nuke_creator_project_cache(string*);
string* query_projects_for_creator (string);
int clear_file_cache (string nfile);
void do_mail (string*, string);
int clear_playtesting_projects (string*);
class project* filter_by_query (mapping);
void catch_status_change (string, int);
class file_access_cache {
  string id;
  mapping accesses;
}
string *pt_post_cache = ({ });
class project *projects = ({ });
class project_tmp *tmp_projects = ({ });
int touched;
int last_summary;
mapping summary;
mapping num_assignments;
nosave mapping inform = ([ ]);
nosave mapping creator_project_cache = ([ ]);
nosave mapping pt_assignment_cache = ([ ]);
nosave class file_access_cache *cache = ({ });
nosave string *excluded = ({
  "bfg",
  "dionysus",
  "melian",
});
mapping project_locks = ([ ]);
void save_file() {
  if (find_call_out ("do_save") == -1) {
    call_out ("do_save", 10);
  }
}
void do_log (string text) {
  log_file (PROJECT_LOG, text);
}
void do_save() {
  seteuid ("Root");
  touched = 1;
  unguarded ((: save_object, PROJECT_SAVE :));
  touched = 0;
}
void do_load() {
  unguarded ((: restore_object, PROJECT_SAVE :));
}
void create() {
  string *creators = ({ });
  do_load();
  if (!last_summary) {
    last_summary = time();
  }
  if (!summary) {
    summary = ([ ]);
  }
  if (!tmp_projects) {
    tmp_projects = ({ });
  }
  if (!creator_project_cache) {
    creator_project_cache = ([ ]);
  }
  if (!cache) {
    cache = ({ });
  }
  if (!pt_post_cache) {
    pt_post_cache = ({ });
  }
  if (!num_assignments) {
    num_assignments = ([ ]);
  }
  foreach (class project p in projects) {
    creators += p->creators;
  }
  creators = uniq_array (creators);
  foreach (string c in creators) {
    query_projects_for_creator (c);
  }
}
void touch_project (string id, string reason, string name) {
  int i = find_project (id);
  object ob;
  if (i == -1) {
    return;
  }
  projects[i]->last_touched = time();
  projects[i]->what_touched = reason;
  projects[i]->touched_by = name;
  save_file();
  if (find_call_out ("do_inform") == -1) {
    call_out ("do_inform", 120);
  }
  if (undefinedp (summary[id])) {
    summary[id] = ({ name });
  }
  else {
    summary[id] += ({ name });
  }
  if (undefinedp (inform[id])) {
    inform[id] = ({ name });
  }
  else {
    inform[id] += ({ name });
  }
  foreach (string d in projects[i]->domains) {
    ob = load_object ("/d/" + d + "/master");
    if (ob) {
      ob->nuke_creator_project_cache (projects[i]->creators);
    }
    nuke_creator_project_cache (projects[i]->creators);
  }
  do_log (sprintf ("%s:  Project %s touched by %s:  %s\n",
    ctime (time()), id, name, reason));
}
void do_inform() {
  int i;
  foreach (string id, string *names in inform) {
    i = find_project (id);
    user_event ("inform", sprintf ("%s: Project %s touched by %s",
      query_multiple_short(map (projects[i]->domains, (: capitalize ($1) :))),
      id, query_multiple_short (map (uniq_array (names),
      (: capitalize ($1) :)))), "message", this_player());
  }
  inform = ([ ]);
}
string* query_projects_for_creator (string c) {
  if (!creator_project_cache[c]) {
    creator_project_cache[c] = map (filter_by_query ((["creators": c])),
      (: $1->id :));
  }
  return creator_project_cache[c];
}
string* query_projects_for_creator_in_domain (string creator, string domain) {
  return sort_array (map (filter_by_query ((["creators": creator, "domains" : domain])),
      (: $1->name :)), 1);
}
string query_touched (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!projects[i]->last_touched) {
    return "This project has not been touched since it was added.";
  }
  return sprintf ("%s last touched project %s on %s:  %s.",
    (projects[i]->touched_by ? capitalize (projects[i]->touched_by) :
    "Someone"), id,
    ctime (projects[i]->last_touched), projects[i]->what_touched);
}
mapping query_summary_mapping() {
  return summary;
}
int query_last_summary() {
  return last_summary;
}
string query_summary_page() {
  string ret = "Project changes since " + ctime (last_summary) + "\n\n";
  foreach (string proj, string *names in summary) {
    ret += sprintf ("%-30s touched by %s\n",
      proj, query_multiple_short (uniq_array (names)));
  }
  return ret;
}
int insert_into_projects (mixed temp) {
  int index = 0;
  if (!sizeof (projects)) {
    projects = ({ temp });
    return 0;
  }
  while (index < sizeof (projects) && temp->id > projects[index]->id) {
    index++;
  }
  if (index == sizeof (projects)) {
    projects = projects + ({ temp });
  }
  else if (index == 0) {
    projects = ({ temp }) + projects;
  }
  else {
    projects = projects[0..index-1] + ({ temp }) +
      projects[index..sizeof(projects)];
  }
  return index;
}
int insert_into_cache (mixed temp) {
  int index = 0;
  if (!sizeof (cache)) {
    cache = ({ temp });
    return 0;
  }
  while (index < sizeof (cache) && temp->id > cache[index]->id) {
    index++;
  }
  if (index == sizeof (cache)) {
    cache = cache + ({ temp });
  }
  else if (index == 0) {
    cache = ({ temp }) + cache ;
  }
  else {
    cache = cache[0..index-1] + ({ temp }) +
      cache[index..sizeof(cache)];
  }
  return index;
}
int insert_into_tasks (int i, mixed temp) {
  int index = 0;
  if (!sizeof (projects[i]->tasks)) {
    projects[i]->tasks = ({ temp });
    return 0;
  }
  while (index < sizeof (projects[i]->tasks) &&
    temp->id > projects[i]->tasks[index]->id) {
      index++;
  }
  if (index == sizeof (projects[i]->tasks)) {
    projects[i]->tasks = projects[i]->tasks + ({ temp });
  }
  else if (index == 0) {
    projects[i]->tasks = ({ temp }) + projects[i]->tasks;
  }
  else {
    projects[i]->tasks = projects[i]->tasks[0..index-1] + ({ temp })
      + projects[i]->tasks[index..sizeof(projects[i]->tasks)];
  }
  return index;
}
int insert_into_notes (int i, mixed temp) {
  int index = 0;
  if (!sizeof (projects[i]->notes)) {
    projects[i]->notes = ({ temp });
    return 0;
  }
  while (index < sizeof (projects[i]->notes) &&
    temp->id > projects[i]->notes[index]->id) {
      index++;
  }
  if (index == sizeof (projects[i]->notes)) {
    projects[i]->notes = projects[i]->notes + ({ temp });
  }
  else if (index == 0) {
    projects[i]->notes = ({ temp }) + projects[i]->notes;
  }
  else {
    projects[i]->notes = projects[i]->notes[0..index-1] + ({ temp })
      + projects[i]->notes[index..sizeof(projects[i]->notes)];
  }
  return index;
}
protected int find_index (string id, mixed array) {
  int mid, right, left;
  if (!sizeof (array)) {
    return -1;
  }
  right = sizeof (array);
  mid = (left + right) / 2;
  left = 0;
  do {
    if (array[mid]->id == id) {
      return mid;
    }
    if (id > array[mid]->id) {
      left = mid + 1;
      mid = (left + right) / 2;
    }
    else if (id < array[mid]->id) {
      right = mid;
      mid = (left + right) / 2;
    }
  } while (left < right);
  return -1;
}
string parse_details(class project p) {
  string ret = sprintf ("$I$5=The %s (%s) project belongs to the %s %s and is "
    "in %s, with assigned creators of: %s.\n",
    p->id, p->name, query_multiple_short (p->domains),
    (sizeof (p->domains) == 1 ? "domain" : "domains"), STATUS[p->status],
    query_multiple_short (p->creators));
    ret = replace (ret, ({"$I$5=", "<p>"}));
  return ret;
}
int find_project (string id) {
  int i = find_index (id, projects);
  return i;
}
int find_note(mixed i, string id) {
  int j;
  if (!intp(i)) {
    i = find_project (i);
  }
  j = find_index (id, projects[i]->notes);
  return j;
}
int find_task(mixed i, string id) {
  int j;
  if (!intp(i)) {
    i = find_project (i);
  }
  j = find_index (id, projects[i]->tasks);
  return j;
}
class file* find_file(mixed i, string nfile, string task) {
  int j;
  class file *tmp = ({ });
  if (!intp(i)) {
    i = find_project (i);
  }
  if (!sizeof (projects[i]->files)) {
    return tmp;
  }
  for (j=0; j < sizeof (projects[i]->files); j++) {
    if (projects[i]->files[j]->file == nfile) {
      if (sizeof (task)) {
        if (task == "leader" || projects[i]->files[j]->task == task) {
          tmp += ({ projects[i]->files[j] });
        }
      }
      else if (!sizeof (projects[i]->files[j]->task)) {
          tmp += ({ projects[i]->files[j] });
      }
    }
  }
  return tmp;
}
int find_cache_file (string file) {
  int i = find_index (file, cache);
  return i;
}
int delete_project (string id, string name) {
  int i = find_index (id, projects);
  if (i == -1) {
    return 0;
  }
  projects -= ({ projects[i] });
  do_log (sprintf ("%s:  %s deleted project %s.\n",
    ctime(time()), name, id));
  save_file();
  return 1;
}
int delete_task (string id, string task_id, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks -= ({ projects[i]->tasks[j] });
  touch_project (id, "Deleted task " + task_id, name);
  return 1;
}
int delete_note (string id, string note_id, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_note (i, note_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->notes -= ({ projects[i]->notes[j] });
  touch_project (id, "Deleted note " + note_id, name);
  return 1;
}
int add_project (string id, string nname, string lead, string desc,
  string *dom, string *cre, string add_name, int size, int complexity,
  string *guilds) {
  int i;
  class project tmp;
  if (find_project (id) != -1) {
    return -1;
  }
  tmp = new (class project, id: id, name: nname, leader: lead,
    date_added: time(), added_by: add_name,
    date_completed: 0, status: 0, estimated_completion: 0,
    description: desc, domains: dom, creators: (sizeof (cre) ? cre :
    ({})), playtesters: ({ }), tasks: ({ }),
    files: ({ }), twiki: ({ }), percent_complete: 0, sub_projects: ({ }),
    notes: ({ }), size: size, complexity: complexity, guild_specific :
    guilds);
  i = insert_into_projects (tmp);
  touch_project (id, "Project added", add_name);
  return i;
}
int add_cache_file (string id) {
  int i;
  class file_access_cache tmp;
  if (find_cache_file (id) != -1) {
    return -1;
  }
  tmp = new (class file_access_cache, id: id, accesses: ([ ]));
  i = insert_into_cache (tmp);
  return i;
}
int set_completion_date (string id, int date) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->estimated_completion = date;
}
int add_creator (string id, string creator) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->creators)) {
    projects[i]->creators = ({ creator });
  }
  else if (member_array (creator, projects[i]->creators) == -1) {
    projects[i]->creators += ({ creator });
  }
  return 1;
}
int add_twiki (string id, string twiki) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->twiki)) {
    projects[i]->twiki = ({ twiki });
  }
  else {
    projects[i]->twiki += ({ twiki });
  }
  return 1;
}
string* query_twiki (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return copy (projects[i]->twiki);
}
class file* query_files (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return copy (projects[i]->files);
}
int add_file (string id, string file, int access, string name, string task) {
  int i = find_project (id);
  int k;
  mixed ob;
  class file tmp;
  class file *files = ({ });
  if (i == -1) {
    return 0;
  }
  if (access == GRANT_MASK || access == LOCK_MASK) {
    ob = find_player (name);
    if (!ob) {
      return 0;
    }
  }
  if (!ob) {
    ob = name;
  }
  k = master()->valid_grant (ob, file, access);
  if (!k) {
    log_file ("CHEAT", ctime(time()) + ": " + name + " tried to add "
      "level " + access + " access to file " + file + "\n");
    return 0;
  }
  tmp = new (class file, file: file, access: access, task: task);
  if (!sizeof (projects[i]->files)) {
    projects[i]->files = ({ tmp });
  }
  else {
    files = find_file (i, file, task);
    foreach (class file f in files) {
      if (f->access == access && f->task == task) {
        return 0;
      }
    }
    projects[i]->files += ({ tmp });
  }
  clear_file_cache (file);
  touch_project (id, "Added a file permission", name);
  return 1;
}
int remove_file (string id, string file, string task, string name) {
  int i = find_project (id);
  class file *tmp = ({ });
  if (i == -1) {
    return 0;
  }
  tmp = find_file (i, file, task);
  if (!sizeof (tmp)) {
    return 0;
  }
  foreach (class file f in tmp) {
    if (f->task == task) {
      projects[i]->files -= ({ f });
      break;
    }
  }
  clear_file_cache (file);
  touch_project (id, "Removed a file permission", name);
  return 1;
}
int reset_files (string id) {
  int i = find_project (id);
  projects[i]->files = ({ });
}
int add_domain (string id, string domain) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->domains)) {
    projects[i]->domains = ({ domain });
  }
  else {
    projects[i]->domains += ({ domain });
  }
  return 1;
}
int set_project_leader (string id, string leader) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->leader= leader;
}
string query_project_leader (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->leader;
}
string* query_project_subprojects (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->sub_projects;
}
string* query_projects() {
  return map (projects, (: $1->id :));
}
int set_status (string id, int stat) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (stat >= sizeof (STATUS)) {
    return 0;
  }
  projects[i]->status = stat;
  catch_status_change (id, stat);
}
int query_status (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->status;
}
string query_all_projects_info() {
  string ret = "";
  foreach (class project p in projects) {
    ret += parse_details (p);
  }
  return ret;
}
string* query_project_tasks (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return map (projects[i]->tasks, (: $1->id :));
}
string* query_project_notes (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->notes)) {
    return 0;
  }
  return map (projects[i]->notes, (: $1->id :));
}
string* query_project_domains (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->domains;
}
int set_description (string id, string desc) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->description = desc;
  return 1;
}
string query_description (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->description;
}
int set_status_change(string id, int time) {
  int i = find_project (id);
  if (time) {
    projects[i]->last_status_change = time;
  }
}
string project_info (string id) {
  int i = find_project (id);
  string ret = "";
  if (i == -1) {
    return "There is no project with that ID.\n";
  }
  ret += sprintf ("\n$I$5=Project %s (%s) belongs to the %s %s.\n",
    id, projects[i]->name, query_multiple_short
      (projects[i]->domains), (sizeof(projects[i]->domains) == 1 ?
      "domain" : "domains"));
  if (sizeof (projects[i]->description)) {
    ret += sprintf ("$I$5=Project %s has the following description: \n",
      id, projects[i]->description);
  }
  ret += sprintf ("$I$5=Project %s is %s percent complete.\n",
    id, query_num (query_project_completeness (id)));
  ret += sprintf ("$I$5=Project %s has a project leader of: %s.\n",
    id, projects[i]->leader);
  ret += sprintf ("$I$5=Project %s has the following assigned creators:  %s.\n",
    id, query_multiple_short (projects[i]->creators));
  ret += sprintf ("$I$5=Project %s is currently: in %s.\n",
    id, STATUS[projects[i]->status]);
  ret += sprintf ("$I$5=Project %s was added at: %s by %s.\n",
    id, ctime (projects[i]->date_added), projects[i]->added_by);
  if (sizeof (projects[i]->twiki)) {
    ret += sprintf ("$I$5=Project %s has the following twiki pages: %s.\n",
      id, query_multiple_short (projects[i]->twiki));
  }
  if (sizeof (projects[i]->tasks)) {
    ret += sprintf ("$I$5=Project %s has the following tasks: %s.\n",
      id, query_multiple_short (query_project_tasks (id)));
  }
  if (projects[i]->estimated_completion) {
    ret += sprintf ("$I$5=Project %s will be completed by the estimated date "
      "of: %s.\n", id, ctime (projects[i]->estimated_completion));
  }
    ret = replace (ret, ({"$I$5=", "<p>"}));
  return ret;
}
string task_info (string id, string task_id) {
  int i = find_project (id);
  int j;
  string ret = "";
  if (i == -1) {
    return "There is no project with that ID.\n";
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return "There is no task with that ID for project " + id + ".\n";
  }
  ret += sprintf ("Project %s:  task %s.\n", id, task_id);
  ret += sprintf ("task %s is %s percent complete.\n",
    task_id, query_num (projects[i]->tasks[j]->percent_complete));
  ret += sprintf ("task %s has the following assigned creators:  %s.\n",
    query_multiple_short (projects[i]->tasks[j]->assigned_to));
  return ret;
}
int set_project_completeness (string id, int percent) {
  int i = find_project (id);
  if (i == -1) {
    return -1;
  }
  projects[i]->percent_complete = percent;
}
int set_project_name (string id, string name) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->name = name;
}
string query_project_name (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->name;
}
int query_project_completeness (string id) {
  int i = find_project(id);
  int percent = 0;
  int counter = 0;
  string p;
  if (i == -1) {
    return 0;
  }
  if (projects[i]->percent_complete) {
    return projects[i]->percent_complete;
  }
  if (!sizeof (projects[i]->tasks)) {
    return 0;
  }
  if (sizeof (projects[i]->sub_projects)) {
    foreach (p in projects[i]->sub_projects) {
      if (p == id) {
        continue;
      }
      percent += query_project_completeness (p);
      counter++;
    }
  }
  foreach (class task bing in projects[i]->tasks) {
      if (!intp (bing->percent_complete)) {
        bing->percent_complete = to_int (bing->percent_complete);
      }
      percent += bing->percent_complete;
      counter++;
  }
  return percent / counter;
}
int update_project_task_completeness (string id, string task, int percent) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return -1;
  }
  j = find_task (i, task);
  if (j == -1) {
    return -1;
  }
  projects[i]->tasks[j]->percent_complete = percent;
}
int assign_project_task_creator (string id, string task, string creator) {
  int i = find_project (id);
  int j;
  string *cres;
  if (i == -1) {
    return -1;
  }
  j = find_task (i, task);
  if (j == -1) {
    return -1;
  }
  cres = projects[i]->tasks[j]->assigned_to;
  if (!sizeof (cres)) {
    cres = ({ creator });
  }
  else {
    cres += ({ creator });
  }
  projects[i]->tasks[j]->assigned_to = cres;
  if (member_array (creator, projects[i]->creators) == -1) {
    add_creator (id, creator);
  }
  return 1;
}
int add_task_to_project (string id, string task_id, string name, string aim) {
  int i = find_project (id);
  int j;
  class task tmp;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j != -1) {
    return 0;
  }
  tmp = new (class task, id: task_id, added_by: name,
    date_added: time(), aims: aim);
  touch_project (id, "Added task " + task_id, name);
  return insert_into_tasks (i, tmp);
}
int add_note_to_project (string id, string note_id, string note, string name) {
  int i = find_project (id);
  int j;
  class note tmp;
  if (i == -1) {
    return 0;
  }
  j = find_note (i, note_id);
  if (j != -1) {
    return 0;
  }
  tmp = new (class note, id: note_id, note: note, added_by: name,
    date_added: time());
  touch_project (id, "Added note " + note_id, name);
  return insert_into_notes (i, tmp);
}
int set_task_name (string id, string task_id, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->task_name = name;
  return 1;
}
int set_task_aims (string id, string task_id, string aims) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->aims = aims;
  return 1;
}
string query_task_aims (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->aims;
  }
string query_task_name (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->task_name;
}
class task* project_task_data (string id) {
  int i = find_project (id);
  if (i == -1) {
    return ({ });
  }
  return projects[i]->tasks;
}
class note* project_note_data (string id) {
  int i = find_project (id);
  if (i == -1) {
    return ({ });
  }
  return projects[i]->notes;
}
int set_task_comments (string id, string task_id, string comments) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->comments = comments;
  return 1;
}
string query_task_comments (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->comments;
}
int add_task_creator (string id, string task_id, string creator) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->tasks[j]->assigned_to)) {
    projects[i]->tasks[j]->assigned_to= ({ creator });
  }
  else {
    projects[i]->tasks[j]->assigned_to+= ({ creator });
  }
  return 1;
}
string* query_task_creators (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->assigned_to;
}
int set_task_completion (string id, string task_id, int percent) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->percent_complete = percent;
  return 1;
}
int query_task_competion (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->percent_complete;
}
int set_task_completion_date(string id, string task_id, int date) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->completion_date = date;
  return 1;
}
int query_task_completion_date (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->completion_date;
}
class project* filter_by_query (mapping query) {
  string tmp_str, *tmp_arr;
  int match, unassigned = 0;
  class project *tmp = ({ });
  string *un = ({"unassigned", "none", "no-one", "noone", "nobody"});
  if (member_array (query["creators"], un) != -1) {
    unassigned = 1;
  }
  foreach (class project p in projects) {
    match = 0;
    tmp_str = query ["projid"];
    if (sizeof (tmp_str)) {
      if (p->id == query["projid"]) {
        match = 1;
      }
      else {
        continue;
      }
    }
    tmp_str = query ["domains"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (map (tmp_arr, (: lower_case ($1) :))
        & map (p->domains, (: lower_case ($1) :))) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    tmp_str = query["creators"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (map (tmp_arr, (: lower_case ($1) :))
        & map (p->creators, (: lower_case ($1) :))) == sizeof (tmp_arr)) {
        match = 1;
      }
      else if (unassigned && !sizeof (p->creators)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (sizeof (query["status"])) {
      if (query["status"] == "all") {
        match = 1;
      }
      else if (p->status == member_array (query["status"], STATUS)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (sizeof (query["leader"])) {
      if (lower_case (p->leader) == lower_case (query["leader"])) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (query["touched"]) {
      if (p->last_touched > time() - query["touched"] ) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (query["completeness"]) {
      if (query_project_completeness (p->id)
        >= to_int (query["completeness"])) {
        match = 1;
      }
      else {
        continue;
      }
    }
    tmp_str = query["playtesters"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (tmp_arr & p->playtesters) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (match) {
      tmp += ({ p });
    }
  }
  return tmp;
}
class task* filter_tasks_by_query (string id, mapping query) {
  string tmp_str, *tmp_arr;
  int match, i, j;
  class task *tmp = ({ });
  i = find_project (id);
  if (i == -1) {
    return 0;
  }
  foreach (class task p in projects[i]->tasks) {
    match = 0;
    tmp_str = query["creators"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (tmp_arr & p->assigned_to) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (sizeof (query["completed"])) {
      j = to_int (query["completed"]);
      if (p->percent_complete > j) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (match) {
      tmp += ({ p });
    }
  }
  return tmp;
}
class project get_project_file (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i];
}
void set_project_file (string id, class project tmp, string name) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i] = tmp;
  touch_project (id, "Updated project file", name);
  catch_status_change (id, tmp->status);
}
class project* data_dump() {
  mapping dom_proj = ([ ]);
  string d;
  class project *tmp = ({ });
  string *dom;
  foreach (class project p in projects) {
    foreach (d in p->domains) {
      if (undefinedp (dom_proj [d])) {
        dom_proj [d] = ({ p });
      }
      else {
        dom_proj [d] += ({ p });
      }
    }
  }
  dom = sort_array (keys (dom_proj), 1);
  foreach (d in dom) {
    tmp += dom_proj[d];
  }
  return uniq_array (tmp);
}
class task get_task_file (string id, string t) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, t);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j];
}
void set_task_file (string id, string t, class task tmp, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, t);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j] = tmp;
  touch_project (id, "Updated task " + t, name);
}
class note get_note_file (string id, string t) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_note (i, t);
  if (j == -1) {
    return 0;
  }
  return projects[i]->notes[j];
}
void set_note_file (string id, string t, class note tmp, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_note(i, t);
  if (j == -1) {
    return 0;
  }
  projects[i]->notes[j] = tmp;
  touch_project (id, "Updated note " + t, name);
}
int is_creator_on_project (string name, string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (member_array ("all", projects[i]->creators) != -1) {
    return 1;
  }
  if (member_array (name, projects[i]->creators) != -1) {
    return 1;
  }
  return 0;
}
varargs int valid_operation (string name, string action, string project,
  string* dom) {
  object ob;
  string *domains;
  int i = find_project (project);
  int j;
  if (master()->high_programmer (name)) {
    return 1;
  }
  if (name == "drakkos") {
    return 1;
  }
  if (i != -1) {
    domains = query_project_domains (project);
  }
  else if (dom) {
    domains = dom;
  }
  if (is_creator_on_project (name, project)) {
    return 1;
  }
  if (action == PLAYTESTING) {
    ob = find_object ("/d/playtesting/master");
    if (ob->query_lord() == name) {
      return 1;
    }
    if (ob->query_deputy (name)) {
      return 1;
    }
  }
  if (!sizeof (domains)) {
    return 0;
  }
  foreach (string d in domains) {
    ob = find_object ("/d/" + d + "/master");
    if (function_exists (CALLBACK, ob)) {
      j = call_other (ob, CALLBACK, name, action, project);
      if (j != -1) {
        return j;
      }
    }
    if (ob->query_lord() == name) {
      return 1;
    }
    if (ob->query_deputy (name) && action != PLAYTESTING) {
      return 1;
    }
  }
  if (action == PROJECT) {
    return 1;
    return sizeof (filter (domains, (:
      find_object ("/d/" + $1 + "/master")->query_member ($(name)) :)));
  }
  if (action == TASK || action == NOTE) {
    return is_creator_on_project (name, project);
  }
  return 0;
}
void catch_status_change (string id, int status) {
  object ob;
  int i = find_project (id);
  foreach (string d in projects[i]->domains) {
    ob = load_object ("/d/" + d + "/master");
    if (!ob) {
      continue;
    }
    if (function_exists ("project_status_change", ob)) {
      ob->project_status_change (id, status);
    }
  }
  if (status == member_array ("play", STATUS)) {
    WHATWHAT->add_project (projects[i]->name, projects[i]->domains,
      projects[i]->creators, projects[i]->description, "play");
  }
  if (status != member_array ("playtesting", STATUS)) {
    clear_playtesting_projects (projects[i]->playtesters);
    projects[i]->playtesters = ({ });
    save_file();
  }
  projects[i]->last_status_change = time();
}
int assign_playtesters (string id, string *pt, string name) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  pt = map(pt, (: lower_case ($1) :));
  pt = filter (pt, (: PLAYTESTER_HAND->query_playtester ($1) :));
  projects[i]->playtesters = pt;
  save_file();
  foreach (string p in pt) {
    if (pt_assignment_cache [p]) {
      map_delete (pt_assignment_cache, p);
    }
  }
  return 1;
}
string* add_playtester (string id, string *pt) {
  int i = find_project (id);
  string *names;
  if (i == -1) {
    return 0;
  }
  pt = map(pt, (: lower_case ($1) :));
  pt = filter (pt, (: PLAYTESTER_HAND->query_playtester ($1) :));
  names = projects[i]->playtesters;
  projects[i]->playtesters = uniq_array (names += pt);
  clear_playtesting_projects (pt);
  save_file();
  do_mail (pt, projects[i]->id);
  return pt;
}
int remove_playtester (string id, string *pt) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  pt = map(pt, (: lower_case ($1) :));
  projects[i]->playtesters -= pt;
  clear_playtesting_projects (pt);
  save_file();
  return 1;
}
void do_load_tmp() {
  unguarded ((: restore_object, TMP_SAVE :));
}
void do_setup() {
  projects = ({ });
  foreach (class project p in tmp_projects) {
    projects += ({ p });
  }
  tmp_projects = ({ });
  do_save();
}
int clear_file_cache (string nfile) {
  int i = find_cache_file (nfile);
  if (i == -1) {
    return 0;
  }
  cache -= ({ cache[i] });
  return 1;
}
int query_permission (string project, string name, string nfile, int access) {
  int i = find_project (project);
  int j;
  string *tasks = ({ });
  class file *tmp = ({ });
  if (i == -1) {
    return 0;
  }
  if (projects[i]->leader != name &&
    member_array (name, projects[i]->creators) == -1) {
    return 0;
  }
  if (projects[i]->leader == name) {
    tasks = map (projects[i]->tasks, (: $1->id :));
    tasks += ({"leader"});
  }
  else {
    tasks = map (filter (projects[i]->tasks, (: member_array ($(name),
      $1->assigned_to) != -1 :)), (: $1->id :));
  }
  tasks += ({""});
  foreach (string t in tasks) {
    tmp += find_file (i, nfile, t);
  }
  if (!sizeof (tmp)) {
    return 0;
  }
  tmp = uniq_array (tmp);
  foreach (class file f in tmp) {
    j = find_cache_file (f->file);
    if (j == -1) {
      j = add_cache_file (f->file);
    }
    if (!sizeof (f->task)) {
      if (f->access == access) {
        if (cache[j]->accesses[name] < access) {
          cache[j]->accesses[name] = access;
        }
        return 1;
      }
    }
    else if (member_array (f->task, tasks) != -1) {
        if (f->access == access) {
          if (cache[j]->accesses[name] < access) {
            cache[j]->accesses[name] = access;
          }
          return 1;
        }
    }
  }
  return 0;
}
int nuke_creator_project_cache(string *creators) {
  if (!creator_project_cache) {
    return 0;
  }
  foreach (string c in creators) {
    map_delete (creator_project_cache, c);
    return 1;
  }
}
int query_file_permission (string name, string nfile, int access) {
  string *a_projects = query_projects_for_creator (name);
  int i, j, k, l = 0;
  if (!sizeof (a_projects)) {
    return 0;
  }
  j = find_cache_file (nfile);
  if (j != -1 ) {
    k = cache[j]->accesses[name];
    if (k == -1) {
      return 0;
    }
    if (k >= access) {
      return 1;
    }
  }
  foreach (string p in a_projects) {
    i = query_permission (p, name, nfile, access);
    if (!l && i) {
      l = 1;
    }
  }
  return l;
}
void set_project_lock (string project) {
  project_locks[project] = time();
}
int query_project_lock (string project) {
  if (project_locks[project] + PROJECT_LOCK > time()) {
    return 1;
  }
  map_delete (project_locks, project);
  return 0;
}
string generate_pt_report() {
  string *new_cache = ({ });
  string missing_projects = "";
  string ret = "";
  string *det = ({ });
  string project_list = "";
  string tmp;
  string post = "";
  int i;
  class project *in_pt = ({ });
  class project *out_pt = ({ });
  class project *new_pt = ({ });
  string *del = ({ });
  class project *playtesting = filter_by_query ((["status": "playtesting"]));
  foreach (class project p in playtesting) {
      new_cache += ({ p->id });
      if (member_array (p->id, pt_post_cache) == -1) {
        new_pt += ({ p });
      }
      else {
        in_pt += ({ p });
      }
    }
  if (sizeof (pt_post_cache)) {
    foreach (string id in pt_post_cache) {
      if (member_array (id, new_cache) == -1) {
        i = find_project (id);
        if (i == -1) {
          del += ({ id });
        }
        else {
          out_pt += ({ projects[i] });
        }
      }
    }
  }
  if (sizeof (new_pt)) {
    ret += "The following projects have entered playtesting:\n\n";
    foreach (class project p in new_pt) {
      det = ({ });
      det += ({sprintf ("*  %s (%s): %s.\n   Description: %s\n   "
        "Project leader: %s.\n   "
        "Creators: %s.\n   Notes: %s.\n", p->id, p->name,
          query_multiple_short (p->domains), (p->description ? replace
            (p->description, ({"\n", ""})) :
          "None"), (p->leader ? p->leader :
          "No-one"), (p->creators ? query_multiple_short (p->creators) :
          "None"), (sizeof (p->pt_notes) ? replace (p->pt_notes,
          ({"\n", ""})) : "None")) });
      ret += implode (det, "\n\n");
    }
    ret += "\n\n";
  }
  if (sizeof (in_pt)) {
    ret += "The following projects are still in playtesting:\n\n";
    det = ({ });
    foreach (class project p in in_pt) {
      det += ({sprintf ("*  %s (%s): %s.", p->id, p->name,
        query_multiple_short (p->domains)) });
    }
    ret += implode (det, "\n");
    ret += "\n\n";
  }
  if (sizeof (out_pt)) {
    det = ({ });
    ret += "The following projects have been removed from playtesting:\n\n";
    foreach (class project p in out_pt) {
      det += ({sprintf ("*  %s (%s): %s.", p->id, p->name,
        STATUS[p->status]) });
    }
    ret += implode (det, "\n\n");
    ret += "\n\n";
  }
  if (sizeof (del)) {
    ret += "The following projects have been deleted from the handler:\n\n";
    foreach (string d in del) {
      det += ({sprintf ("*  %s.", d) });
    }
    ret += implode (det, "\n\n");
    ret += "\n\n";
  }
  pt_post_cache = new_cache;
  if (!sizeof (ret)) {
    ret= "Wow, absolutely nothing is officially in playtesting at the "
      "moment.  You can all have the week off.\n\n";
  }
  else {
    ret += "Remember that you can use the 'playtesting' command for more "
      "information on projects that are currently in playtesting.\n\n";
  }
  return ret;
}
int make_post() {
  int ret;
  ret = BOARD_HAND->add_message("ptforum",
         "The Project Tracker", "What's in Playtesting?",
         generate_pt_report() +
         TWIKI_HANDLER->find_changes_in_database("Playtesters", last_summary));
  last_summary = time();
  save_file();
}
string* query_pt_cache() {
  return pt_post_cache;
}
string* query_pt_projects (string name) {
  class project *tmp;
  if (!undefinedp (pt_assignment_cache [name])) {
    return pt_assignment_cache [name];
  }
  tmp = filter_by_query ((["playtesters" : name ]));
  if (!tmp) {
    pt_assignment_cache[name] = ({ });
  }
  else {
    pt_assignment_cache[name] = map (tmp, (: $1->id :));
  }
  return pt_assignment_cache[name];
}
int query_number_of_pts (mixed proj) {
  int i;
  int t;
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  if (i == -1) {
    return -1;
  }
  switch (projects[i]->size) {
    case 0:
      t = 2;
    break;
    case 1:
      t = 3;
    break;
    case 2:
      t = 4;
    break;
    case 3:
      t = 5;
    break;
    case 4:
      t = 6;
    break;
    case 5:
      t = 8;
    break;
    case 6:
      t = 0;
    break;
    default:
      t = 2;
    break;
  }
  return t;
}
int next_rotation_time(mixed proj) {
  int i, t;
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  if (i == -1) {
    return -1;
  }
  if (projects[i]->complexity == member_array ("special", COMPLEXITY)) {
    return 0;
  }
  switch (projects[i]->size) {
    case 0:
      t = WEEK;
    break;
    case 1:
      t = WEEK * 2;
    break;
    case 2:
      t = WEEK * 2;
    break;
    case 3:
      t = WEEK * 4;
    break;
    case 4:
      t = WEEK * 4;
    break;
    case 5:
      t = WEEK * 6;
    break;
    case 6:
      t = WEEK * 6;
    default:
      t = WEEK;
  }
  if (!projects[i]->current_rotation) {
    projects[i]->last_rotation = time();
    projects[i]->current_rotation = 1;
    save_file();
  }
  return projects[i]->last_rotation + t;
}
int query_time_to_rotate (mixed proj) {
  int i;
  i = next_rotation_time(proj);
  if (i < time()) {
    return 1;
  }
  else {
    return 0;
  }
}
int query_number_rotations(mixed proj) {
  int i ;
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  if (i == -1) {
    return -1;
  }
  if (projects[i]->complexity == member_array ("special", COMPLEXITY)) {
    return projects[i]->current_rotation + 1;
  }
  return projects[i]->complexity + 2;
}
int query_rotation (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->current_rotation;
}
string* query_playtesters (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->playtesters;
}
int set_complexity (mixed proj, int com) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  projects[i]->complexity = com;
  return 1;
}
int set_size(mixed proj, int siz) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  projects[i]->size = siz;
  return 1;
}
int query_size(mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->size;
}
int set_guild_specific (mixed proj, string *guilds) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  projects[i]->guild_specific = guilds;
  return 1;
}
string *query_guild_specific(mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->guild_specific;
}
int clear_playtesting_projects (string *names) {
  foreach (string v in names) {
    if (pt_assignment_cache[v]) {
      map_delete (pt_assignment_cache, v);
    }
    if (!num_assignments[v]) {
      num_assignments[v] = 1;
    }
    else {
      num_assignments[v] += 1;
    }
  }
  save_file();
}
class project* get_playtesting_projects () {
  class project *tmp;
  tmp = filter_by_query ((["status": "playtesting"]));
  return tmp;
}
void set_rotations (string proj, int rot) {
  int i = find_project (proj);
  if (i == -1) {
    return;
  }
  projects[i]->current_rotation = rot;
}
string* assign_pts_to_project (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  int needed, tmp;
  int min = sizeof (projects) + 1, max = -1;
  mapping guilds;
  mapping tmp_assign_cache = ([ ]);
  string tpt;
  string *valid = ({ });
  string *selected = ({ });
  string *virgins = ({ });
  string *ordered = ({ });
  string *last = ({ });
  string *nvalid = ({ });
  string *unassigned = ({ });
  string *assigned = ({ });
  if (i == -1) {
    return 0;
  }
  if (projects[i]->size != member_array ("special", SIZE)) {
    needed = query_number_of_pts (proj);
  }
  else {
    return ({ });
  }
  if (sizeof (projects[i]->guild_specific)) {
    guilds = PLAYTESTER_HAND->query_guilds();
    foreach (string g in projects[i]->guild_specific) {
      foreach (string name, string gu in guilds) {
        if (load_object (gu)->query_name() == g) {
          valid += ({ name });
        }
      }
    }
  }
  else {
    valid = PLAYTESTER_HAND->query_playtesters();
  }
  foreach (string v in valid) {
    if (!sizeof (query_pt_projects (v))) {
      unassigned += ({ v });
    }
    else {
      assigned += ({ v });
    }
  }
  if (sizeof (unassigned) >= needed) {
    valid = unassigned;
  }
  else {
    valid = unassigned;
    while (sizeof (valid) < needed) {
      tmp = random (sizeof (assigned));
      valid += ({ assigned[tmp] });
      assigned -= ({ assigned[tmp] });
    }
  }
  foreach (string va in valid) {
    if (member_array (lower_case (va), excluded) != -1) {
      nvalid += ({ va });
    }
    if (PLAYTESTER_HAND->query_leave (va)) {
      nvalid += ({ va });
    }
  }
  valid -= nvalid;
  virgins = valid - (projects[i]->last_pt_cohort ? projects[i]->last_pt_cohort : ({ }));
  if (sizeof (projects[i]->last_pt_cohort)) {
    clear_playtesting_projects (projects[i]->last_pt_cohort);
  }
  last = projects[i]->last_pt_cohort;
  projects[i]->last_pt_cohort = ({ });
  projects[i]->last_rotation = time();
  foreach (string v in valid) {
    tmp_assign_cache[v] = sizeof (query_pt_projects (v)) + num_assignments[v];
  }
  foreach (string pt, int val in tmp_assign_cache) {
    if (val < min) {
      min = val;
    }
    if (val > max) {
      max = val;
    }
  }
  for (int v = min; v <= max; v++) {
    ordered = ({ });
    foreach (string pt, int val in tmp_assign_cache) {
      if (val == v) {
        ordered += ({ pt });
      }
    }
    if ((sizeof (selected) + sizeof (ordered))  >= needed) {
      do {
        tpt = ordered[random(sizeof(ordered))];
        selected += ({ tpt });
        ordered-= ({ tpt });
      } while (sizeof (selected) < needed);
      projects[i]->playtesters = selected;
      save_file();
      if (!last) {
        last = ({ });
      }
      clear_playtesting_projects ((selected ? selected : ({ })) + (last? last : ({ })));
      do_mail (selected, projects[i]->id);
      return selected;
    }
    else {
      selected += ordered;
    }
  }
  valid = uniq_array (valid);
  projects[i]->last_pt_cohort = projects[i]->playtesters;
  if (sizeof (projects[i]->playtesters)) {
    if (sizeof (projects[i]->all_pts)) {
      projects[i]->all_pts += ({ projects[i]->playtesters });
    }
    else {
      projects[i]->all_pts = ({ projects[i]->playtesters });
    }
  }
  projects[i]->playtesters = selected;
  clear_playtesting_projects ((selected ? selected : ({ })) + (last? last : ({ })));
  do_mail (selected, projects[i]->id);
  save_file();
  return selected;
}
void rotate_project (mixed tmp) {
  int i;
  if (intp (tmp)) {
    i = tmp;
  }
  else {
    i = find_project (tmp);
  }
  if (projects[i]->current_rotation == query_number_rotations (i)) {
    AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate",
      "Your project in playtesting", projects[i]->leader,
      "Bing!\n\nThe project " + projects[i]->id + " has reached the end of "
      "its automatic playtesting lifetime and has been put back into a state "
      "of limbo.  If you wish for the project to continue in playtesting, then "
      "please set the project back into playtesting and give Drakkos a nudge!\n\n"
      "Thx bye,\nThe Playtester Wheel Of Fate.\n", 0, 0, 1 );
    AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate",
      "Your project in playtesting", implode (projects[i]->playtesters, ","),
      "Bing!\n\nThe project " + projects[i]->id + " has reached the end of "
      "its automatic playtesting lifetime and has been put back into a state "
      "of limbo.  Thank you for your work on the last stage of its current "
      "playtesting phase.\n\n"
      "Thx bye,\nThe Playtester Wheel Of Fate.\n", 0, 0, 1 );
    set_status(projects[i]->id, 4);
    projects[i]->current_rotation = 0;
    return;
  }
  projects[i]->current_rotation = projects[i]->current_rotation+1;
  projects[i]->last_rotation = time();
  assign_pts_to_project(i);
}
void reset() {
  if (!last_summary) {
    last_summary = time();
  }
  if ((last_summary + TIME_BETWEEN_POSTINGS) < time()) {
    make_post();
  }
  for (int i = 0; i < sizeof (projects); i++) {
    if (projects[i]->status != member_array ("playtesting", STATUS)) {
      continue;
    }
    if (query_time_to_rotate (i)) {
      rotate_project (i);
    }
  }
}
void do_mail (string *playtesters, mixed proj) {
  string text = "Hello!\n\nYou have been assigned to project " +
    proj + " on its latest rotation.  You can use "
    "'playtesting details " + proj + " to find out more about "
    "the project if neccessary.\n\nRegards,\nThe Playtester Wheel "
    "Of Fate.\n";
  AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate",
    "Your new playtester assignment", implode (playtesters, ","),
    text, 0, 0, 1 );
}
void clear() {
  string *names;
  for (int i = 0; i < sizeof (projects); i++) {
    projects[i]->all_pts = ({ });
    projects[i]->last_pt_cohort = ({ });
    projects[i]->playtesters = ({ });
  }
  names = PLAYTESTER_HAND->query_playtesters();
  clear_playtesting_projects (names);
  save_file();
}
void test_num() {
  printf ("%O\n", pt_assignment_cache);
}

==================================================
FILE: handlers/property_tracker.c
==================================================

#include <login.h>
#define CACHE_PROPERTY "property_tracker"
nosave inherit "/std/object";
void save_file();
private string *_invalid_properties;
private mapping _property_funcs;
void create() {
    ::create();
    seteuid( "Root" );
    set_name( "tracker" );
    set_short( "property tracker" );
    unguarded( (: restore_object, "/save/property_tracker.o" :) );
    if ( !_invalid_properties ) {
        _invalid_properties = ({ "team", "ctf_deaths", "ctf_shared",
            "ctf_solo",
            "completed feather quest", "ChapelGapp",
            "scythe sharpness", "DJ to ephebe",
            "emote", "quiting frog", "woeshipper",
            "arresting", "Junior's friend", "donetd",
            "Sek_gem", "looky thingy", "riddle_master",
            "help shopkeeper" });
        _property_funcs = ([ ]);
        save_file();
    }
}
public void check_properties(mixed person, string type) {
    string property;
    mixed data;
    int result;
    int diff;
    if (type != LOGIN)
        return;
    if ( !objectp(person) && !( person = find_player( person ) ) ) {
        return;
    }
#ifdef CACHE_TIME
    diff = CACHE_TIME;
#else
    diff = 1;
#endif
    if ( time() > person->query_property( CACHE_PROPERTY ) + diff ) {
#ifdef DEBUG
        tell_creator( "taffyd", "Scanning %s (%O) for properties.\n",
            person->query_name(), person );
#endif
        foreach( property, data in person->query_properties() ) {
            if ( member_array( property, _invalid_properties ) > -1 ) {
#ifdef DEBUG
                tell_creator( "taffyd", "Checking to property %s.\n",
                    property );
#endif
                if ( _property_funcs[ property ] ) {
                    result = call_other( _property_funcs[ property ][ 1 ],
                        _property_funcs[ property ][ 0 ], property, person,
                        data );
                    if ( result ) {
                        continue;
                    }
                }
#ifdef DEBUG
                tell_creator( "taffyd", "Removing property %s.\n",
                    property );
#endif
                person->remove_property( property );
            }
        }
#ifdef CACHE_TIME
        person->add_property( CACHE_PROPERTY, time() );
#else
        person->remove_property( CACHE_PROPERTY );
#endif
    }
    person->add_skill_level( "other.language.common.spoken", -person->query_skill( "other.language.common.spoken" ) );
    person->add_skill_level( "other.language.common.written", -person->query_skill( "other.language.common.written" ) );
}
public string query_invalid_properties() {
    return copy( _invalid_properties );
}
varargs public int add_invalid_property( string property, mixed func, mixed obj ) {
#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    if ( member_array( property, _invalid_properties ) == -1 ) {
        if ( objectp( func ) ) {
            func = file_name( func );
        }
        if ( objectp( obj ) ) {
            obj = file_name( obj );
        }
        if ( func && obj ) {
            _property_funcs[ property ] = ({ func, obj });
        }
        _invalid_properties += ({ property });
        save_file();
        return 1;
    }
    return 0;
}
int remove_invalid_property( string property ) {
#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    if ( _property_funcs[ property ] ) {
        map_delete( _property_funcs, property );
    }
    _invalid_properties -= ({ property });
    save_file();
    return 1;
}
void save_file() {
    unguarded( (: save_object, "/save/property_tracker" :) );
}
void reset_data() {
    unguarded( (: rm, "/save/property_tracker.o" :) );
}
void convert_no_score( string property, object who, mixed data ) {
    if ( property != "no_score" )
        return;
    if ( data ) {
        who->remove_property( property );
        who->add_property( "no score", 1 );
    }
}
int remove_warmth( string property, object who, mixed data ) {
    if ( property != "warmth" ) {
        return 1;
    }
    if ( !who->query_property_time_left( property ) ) {
        who->remove_property( property );
        return 1;
    }
    return 1;
}

==================================================
FILE: handlers/quest_handler.c
==================================================

#include <library.h>
#include <player_handler.h>
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}

==================================================
FILE: handlers/random_names.c
==================================================

#include <random_names.h>
#include <player_handler.h>
private mapping rules;
private string* _test_rules;
void create() {
   seteuid("Room");
   rules = ([ ]);
   _test_rules = ({ });
   unguarded((: restore_object, RANDOM_NAME_SAVE_FILE :));
   if (!_test_rules) {
      _test_rules = ({ });
   }
}
private void save_me() {
   unguarded((: save_object, RANDOM_NAME_SAVE_FILE :));
}
void open_file(string f) {
   string str, *bits, *stuff, lang;
   int i;
   bits = explode(f, ".");
   if (sizeof(bits) > 1) {
      lang = implode(bits[0..sizeof(bits)-2], ".");
   } else {
      lang = f;
   }
   lang = replace(lang, "_", " ");
   str = unguarded((: read_file, RANDOM_NAME_DATA_DIR+f :));
   bits = explode(str, "\n");
   rules[lang] = ([ ]);
   for (i=0;i<sizeof(bits);i++) {
      sscanf(bits[i], "%s#%*s", bits[i]);
      if (strlen(bits[i])) {
         stuff = explode("G"+bits[i], ":");
         if (sizeof(stuff) >= 3) {
            rules[lang][stuff[1]] = stuff[2];
         } else {
            write("Incorrect file format at line "+i+", less than 3 "
                  ": seporated bits.\n");
         }
      }
   }
   save_me();
}
string random_name(string lang) {
   string word = "W", *bing;
   int some_caps = 1, i;
   do {
      some_caps = 0;
      for (i = 0; i < strlen(word); i++)
         if (word[i] >= 'A' && word[i] <= 'Z') {
            bing = explode(rules[lang][word[i..i]], " ") - ({ "" });
            word = word[0..i-1] + bing[random(sizeof(bing))] + word[i+1..];
            some_caps = 1;
         }
   } while (some_caps);
   return word;
}
string *query_languages() { return keys(rules) - _test_rules; }
string *query_test_languages() {
   return _test_rules;
}
void add_test_language(string lang) {
   _test_rules += ({ lang });
   save_me();
}
void remove_test_language(string lang) {
   _test_rules -= ({ lang });
   save_me();
}
string unique_name(string lang) {
   string str;
   int ok;
   do {
      ok = 1;
      str = random_name(lang);
      if (strlen(str) < 2 || strlen(str) > 11)
         ok = 0;
      if (ok && PLAYER_HANDLER->test_user(str))
         ok = 0;
      if (ok && !PLAYER_HANDLER->test_valid(str))
         ok = 0;
      if (ok && find_living(str))
         ok = 0;
   } while (!ok);
   return str;
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/random_num.c
==================================================

int seed = 100;
varargs int random(int max, mixed lseed);
#define Q           51924
#define R           10855
#define MULT        41358
#define MOD   21474836647
#define MAX_VALUE (MOD-1)
#define STARTUP_RANDS  16
void set_seed(int new_seed) {
  int i;
  if (seed <= 0)
    seed = efun::random(200);
  else
    seed = new_seed;
  for (i=0;i<STARTUP_RANDS;i++)
    random(200);
}
varargs int random(int max, mixed lseed) {
  int k, residue, curseed, mode;
  if (undefinedp(lseed)) {
    curseed = seed;
  } else if (intp(lseed)) {
    curseed = lseed;
    mode = 1;
  } else if (arrayp(lseed) && (sizeof(lseed) == 1) && (intp(lseed[0]))) {
    curseed = lseed[0];
    mode = 2;
  } else {
    curseed = seed;
  }
  k = curseed / Q;
  residue = MULT * (curseed - Q*R) - R*k;
  if (residue < 0)
    residue += MOD;
  if (mode == 0) {
    seed = residue;
  } else if (mode == 2) {
    lseed[0] = residue;
  }
  return residue % max;
}
int query_seed() {
  return seed;
}

==================================================
FILE: handlers/reaction.c
==================================================

#include <move_failures.h>
#include <reaction.h>
#define REACTIONS "/obj/reactions/"
#define SUBSTANCES 10
mapping substance = allocate_mapping(SUBSTANCES);
int debug_rh = 0;
void restore_from_files();
void write_dbg(string str) { if (debug_rh) write(str); }
void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    restore_from_files();
}
mapping merge_effects(mapping effects_a, mapping effects_m, int q_a, int q_m) {
    int q_t, strength;
    string key;
    mapping ret = ([ ]);
    if(!mapp(effects_a) || !mapp(effects_m))
      return 0;
    q_t = q_a + q_m;
    if ( !q_t ) {
        return 0;
    }
    foreach (key in keys(effects_a)) {
        if (!intp(effects_a[key]) || !intp(effects_m[key])) {
            continue;
        }
        if (undefinedp(effects_m[key])) {
            strength = (effects_a[key]*q_a)/q_t;
        } else {
            strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
                - effects_m[key];
            map_delete(effects_m, key);
        }
        ret += ([key: strength]);
    }
    foreach (key in keys(effects_m)) {
        if (!intp(effects_m[key])) {
            continue;
        }
        strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
            - effects_m[key];
        ret += ([key: strength]);
    }
    return ret;
}
object merge_cont_medium(object a, string medium_alias) {
    object medium;
    int no_join, q_a, q_m;
    mapping effects_a, effects_m, eff;
    string key;
    a->remove_alias(medium_alias);
    no_join = a->query_no_join();
    if ((medium = present(medium_alias, environment(a))) && !no_join) {
        a->set_no_join();
        a->move("/room/void");
        q_a = a->query_amount();
        q_m = medium->query_amount();
        medium->adjust_amount(q_a);
        effects_a = copy(a->query_eat_effects());
        effects_m = copy(medium->query_eat_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if (mapp(eff)) {
           foreach (key in keys(eff)) {
               medium->add_eat_effect(key, eff[key]);
           }
        }
        effects_a = copy(a->query_external_effects());
        effects_m = copy(medium->query_external_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if(eff) {
          foreach (key in keys(eff)) {
            medium->add_external_effect(key, eff[key]);
          }
        }
        call_out("dest_substance", 0, a);
        return medium;
    } else {
        a->add_alias(medium_alias);
        return a;
    }
}
void check_reaction(object a) {
    int amt_a, need_amt_a, amt_b, need_amt_b;
    string name_a, name_b, i_a, i_b, msg, fcn;
    mixed *fcns;
    int i, j, amt_result;
    object x, *bs, ob_a, ob_b;
    float ratio;
    class reaction rcn;
    if (objectp(this_player()))
      debug_rh = this_player()->query_property("debug_rh");
    else
      debug_rh = 0;
    write_dbg("Entering reaction_handler.\n");
    name_a = a->query_medium_alias();
    if (!name_a || !a->query_continuous()) {
        write_dbg("Leaving reaction_handler because there is no A or it is not "
        "continous.\n");
        return;
    }
    if ( a->query_medium_alias() == a->query_name() ) {
        debug_printf( "WARNING: Your cont_medium alias must "
          "not be the same as your name.\n" );
        return;
    }
    a = merge_cont_medium(a, name_a);
    bs = all_inventory(environment(a));
    debug_printf( "A is %O at %O. Bs are: %O.\n", a, environment( a ), bs );
    if ((sizeof(bs) < 2) || (!a->query_amount())) {
        write_dbg("Leaving reaction_handler because there is no B, or there is "
        "0 amounts of A.\n");
        return;
    }
    write_dbg("Checking the following: ");
    for (i = 0; i < sizeof(bs); i++) {
        write_dbg(bs[i]->query_medium_alias() + ", ");
    }
    write_dbg("\n");
    for (i = 0; i < sizeof(bs); i++) {
        if (!a->query_amount()) {
            write_dbg("Leaving reaction_handler.\n");
            return;
        }
        name_b = bs[i]->query_medium_alias();
        if (!name_b || !bs[i]->query_continuous() || !bs[i]->query_amount()) {
            continue;
        }
        if (name_a < name_b) {
            i_a = name_a;
            i_b = name_b;
            ob_a = a;
            ob_b = bs[i];
        } else {
            i_a = name_b;
            i_b = name_a;
            ob_a = bs[i];
            ob_b = a;
        }
        write_dbg("Checking " + i_a + " against " + i_b + ".\n");
        if (!substance[i_a] || !substance[i_a][i_b]) {
            continue;
        }
        write_dbg("...they react.\n");
        rcn = substance[i_a][i_b];
        amt_a = ob_a->query_amount();
        amt_b = ob_b->query_amount();
        ratio = to_float(amt_a) / amt_b;
        if (intp(rcn->ratio)) {
            rcn->ratio = to_float(rcn->ratio);
        }
        if (floatp(rcn->ratio)) {
            write_dbg("Single ratio...\n");
            if (ratio > rcn->ratio) {
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio)) +".\n" );
            } else {
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio)) +".\n" );
            }
        } else if (arrayp(rcn->ratio) && (sizeof(rcn->ratio) == 2)) {
            write_dbg("Range of ratios...");
            if (intp(rcn->ratio[0])) {
                rcn->ratio[0] = to_float(rcn->ratio[0]);
            }
            if (intp(rcn->ratio[1])) {
                rcn->ratio[1] = to_float(rcn->ratio[1]);
            }
            if (ratio > rcn->ratio[1]) {
                write_dbg("above range...(" + ratio + ")\n");
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio[1]));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio[1])) +".\n" );
                write_dbg("This is because amta is: "+ amt_b +" and ratio is "+ rcn->ratio[1] + ".\n" );
            } else if (ratio < rcn->ratio[0]) {
                write_dbg("below range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio[0]));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio[0])) +".\n" );
                write_dbg("This is because amta is: "+ amt_a +" and ratio is "+ rcn->ratio[0] + ".\n" );
            } else {
                write_dbg("within range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = amt_b;
            }
        } else {
            error("Illegal reaction ratio; expecting float, int, or "
                  "array of two floats or ints.");
        }
        amt_result = to_int((need_amt_a + need_amt_b)*rcn->result_amt);
        write_dbg("...got ("+amt_a+","+amt_b+"), taking ("+need_amt_a+","+
                  need_amt_b+"), creating " + amt_result + ".\n");
        write_dbg("...creating "+rcn->result+".\n");
        x = clone_object(rcn->result);
        if (rcn->result_amt) {
            if (function_exists("set_amount", x)) {
                x->set_amount(amt_result);
            } else {
                x->set_weight(amt_result);
            }
        }
        msg = rcn->message;
        if (msg) {
            msg = replace(rcn->message, ({
                "#env#", file_name(environment(a)),
                "#env2#", file_name(environment(environment(a))),
                "#obj_a#", file_name(ob_a),
                "#obj_b#", file_name(ob_b),
                "#obj_x#", file_name(x)
              }));
            tell_room(environment(environment(a)), msg);
        }
        fcns = rcn->func;
        if (fcns) {
            for (j = 0; j < sizeof(fcns); j++) {
                if (stringp(fcns[j])) {
                    fcn = replace(fcns[j], ({
                        "#env#", file_name(environment(a)),
                        "#env2#", file_name(environment(environment(a))),
                        "#obj_a#", file_name(ob_a),
                        "#obj_b#", file_name(ob_b),
                        "#obj_x#", file_name(x)
                      }));
                } else if (functionp(fcns[j])) {
                    evaluate(fcns[j], ob_a, ob_b, x, environment(a),
                             environment(environment(a)), need_amt_a,
                             need_amt_b);
                }
            }
        }
        call_out("move_substance", 0, ({x, environment(a)}));
        ob_a->adjust_amount( -need_amt_a );
        ob_b->adjust_amount( -need_amt_b );
    }
    write_dbg("Leaving reaction_handler.\n");
}
void move_substance(object *ob) {
    int vol, vol_left, cont, closed, i, mv_stat;
    object *contents;
    if (!ob[0] || !ob[1]) return;
    vol_left = (int)ob[1]->query_max_volume() - (int)ob[1]->query_volume();
    if (cont = ob[0]->query_continuous()) {
        vol = ob[0]->query_amount();
    } else {
        vol = (int)ob[0]->query_weight()*200;
    }
    closed = ob[1]->query_closed();
    ob[1]->set_open();
    if ((mv_stat = ob[0]->move(ob[1])) != MOVE_OK) {
        write_dbg(sprintf("Move error (%d)...", vol));
        if ((vol > vol_left) && cont && !closed) {
            write_dbg("too much...\n");
            ob[0]->set_amount(vol_left);
            tell_room(environment(ob[1]), ob[0]->short(0) +
                      " leaks out of the " + ob[1]->short(0) + ".\n");
            mv_stat = ob[0]->move(ob[1]);
        }
        if (mv_stat == MOVE_OK) {
            if (closed) ob[1]->set_closed();
        } else {
            contents = all_inventory(ob[1]);
            write_dbg(sprintf("contents = %O\n", contents));
            for (i = 0; i < sizeof(contents); i++) {
                contents[i]->dest_me();
            }
            if (!living(ob[1]) && !function_exists("query_co_ord", ob[1])) {
                tell_room(environment(ob[1]), ob[1]->the_short(0) +
                          " explodes, splattering the contents all over.\n");
                ob[1]->move("/room/rubbish");
            }
            ob[0]->move("/room/rubbish");
        }
    } else {
        if (closed) ob[1]->set_closed();
    }
}
void dest_substance(object ob) {
    if (ob) {
        ob->dest_me();
    }
}
mixed *query_reaction(string name_a, string name_b) {
    if (!substance[name_a] || !substance[name_a][name_b]) {
        return 0;
    }
    return substance[name_a][name_b];
}
mapping query_reactions() { return substance; }
void restore_from_files() {
    string *files;
    int i;
    files = ({ "base.hdr" });
    files += get_dir(REACTIONS + "*.rcn");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = REACTIONS + files[i];
    }
    substance = "/obj/handlers/data"->compile_data(files);
}
void update_from_files(string fn) {
    mapping new_substance;
    string a, b;
    new_substance = "/obj/handlers/data"->compile_data( ({ fn }) );
    foreach (a in keys(new_substance)) {
      if (undefinedp(substance[a])) {
        substance[a] = ([ ]);
      }
      foreach (b in keys(new_substance[a])) {
        substance[a][b] = new_substance[a][b];
      }
    }
}

==================================================
FILE: handlers/refresh.c
==================================================

#include <refresh.h>
#include <playerinfo.h>
#define SAVE_FILE "/save/refresh"
mapping refresh_callbacks;
mapping delete_callbacks;
nosave string loaded_by;
nosave string loaded_time;
protected void load_me()
{
  refresh_callbacks = 0;
  delete_callbacks = 0;
  unguarded( (: restore_object, SAVE_FILE, 0 :) );
  if (!refresh_callbacks) {
    refresh_callbacks = ([ ]);
  }
  if (!delete_callbacks) {
    delete_callbacks = ([ ]);
  }
}
protected void save_me()
{
  unguarded( (: save_object, SAVE_FILE, 0 :) );
}
string query_name() {
   return "Refresh Handler";
}
void create()
{
  seteuid("/secure/master"->creator_file(file_name(this_object())));
  load_me();
  if (!previous_object()) {
    loaded_by = "The Masked Man";
  } else {
    if (previous_object()->query_creator()) {
      loaded_by = "Creator: " + previous_object()->query_name();
    } else if (previous_object()->query_interactive()) {
      loaded_by = "Player: " + previous_object()->query_name();
    } else {
      loaded_by = file_name(previous_object());
      if (this_player())
        loaded_by += sprintf(" (%s)", this_player()->query_name());
    }
  }
  loaded_time = ctime(time());
}
void dest_me()
{
  save_me();
  destruct(this_object());
}
nomask mixed dwep()
{
  efun::destruct(this_object());
  return "Destructed With Extreme Prejudice";
}
string register_refresh(mixed ob, string func)
{
  object real;
  if (objectp(ob)) {
    ob = base_name(ob);
  }
  if (!ob) {
    return "Please supply an object";
  }
  real = load_object(ob);
  if (!real) {
    return "Couldn't find object";
  }
  if (func && !function_exists(func, real)) {
    return "Couldn't find function";
  }
  if (!func) {
    if (refresh_callbacks[ob]) {
      map_delete(refresh_callbacks, ob);
    }
  } else {
    if (refresh_callbacks[ob]) {
      refresh_callbacks[ob] = func;
    } else {
      refresh_callbacks += ([ ob : func ]);
    }
  }
  save_me();
}
string register_delete(mixed ob, string func)
{
  object real;
  if (objectp(ob)) {
    ob = base_name(ob);
  }
  if (!ob) {
    return "Please supply an object";
  }
  real = load_object(ob);
  if (!real) {
    return "Couldn't find object";
  }
  if (func && !function_exists(func, real)) {
    return "Couldn't find function";
  }
  if (!func) {
    if (delete_callbacks[ob]) {
      map_delete(delete_callbacks, ob);
    }
  } else {
    if (delete_callbacks[ob]) {
      delete_callbacks[ob] = func;
    } else {
      delete_callbacks += ([ ob : func ]);
    }
  }
  save_me();
}
varargs void player_refreshed(object player, int totally) {
  string ob;
  if (base_name(file_name(previous_object())) != "/global/player") {
    return;
  }
  foreach (ob in keys(refresh_callbacks)) {
    object obj;
    obj = load_object(ob);
    if (obj) {
      mixed *vals;
      vals = ({ refresh_callbacks[ob], player, totally });
      call_out( (: call_other, obj, vals :), 1);
    }
  }
}
varargs void player_deleted(string player)
{
  string ob;
  if (file_name(previous_object()) != "/secure/delete_clear" &&
      file_name(previous_object()) != "/cmds/lord/rmp_layer" &&
      !master()->high_programmer(previous_object(-1))) {
    unguarded( (: write_file, "/log/CHEAT", ctime( time() ) +
                ": illegal attempt to delete player files using "+
                "refresh_handler\nTrace: "+ back_trace() :) );
    return;
  }
  foreach (ob in keys(delete_callbacks)) {
    object obj;
    obj = load_object(ob);
    if (obj) {
      mixed *vals;
      vals = ({ delete_callbacks[ob], player, PLAYER_DELETED });
      call_out( (: call_other, obj, vals :), 1);
    }
  }
  "/secure/related_files"->delete_related_files(player, 1, 0);
}
mapping query_funcs()
{
  return ([
    "refresh callbacks" : refresh_callbacks,
    "delete callbacks" : delete_callbacks,
    ]);
}
mixed *stats()
{
  return ({
    ({ "refreshes", sizeof(refresh_callbacks) }),
    ({ "deletes", sizeof(delete_callbacks) }),
    ({ "loaded by", loaded_by }),
    ({ "loaded time", loaded_time }),
    });
}

==================================================
FILE: handlers/report_handler.c
==================================================

#include <report_handler.h>
inherit "/std/object";
void move_to_recent_cases(mixed *thing);
mixed *new_cases, *recent_cases;
void setup() {
  set_short("report handler");
  add_property("determinate", "the ");
  set_long("This is a rather tacky statue of a woman holding "
    "a sword and some wonky scales.\n");
  if(file_size(NEWCASES) > -1) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(file_size(RECENT) > -1) {
    recent_cases = restore_variable(read_file(RECENT));
  }
}
void save_new_cases() {
  unguarded((: rm, NEWCASES :));
  unguarded((: write_file, NEWCASES, save_variable(new_cases)+"\n" :));
}
mixed query_new() {
  return new_cases;
}
int sizeof_new_cases() {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  return sizeof(new_cases);
}
string query_new_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(new_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Player%^RESET%^: "+capitalize(new_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(new_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+new_cases[i][CATEGORY]+"\n";
  }
  return reports;
}
string query_new_case(int i) {
  string report = "";
  mixed *stuff;
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(i < 1 || i > sizeof(new_cases)) {
    return 0;
  }
  stuff = new_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+stuff[CREATOR]+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Category%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0=";
  return report;
}
void add_report(string *stuff) {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  new_cases += ({ stuff });
  save_new_cases();
}
void deal_with_it(int num, string name, string decision) {
  mixed *thing;
  num--;
  thing = new_cases[num];
  thing += ({ name });
  thing += ({ decision });
  new_cases -= ({new_cases[num]});
  move_to_recent_cases(thing);
}
void save_recent_cases() {
  unguarded((: rm, RECENT :));
  unguarded((: write_file, RECENT, save_variable(recent_cases)+"\n" :));
}
void move_to_recent_cases(mixed *thing) {
  int i, j;
  mixed *c_record, *chars;
  for(i = sizeof(recent_cases) - NO_RECENT; i > -1; i--) {
    chars = ({recent_cases[i][NAME]});
    if(arrayp(recent_cases[i][CHARS])) {
      chars += recent_cases[i][CHARS];
    }
    uniq_array(chars);
    for(j = 0; j < sizeof(chars); j++) {
      if(file_size((SAVEPATH+chars[j]+".o")) > -1) {
        c_record = restore_variable(read_file((SAVEPATH+chars[j]+".o")));
        c_record += ({recent_cases[j]});
      } else {
        c_record = ({recent_cases[j]});
      }
      unguarded((: rm, (SAVEPATH+chars[j]+".o") :));
      unguarded((: write_file, (SAVEPATH+chars[j]+".o"),
        save_variable(c_record)+"\n" :));
    }
    recent_cases -= ({recent_cases[i]});
  }
  recent_cases += ({ thing });
  save_new_cases();
  save_recent_cases();
}
mixed query_recent() {
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  return recent_cases;
}
string query_recent_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(recent_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Suspect%^RESET%^: "+capitalize(recent_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(recent_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+recent_cases[i][CATEGORY]+"\n";
  }
  return reports;
}
string query_recent_case(int i) {
  string report = "";
  mixed *stuff;
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  if(i < 1 || i > sizeof(recent_cases)) {
    return 0;
  }
  stuff = recent_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
    "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
    "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
  for(i = 8; i < sizeof(stuff); i += 2) {
    report += "  %^YELLOW%^Comment from "+stuff[i]+"%^RESET%^: "
      +stuff[i + 1];
  }
  return report;
}
string case_history(string name) {
  int i, j;
  mixed *history, *cases, *stuff, *all_cases, *check_case;
  string report, *other_chars = ({ });
  history = get_dir(SAVEPATH+lower_case(name)+".o");
  all_cases = get_dir(SAVEPATH);
  all_cases -= ({"recent.o", "new.o"});
  for(i = 0; i < sizeof(all_cases); i++) {
    check_case = restore_variable(read_file((SAVEPATH+all_cases[i])));
    for(j = 0; j < sizeof(check_case); j++) {
      if(arrayp(check_case[j][CHARS])) {
        if(member_array(capitalize(name), check_case[j][CHARS]) != -1) {
          other_chars += check_case[j][CHARS];
          other_chars += ({check_case[j][NAME]});
        }
      }
    }
  }
  if(sizeof(other_chars)) {
    uniq_array(other_chars);
    for(i = 0; i < sizeof(other_chars); i++) {
      other_chars[i] = capitalize(other_chars[i]);
    }
    other_chars -= ({capitalize(name)});
    other_chars = uniq_array(other_chars);
    write(capitalize(name)+" is also "
      +query_multiple_short(other_chars)+".\n");
  }
  if(!sizeof(history)) {
    return 0;
  }
  write("%^CYAN%^Case History for "+capitalize(name)+"%^RESET%^:\n");
  report = "";
  cases = restore_variable(read_file(SAVEPATH+lower_case(name)+".o"));
  for(i = 0; i < sizeof(cases); i++) {
    stuff = cases[i];
    report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
    if(!sizeof(stuff[CHARS])) {
      report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
    } else {
      report += "  %^CYAN%^Other Characters%^RESET%^: "
        "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
    }
    report +=  "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
      "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
      "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
      "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
      "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
      "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
    for(j = 8; j < sizeof(stuff); j += 2) {
      report += "  %^YELLOW%^Comment from "+stuff[j]+"%^RESET%^: "
        +stuff[j + 1];
    }
  }
  return report;
}
void add_comment(int i, string name, string comment) {
  i--;
  recent_cases[i] += ({ capitalize(name), comment });
  save_recent_cases();
}

==================================================
FILE: handlers/room_handler.c
==================================================

#include <climate.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <room.h>
#include <weather.h>
#include <position.h>
#define CHATSIZE 80
#define DOORSIZE 60
mapping exit_types;
mapping door_types;
mapping opposite;
mixed *chatters, *doors;
void add_door( object thing );
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   exit_types = ([
"standard" :({ 0, 1,   400, 0 }),
"corridor" :({ 0, 1,   250, 0 }),
"plain"    :({ 0, 1, 10000, 0 }),
"door"     :({ 0, 1,   300, 0 }),
"stair"    :({ 0, 1,   300, 0 }),
"hidden"   :({ 0, 0,   300, 0 }),
"secret"   :({ 0, 0,   300, 0 }),
"gate"     :({ 0, 1,   450, 0 }),
"road"     :({ 0, 1,  1300, 0 }),
"path"     :({ 0, 1,   800, 0 }),
"window"   :({ "$N climb$s through a window.\n", 0, 75, 0 }),
]);
   door_types = ([
"door"      : ({ 0, 0, "generic_key", 2, 0, 0, "door" }),
"secret"    : ({ 0, 0, "generic_key", 3, 1, 0, "door" }),
"gate"      : ({ 1, 0, "generic_key", 1, 0, 1, "door" }),
"window"    : ({ 1, 0, "generic_key", 1, 0, 1, "window" }),
]);
   opposite = ([
"north" : ({ 0, "$R$[the ]+south$R$" }),
"south" : ({ 0, "$R$[the ]+north$R$" }),
"east" : ({ 0, "$R$[the ]+west$R$" }),
"west" : ({ 0, "$R$[the ]+east$R$" }),
"northeast" : ({ 0, "$R$[the ]+southwest$R$" }),
"southwest" : ({ 0, "$R$[the ]+northeast$R$" }),
"southeast" : ({ 0, "$R$[the ]+northwest$R$" }),
"northwest" : ({ 0, "$R$[the ]+southeast$R$" }),
"up":({0,"below"}), "down":({0,"above"}),
"out":({0,"inside"}), "in":({0,"outside"}),
"exit":({0,"inside"}), "enter":({0,"outside"}),
"hubward":({0,"rimward"}), "rimward":({0,"hubward"}),
"turnwise":({0,"widdershins"}),
"widdershins":({0,"turnwise"}) ]);
   chatters = allocate( CHATSIZE );
   doors = allocate( DOORSIZE );
   call_out( "housekeeping", 4 );
}
string query_opposite_direction(string dir) {
   if (opposite[dir]) {
      return opposite[dir][1];
   }
   return 0;
}
mixed *query_chatters() { return chatters; }
mixed *query_doors() { return doors; }
int add_exit_type(string type, mixed message, mixed obvious,
                            int size, mixed func) {
  if (exit_types[type]) {
    return 0;
  }
  exit_types[type] = ({ message, obvious, size, func });
  return 1;
}
int remove_exit_type(string type) {
   map_delete(exit_types, type);
   return 1;
}
mixed *query_door_type(string type, string direc, string dest) {
   if (!door_types[type]) {
      return 0;
   }
   call_out( "check_door", 1, ({ previous_object(), direc }) );
   return door_types[type];
}
void check_door( mixed args ) {
   string direc, dest;
   string door_name;
   if ( !args[ 0 ] ) {
      return;
   }
   args[ 0 ]->set_destination( args[ 1 ] );
   dest = (string)args[ 0 ]->query_destination( args[ 1 ] );
   if ( !dest ) {
      tell_room( args[ 0 ], "Error: "+ args[ 1 ] +
            " is no longer an exit.\n" );
      return;
   }
   if ( !find_object( dest ) ) {
      return;
   }
   door_name = args[0]->call_door(args[1], "query_door_name");
   direc = (string)dest->query_door( args[ 0 ], door_name );
   if ( !direc &&
       !args[ 0 ]->call_door( args[ 1 ], "query_one_way" ) ) {
      tell_room( args[ 0 ], "Error: "+ dest +
                "does not have a door coming back here.\n" );
      return;
   }
   args[ 0 ]->modify_exit( args[ 1 ], ({ "other", direc }) );
   args[ 0 ]->modify_exit( args[ 1 ], ({
      "closed", (int)dest->call_door( direc, "query_closed" ),
      "locked", (int)dest->call_door( direc, "query_locked" ) }) );
   if ( !args[ 0 ]->call_door( args[ 1 ], "query_closed" ) &&
       ( (string)args[ 0 ]->query_property( "location" ) == "outside" ) ) {
      add_door( (object)args[ 0 ]->query_door_control( args[ 1 ], door_name ) );
   }
}
mixed *query_exit_type(string type, string dir) {
  mixed s;
   if (!(s = opposite[dir])) {
      s = ({ 0, "elsewhere" });
   }
   if (!exit_types[type]) {
      return exit_types["standard"] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
   }
   return exit_types[ type ] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
}
int move_thing( object thing, string dir, string dest, mixed exit,
                mixed enter, string move ) {
  int ret;
  string arrive, leave;
  object dragging;
  dragging = (object)thing->query_dragging();
  if (dragging && environment(dragging) != environment(thing)) {
    thing->reset_dragging();
    dragging = 0;
  }
  if ( ( exit != "none" ) || objectp( dragging ) ) {
    if ( stringp( enter ) )
      enter = ({ 1, enter });
    else if ( functionp(enter) )
      enter = ({ 1, evaluate(enter, thing) });
    else if ( !pointerp( enter ) )
      enter = ({ 0, "somewhere" });
    switch ( enter[ 0 ] ) {
    case 0 :
      arrive = replace( (string)thing->query_msgin(),
                        ({"$F", enter[ 1 ],
                          "$r", thing->query_pronoun() }) );
      break;
    default :
      arrive = enter[ 1 ];
    }
    if ( stringp( exit) )
      leave = exit;
    else if ( functionp( exit ) )
      leave = evaluate(exit, thing);
    else if ( pointerp( exit ) )
      leave = exit[ 0 ];
    else
      leave = (string)thing->query_msgout();
    leave = replace( leave, ({"$T", "$R$-"+ dir +"$R$",
                              "$r", thing->query_pronoun() }) );
  }
  thing->return_to_default_position(1);
  if ( arrive || objectp( dragging ) ) {
    thing->remove_hide_invis( "hiding" );
    if ( stringp( arrive ) && objectp( dragging ) ) {
      arrive += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->a_short() +" in behind "+
        (string)thing->query_objective() +".";
    }
    if ( stringp( leave ) && objectp( dragging ) ) {
      leave += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->the_short() +" away behind "+
        (string)thing->query_objective() +".";
    }
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest, arrive, leave );
    if ( ( ret == MOVE_OK ) && objectp( dragging ) ) {
      if(dragging->move(environment(thing)) == MOVE_OK) {
        tell_object( thing, "You drag "+
                     (string)dragging->the_short() +" behind you.\n" );
        thing->adjust_time_left( -DEFAULT_TIME );
      } else {
        tell_object( thing, "You fail to drag "+
                     (string)dragging->the_short() +" behind you.\n" );
      }
    }
  } else {
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest );
  }
  if ( ret == MOVE_OK ) {
    thing->adjust_time_left( -DEFAULT_TIME );
    return 1;
  }
  return 0;
}
int exit_move_door_checks(object thing, mixed closed) {
  closed->force_other();
  if(closed->query_open())
    return 1;
  if(thing->query_property( "demon" ) || thing->query_property("dead")) {
    tell_object(thing, "You ghost through "+(string)closed->the_short()+
                ".\n");
    return 1;
  }
  if(thing->query_weight() < 300)
    return 0;
  if(closed->query_locked() && !closed->moving_unlock(thing)) {
    if(!closed->query_visible(thing)) {
      return 0;
    }
    tell_object(thing, (string)closed->the_short() +
                ({ " is ", " are " })[(int)closed->query_how_many()] +
                "locked.\n");
    return notify_fail("");
  }
  if(!closed->moving_open(thing)) {
    return 0;
  }
  return 1;
}
int exit_move_func_checks(string verb, string special, object thing,
                          mixed func, object place) {
  if(stringp(func))
    return call_other(place, func, verb, thing, special);
  if(functionp(func))
    return evaluate(func, verb, thing, special);
  if(pointerp(func) && sizeof(func) > 1 && func[0] && func[1])
    return call_other(func[0], func[1], verb, thing, special);
  return 1;
}
int exit_move( string verb, string extra, mixed special, object thing ) {
   string leave;
   object place;
   object follower;
   object *okay;
   mixed closed;
   int locked;
   mixed func;
   mixed *dest_other;
   object *all_followers;
   object *tmp_followers;
   object *more_followers;
   place = environment( thing );
   verb = (string)place->expand_alias( verb );
   place->set_destination( verb );
   dest_other = (mixed *)place->query_dest_other( verb );
   if (!pointerp(dest_other))
      return 0;
   if(thing->cannot_walk( verb, dest_other ))
      return notify_fail( "" );
   closed = (object)place->query_door_control( verb );
   if(objectp(closed)) {
     closed->force_other();
     if(!closed)
       closed = (object)place->query_door_control( verb );
   }
   if (!interactive(thing) && living(thing)
         && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
      return 0;
   if (objectp(closed)) {
      locked = closed->query_locked();
   }
   if(objectp(closed) && closed->query_open()) {
     closed = 0;
   }
   if(objectp(closed) && !exit_move_door_checks(thing, closed)) {
     return 0;
   }
   if ( place->block_exit_move( verb, thing ) ) {
     return notify_fail( "" );
   }
   func = dest_other[ROOM_FUNC];
   if(func && !thing->query_property( "demon" ) &&
      !exit_move_func_checks(verb, special, thing, func, place))
     return 0;
   if ( place->query_relative( verb ) )
     leave = (string)thing->find_rel( verb, 0 );
   else
     leave = verb;
   if((int)thing->query_height() > dest_other[ ROOM_SIZE ] &&
      !(thing->query_crawling() &&
        (int)thing->query_height()/3 <= dest_other[ ROOM_SIZE ])) {
     tell_object( thing, "You are too tall to go that way.\n" );
     return notify_fail( "" );
   }
   if ( !stringp( special ) ) {
      special = dest_other[ ROOM_EXIT ];
   }
   if ( !move_thing( thing, verb, dest_other[ ROOM_DEST ], special,
                     dest_other[ ROOM_ENTER ], dest_other[ ROOM_MESS ] ) ) {
     return 0;
   }
   thing->return_to_default_position(1);
   okay = ({ });
   if (place) {
     all_followers = thing->query_followers();
     more_followers = all_followers;
     do {
       tmp_followers = ({ });
       foreach (follower in more_followers) {
         if (follower &&
             environment( follower ) == place ) {
           tmp_followers |= follower->query_followers();
         }
       }
       more_followers = tmp_followers - all_followers;
       all_followers |= tmp_followers;
     } while (sizeof(more_followers));
     foreach ( follower in all_followers) {
       if ( !objectp( follower ) ) {
         thing->remove_follower( follower );
         continue;
       }
       if(environment(follower) != place ||
          (userp(follower) && !interactive(follower)) ||
          (!thing->query_visible(follower) || (special == "none")) ||
          follower->query_property( PASSED_OUT) ||
          follower->cannot_walk( verb, dest_other ))
         continue;
       if(objectp(closed) && !exit_move_door_checks(follower, closed))
         continue;
       if ( func && !follower->query_property( "demon" ) &&
            !exit_move_func_checks(verb, special, follower, func, place))
         continue;
       if (!interactive(follower) && living(follower)
           && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
         continue;
       if ( place->query_relative( verb ) ) {
         leave = (string)follower->find_rel( verb, 0 );
         follower->reorient_rel( leave );
       } else {
         leave = verb;
         follower->reorient_abs( leave );
       }
       if ( (int)follower->query_height() > dest_other[ ROOM_SIZE ] ) {
         tell_object( follower, "You are too tall to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
         continue;
       }
       if (function_exists("check_doing_follow", follower) &&
           !follower->check_doing_follow(thing, verb, special)) {
         continue;
       }
       if(move_thing( follower, verb, dest_other[ROOM_DEST], special,
                      dest_other[ROOM_ENTER], dest_other[ROOM_MESS]) &&
          living(follower)) {
         tell_object(follower, "You follow "+ (string)thing->the_short() +
                     " "+ leave +".\n");
         if(follower->query_visible(thing))
           okay += ({ follower });
         follower->return_to_default_position(1);
       } else {
         tell_object( follower, "You fail to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
       }
     }
   }
   thing->room_look();
   if(sizeof(okay)) {
     okay->room_look();
     tell_object(thing, query_multiple_short(okay) +
                 " $V$0=follows,follow$V$ you.\n" );
   }
   if(objectp(closed)) {
      closed->moving_close(thing);
      if (locked)
        closed->moving_lock(thing);
   }
   return 1;
}
void housekeeping() {
   call_out( "check_chatters", 1 );
   call_out( "check_doors", 2 );
   call_out( "housekeeping", 4 );
}
void add_chatter(object thing, int number) {
   number /= 4;
   if ( number > CHATSIZE - 1 )
      number = CHATSIZE - 1;
   if ( !pointerp( chatters[ number ] ) )
      chatters[ number ] = ({ thing });
   else
      chatters[ number ] += ({ thing });
}
void check_chatters() {
   object thing, *things;
   things = chatters[ 0 ];
   chatters[ 0 .. <2 ] = chatters[ 1 .. <1 ];
   chatters[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) )
         thing->make_chat();
   }
}
void add_door( object thing ) {
   int number;
   number = random( DOORSIZE );
   if ( !pointerp( doors[ number ] ) )
      doors[ number ] = ({ thing });
   else
      doors[ number ] += ({ thing });
}
void check_doors() {
   int wind;
   string dest, other, mess;
   object mine, thing, *things;
   things = doors[ 0 ];
   doors[ 0 .. <2 ] = doors[ 1 .. <1 ];
   doors[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_closed() )
         continue;
      if(thing->query_stuck())
         continue;
      dest = (string)thing->query_dest();
      other = (string)thing->query_other_id();
      mine = (object)thing->query_my_room();
      wind = (int)WEATHER->calc_actual( mine, WINDSP );
      if ( random( 25 ) > wind ) {
         add_door( thing );
         return;
      }
      switch ( wind ) {
       case -1000 .. 20 :
         mess = "blow$s shut in the breeze.\n";
         break;
       case 21 .. 40 :
         mess = "blow$s shut in the wind.\n";
         break;
       default :
         mess = "slam$s shut in the wind.\n";
      }
      if ( find_object( dest ) ) {
         dest->modify_exit( other, ({ "closed", 1 }) );
         if(thing->query_autolock())
           dest->modify_exit(other, ({ "locked", 1 }));
         dest->tell_door( other, "The $D "+ mess, 0 );
      }
      thing->set_closed( 1 );
      if(thing->query_autolock())
        thing->set_locked();
      thing->tell_door( "The $D "+ mess, 0 );
   }
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "exit_types" : exit_types,
            "door_types" : door_types,
            "opposite" : opposite,
            "chatters" : chatters,
            "doors" : doors,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["exit_types"])
      exit_types = maps["exit_types"];
   if (maps["door_types"])
      door_types = maps["door_types"];
   if (maps["opposite"])
      opposite = maps["opposite"];
   if (maps["chatters"])
      chatters = maps["chatters"];
   if (maps["doors"])
      doors = maps["doors"];
}
mixed *stats() {
   int door_count, chatter_count;
   mixed temp;
   foreach (temp in chatters)
      chatter_count += sizeof( temp );
   foreach (temp in doors)
      door_count += sizeof( temp );
   return ({
      ({ "exit types", sizeof( exit_types ) }),
      ({ "door types", sizeof( door_types ) }),
      ({ "opposites",  sizeof( opposite ) }),
      ({ "chatters",  chatter_count }),
      ({ "doors", door_count }),
   });
}

==================================================
FILE: handlers/room_rental.c
==================================================

#include <money.h>
#include <room/room_rental.h>
protected void do_load();
protected void do_save();
protected void evict_tenant( object room_ob );
private nosave int loaded = 0;
private mapping rented_rooms = ([]);
private mapping rental = ([]);
private mapping eviction_times = ([]);
private mapping locations = ([]);
private mapping paths = ([]);
void create() {
  do_load();
}
void reset() {
   string room;
   int now = time();
   foreach( room in keys( rented_rooms ) ) {
      if ( stringp( rented_rooms[ room ] ) ) {
         if ( ( eviction_times[ room ] < now ) &&
              ( eviction_times[ room ] > -1 ) ) {
            evict_tenant( find_object( room ) );
            tell_creator( "goldenthread", "RENTAL: %s no longer rents %s\n",
                          rented_rooms[ room ], room );
            rented_rooms[ room ] = 0;
            eviction_times[ room ] = -1;
         }
      }
   }
   do_save();
}
protected void do_load() {
   if ( !loaded )
      unguarded( (: restore_object( ROOM_RENTAL_SAVE_FILE, 1 ) :) );
   loaded = 1;
}
protected void do_save() {
   unguarded( (: save_object( ROOM_RENTAL_SAVE_FILE , 0 ) :) );
}
void evict_tenant( object room_ob ) {
   object *occupants;
   occupants = filter( all_inventory( room_ob ), (: living :) );
   room_ob->evict_tenant( occupants );
}
int add_room( string room, int cost, object office ) {
   object room_ob;
   if( !room_ob = load_object( room ) )
      return 0;
   rented_rooms[ room ] = 0;
   rental[ room ] = cost;
   eviction_times[ room ] = -1;
   locations[ room ] = office->query_location();
   paths[ room_ob->short() ] = room;
   do_save();
   return 1;
}
string query_who_rents( string room, object office ) {
   if ( locations[room] == office->query_location() ) {
      if ( stringp( rented_rooms[room] ) )
         return rented_rooms[room];
      else
         return "nobody";
   } else
      return "no such room in this location";
}
int check_tenant( object player_ob, object room_ob, object office ) {
   string player = player_ob->short();
   string room = room_ob->short();
   if ( player == query_who_rents( room, office ) )
      return RENTAL_SUCCESS;
   else if ( player == "nobody" )
      return RENTAL_AVAILABLE;
   else if ( player == "no such room!" )
      return RENTAL_NO_SUCH_ROOM;
   else
      return RENTAL_ALREADY_RENTED;
}
int delete_room( string room, object office ) {
  string room_short = load_object( room )->short();
  if ( locations[room] == office->query_location() ) {
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_short );
    do_save();
    return 1;
  } else
    return 0;
}
int clear_rooms( object office ) {
   object room_ob;
   foreach( string room in keys( filter( locations,
            (: $2 == $( office->query_location() ) :) ) ) ) {
      room_ob = load_object( room );
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_ob->query_short() );
  }
  do_save();
  return 1;
}
string *query_rooms_to_rent( object office ) {
  return keys( filter( locations,
               (: $2 == $( office->query_location() ) :) ) );
}
int do_rental( object player_ob, string room_short, object office ) {
   int result;
   string domain = office->query_domain();
   string room = paths[ room_short ];
   if ( locations[room] == office->query_location() ) {
      if ( !rented_rooms[room] ||
           ( rented_rooms[room] == player_ob->short()) ) {
         if ( (int)player_ob->query_value_in( domain ) < rental[room] )
            return RENTAL_NO_MONEY;
         rented_rooms[room] = player_ob->short();
         eviction_times[room] = time() + ONE_DAY;
         result = RENTAL_SUCCESS;
      } else
         result = RENTAL_ALREADY_RENTED;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}
int query_rental_value( string room ) {
   return rental[ room ];
}
int remove_rental( object room_ob ) {
   int result;
   string room_short = room_ob->short();
   string room = paths[ room_short ];
   if ( !undefinedp( rented_rooms[room] ) ) {
      rented_rooms[room] = 0;
      result = RENTAL_SUCCESS;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}

==================================================
FILE: handlers/route_handler.c
==================================================

int use_count;
varargs void get_route(string end, string start, function call_back, int count) {
  string *result;
  if(start == "/room/virtual"){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    return;
  }
  if(!(stringp(start) && stringp(end)))
    error("illegal argument 1 or 2 to get_route");
  if(!function_owner(call_back))
    return;
  if ((end == start) || (count > 3)){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    if(end != start)
      log_file("ROUTEHANDLER","route for %s from %s to %s failed\n",
               file_name(function_owner(call_back)), start, end);
    return;
  }
  result = "/obj/handlers/clusters"->get_route(start, end);
  if(!result){
    call_out((:get_route($(end), $(start), $(call_back), $(count + 1)):), 10);
    return;
  }
  use_count++;
  call_out((: evaluate($(call_back), $(result)) :), 1);
  return;
}
void dest_me() {
  destruct(this_object());
}
mixed *stats() {
  return  ({
    ({ "routes done", use_count }),
  });
}

==================================================
FILE: handlers/script_processor.c
==================================================

#define RATIO 20
inherit "/std/object";
string stage;
mapping actors;
void setup() {
   actors = ([ ]);
}
string query_stage() { return stage; }
void set_stage( string word ) { stage = word; }
mapping query_actors() { return actors; }
string query_actor( string word ) { return actors[ word ]; }
void set_actor( string name, string path ) { actors[ name ] = path; }
int perform_line( string script, int line ) {
   int length;
   string action, name, text;
   object actor;
   length = file_length( script );
   if ( length < 1 ) {
      write( "Length of file \""+ script +"\" is "+ length +".\n" );
      return -1;
   }
   if ( length < line )
      return -1;
   if ( !stage || ( stage == "" ) )
      return -2;
   text = read_file( script, line, 1 );
   if ( sscanf( text, "%s=%s\n", name, action ) == 2 ) {
      if ( !actors[ name ] )
         return -3;
      actor = find_object( actors[ name ] );
      if ( !actor )
         return -4;
      actor->do_command( action );
   } else {
      actor = find_object( stage );
      if ( !actor )
         return -4;
      tell_room( actor, text );
   }
   if ( length == line )
      return -5;
   return strlen( text ) / RATIO;
}
void perform_script( string script, int line ) {
   int next;
   next = perform_line( script, line );
   if ( next < 0 ) {
      if ( find_object( stage ) )
         stage->script_ended( next );
      return;
   }
   call_out( "perform_script", 2 + next, script, line + 1 );
}
int start_script( string script ) {
   if ( find_call_out( "perform_script" ) != -1 )
      return 0;
   call_out( "perform_script", 3, script, 1 );
   return 1;
}

==================================================
FILE: handlers/snmp_handler.c
==================================================

#include "snmp.h"
void create()
{
}
buffer BufferiseInt(int p)
{
  buffer buf1;
  buf1=allocate_buffer(4);
  if(p<0)
  {
    buf1[0]=(4294967296+p)/16777216;
  } else {
    buf1[0]=p/16777216;
  }
  buf1[1]=p/65536;
  buf1[2]=p/256;
  buf1[3]=p%256;
  return buf1;
}
buffer GetData(buffer MIB)
{
  int i,j,k;
  object *tmp;
  buffer mibreply,mibdata,tmpbuf;
  mibreply=allocate_buffer(4);
  tmpbuf=allocate_buffer(1);
  mibreply[0]=48;
  mibreply[1]=0;
  mibreply[2]=OBJECT_IDENT;
  mibreply[3]=0;
  mibreply+=MIB;
  i=sizeof(mibreply);
  switch(MIB[6])
  {
    case 101 :
      j=sizeof(users());
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 102 :
      j=0;
      tmp=users();
      for(k=0;k<sizeof(tmp);k++)
        if(tmp[k] && (tmp[k])->query_creator())
          j++;
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 100 :
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=1;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      break;
    default :
      mibreply[0]=255;
      break;
  }
  mibreply[1]=sizeof(mibreply)-2;
  mibreply[3]=sizeof(MIB);
  return mibreply;
}

==================================================
FILE: handlers/soul_compiler.c
==================================================

#include "soul.h"
#include "user_parser.h"
private nosave string _current_file;
private nosave int _current_line;
private nosave int _file_len;
private nosave int _depth;
private nosave int _look_for;
private nosave int _last_chunk_compile;
private nosave mixed *_to_compile;
private nosave mixed *_arguments;
private nosave object _current_player;
void start_compile();
void parse_chunk(string chunk);
void make_into_soul_commands(mapping commands);
#define CHUNK_SIZE 20
#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define ARGUMENT_VALUE 5
#define ARGUMENT_NAME 6
#define REST_OF_ARGUMENT 7
void create() {
   _to_compile = ({ });
   seteuid("Root");
}
int test_security(string fname) {
   return 1;
}
void notify(string mess) {
   if (_current_player)
      tell_object(_current_player, mess);
}
void compile_file(string fname) {
   if (file_size(SOUL_DIR+fname) == -1) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" does not exist.\n");
      return ;
   }
   if (file_size(SOUL_DIR+fname) == -2) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" is a directory exist.\n");
      return ;
   }
   _to_compile += ({ SOUL_DIR+fname, this_player() });
   start_compile();
}
void compile_directory(string fname) {
   string *bits, start;
   int i;
   if (file_size(SOUL_DIR+fname) != -2) {
      tell_object(this_player(), "The file "+
                         fname+" is not a directory exist.\n");
      return ;
   }
   bits = explode(fname, "/");
   start = implode(bits[0..<1], "/");
   if (start != "") {
      start += "/";
   }
   fname = SOUL_DIR+fname;
   if (fname[<1] == '/') {
      fname += "*.s";
   } else {
      fname += "
void start_compile() {
   if ((_current_file || !sizeof(_to_compile)) &&
       (time() - _last_chunk_compile) > 10) {
      return ;
   }
   write("Starting to compile " + _to_compile[0] + "\n");
   _current_file = _to_compile[0];
   _current_player = _to_compile[1];
   _to_compile = _to_compile[2..];
   _current_line = 1;
   _depth = 0;
   _look_for = OPEN_BRACKET;
   _file_len = file_length(_current_file);
   _arguments = ({ 0, ([ ]) });
   call_out("compile_chunk", 2);
}
void compile_chunk() {
   string chunk;
   int end;
   _last_chunk_compile = time();
   if (_current_line+CHUNK_SIZE > _file_len) {
      end = _file_len+1;
   } else {
      end = _current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, _current_file, _current_line,
                               end-_current_line :));
   _current_line = end;
   parse_chunk(chunk);
   if (end > _file_len) {
      call_out("start_compile", 2);
      _current_file = 0;
      make_into_soul_commands(_arguments[1]);
   } else {
      call_out("compile_chunk", 2);
   }
}
void parse_chunk(string chunk) {
   string *bits, s1, s2;
   int pos, chunk_size, start;
   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (_look_for) {
         case OPEN_BRACKET :
            if (sscanf(chunk[pos..], "%s(%s", s1, s2)) {
               chunk = s2;
               chunk_size = strlen(chunk);
               pos = 0;
               _depth++;
               _arguments += ({ 0, 0 });
               _look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;
         case ARGUMENT_NAME :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            while (pos < chunk_size && chunk[pos] != ' ' &&
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            _arguments[_depth*2] = chunk[start..pos-1];
            _look_for = ARGUMENT_VALUE;
            break;
         case ARGUMENT_VALUE :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  _arguments[_depth*2+1] = ([ ]);
                  _depth++;
                  _arguments += ({ 0, 0 });
                  _look_for = ARGUMENT_NAME;
                  pos++;
                  break;
               case '"' :
                  _arguments[_depth*2+1] = "";
                  _look_for = END_STRING;
                  pos++;
                  break;
               default :
                  start = pos;
                  if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
                     _arguments[_depth*2+1] = replace(implode(explode(replace(s1,
                            ({ "\n", " ", "\r", "" })), " ")-({ "" }), " "), ", ", ",");
                     pos = 0;
                     chunk = ")"+s2;
                     _look_for = END_BRACKET;
                  } else {
                     _arguments[_depth*2+1] = chunk[pos..];
                     _look_for = REST_OF_ARGUMENT;
                     pos = 0;
                     chunk = "";
                  }
                  chunk_size = strlen(chunk);
                  break;
            }
            break;
         case REST_OF_ARGUMENT :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
               _arguments[_depth*2+1] = replace(implode(explode(
                                                    replace(_arguments[_depth*2+1]+s1, "\n", " "),
                                                                         " ") - ({ "" }),
                                                             " "), ", ", ",");
               pos = 0;
               chunk = ")"+s2;
               _look_for = END_BRACKET;
            } else {
               _arguments[_depth*2+1] += chunk[pos..];
               pos = 0;
               chunk = "";
            }
            chunk_size = strlen(chunk);
            break;
         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               switch (_depth) {
                  case 2 :
                  case 3 :
                     if (pointerp(_arguments[_depth*2-1][_arguments[_depth*2]]))
                        _arguments[_depth*2-1][_arguments[_depth*2]] += ({ _arguments[_depth*2+1] });
                     else
                        _arguments[_depth*2-1][_arguments[_depth*2]] = ({ _arguments[_depth*2+1] });
                     break;
                  case 1 :
                  case 4 :
                  case 5 :
                  case 6 :
                  case 7 :
                     _arguments[_depth*2-1][_arguments[_depth*2]] = _arguments[_depth*2+1];
                     break;
               }
               chunk = s2;
               chunk_size = strlen(s2);
               _depth--;
               pos = 0;
               _arguments = _arguments[0.._depth*2+1];
               if (_depth) {
                  _look_for = START_ARGUMENT;
               } else {
                  _look_for = OPEN_BRACKET;
               }
            }
            break;
         case START_ARGUMENT :
            while (pos < chunk_size && (chunk[pos] == ' '
                   || chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ')' :
                  _look_for = END_BRACKET;
                  break;
               case '(' :
                  _look_for = OPEN_BRACKET;
                  break;
               default :
                  if (!sscanf(chunk[pos..], "%s\n%s", s1, s2)) {
                     s1 = chunk;
                  }
                  printf("Syntax error in file %s, near %s\n", _current_file, s1);
                  _look_for = END_BRACKET;
                  break;
            }
            break;
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  _arguments[_depth*2+1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  _arguments[_depth*2+1] += replace(s1, "\n", "");
                  _look_for = END_BRACKET;
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               _arguments[_depth*2+1] += replace(chunk, "\n", "");
               pos = chunk_size;
            }
            break;
         default :
            notify("Horrible error "+_look_for+"\n");
            pos = chunk_size;
            break;
      }
   }
}
int check_sort(string pat1, string pat2) {
   int lvl1, lvl2;
   lvl1 = ((mixed *)PATTERN_OB->compile_pattern(pat1))[0];
   lvl2 = ((mixed *)PATTERN_OB->compile_pattern(pat2))[0];
   return lvl2-lvl1;
}
string *sort_patterns(string *inp) {
   if (!pointerp(inp)) {
      printf("%O\n", inp);
      return ({ });
   }
   return sort_array(inp, "check_sort", this_object());
}
void make_into_soul_commands(mapping comms) {
   string *fluff;
   int i, failed, j;
   mapping ret, tmp;
   fluff = keys(comms);
   ret = ([ ]);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]] = ({ comms[fluff[i]]["pattern"], 0, 0 });
      if (comms[fluff[i]]["single"]) {
         if (comms[fluff[i]]["single"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["single"][0]["no-arguments"][0];
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][SINGLE] = ({ ({ tmp["self"], tmp["rest"],
                                                            tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["single"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["single"][0]["arguments"]);
            if (!ret[fluff[i]][SINGLE]) {
               ret[fluff[i]][SINGLE] = ({ 0, allocate(j*SMALL_ARG_SIZE) });
            } else {
               ret[fluff[i]][SINGLE][ARGUMENTS] = allocate(j*SMALL_ARG_SIZE);
            }
            for (j=0;j<sizeof(comms[fluff[i]]["single"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["single"][0]["arguments"][j];
               if (!mapp(tmp)) {
                  notify("The soul command "+fluff[i]+" is totaly stuffed.\n");
                  failed = 1;
               } else if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+POSITION_SINGLE] = tmp["position"];
               }
            }
         }
      }
      if (comms[fluff[i]]["targeted"]) {
         if (comms[fluff[i]]["targeted"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["targeted"][0]["no-arguments"][0];
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][TARGET] = ({ ({ tmp["self"], tmp["rest"],
                                     tmp["target"], 0, tmp["force"], tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["targeted"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);
            if (!ret[fluff[i]][TARGET])
               ret[fluff[i]][TARGET] = ({ 0, allocate(j*ARG_SIZE) });
            else
               ret[fluff[i]][TARGET][ARGUMENTS] = allocate(j*ARG_SIZE);
            for (j=0;j<sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["targeted"][0]["arguments"][j];
               if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+TARG] = tmp["target"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+FORCE] = tmp["force"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+POSITION] = tmp["position"];
               }
            }
         }
      }
   }
   fluff = keys(ret);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]][PATTERNS] = sort_patterns(ret[fluff[i]][PATTERNS]);
      SOUL_OBJECT->add_soul_command(fluff[i], ret[fluff[i]]);
      notify("Added soul command "+fluff[i]+".\n");
   }
}
void blue() {
   printf("%O\n", sort_patterns(({ "[at] <indirect:object>", "<string>" })));
}

==================================================
FILE: handlers/start_positions.c
==================================================

#include <login_handler.h>
#define SAVE_FILE "/save/start_position_handler"
#define CHECKED_PROP "checked start positions"
private int _last_added;
private string * _buggy_starts;
void load_file() {
   if ( file_size( SAVE_FILE + ".o" ) > 0 ||
        file_size( SAVE_FILE + ".o.gz" ) > 0 )
   {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
}
void save_file() {
   unguarded( (: save_object, SAVE_FILE :) );
}
void create() {
   _last_added = 0;
   _buggy_starts = ({ });
   load_file();
   if ( !_buggy_starts ) {
      _buggy_starts = ({ });
   }
}
int add_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );
   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }
   if ( member_array( fname, _buggy_starts ) != -1 ) {
      return -1;
   }
   _buggy_starts += ({ fname });
   _last_added = time();
   save_file();
   return 1;
}
int delete_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );
   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }
   if ( member_array( fname, _buggy_starts ) == -1 ) {
      return -1;
   }
   _buggy_starts -= ({ fname });
   save_file();
   return 1;
}
string * list_buggy_starts() {
   return copy( _buggy_starts );
}
void remove_buggy_starts( object player ) {
   string * starts;
   if ( !player ) {
      return;
   }
   starts = copy( player->query_starts() );
   for( int i = 0; i < sizeof( starts ); i += 2 ) {
      if ( member_array( starts[i], _buggy_starts ) != -1 ) {
         player->remove_start( starts[i] );
      }
   }
   player->add_property( CHECKED_PROP, time() );
}
void login_callback( string player, string type ) {
   object playerob;
   if ( !player ||
        !type ||
        type != LOGIN )
   {
      return;
   }
   player = lower_case( player );
   if ( !( playerob =  find_player( player ) ) ||
        ( playerob->query_property( CHECKED_PROP ) >= _last_added ) )
   {
      return;
   }
   remove_buggy_starts( playerob );
}
void dest_me() {
   destruct( this_object() );
}

==================================================
FILE: handlers/state_change.c
==================================================

#include <state_change.h>
#define PROP "state name"
#define DATA_DIR "/obj/state_change/"
mapping table = ([ ]);
void set_amount_of_ob( object ob, int amount );
mixed query_table() { return table; }
void create() {
    string *files;
    int i;
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    files = ({ "base.hdr" });
    files += get_dir(DATA_DIR + "*.dat");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = DATA_DIR + files[i];
    }
    table += "/obj/handlers/data"->compile_data(files);
}
varargs object transform( object ob, string transformation, object player ) {
    string index, name;
    object ret;
    class state_change c;
    function f;
    int *weight_unit;
    if (!stringp(name = ob->query_property(PROP)))
      if (!stringp(name = ob->query_medium_alias()))
        name = ob->short();
    if ( !player )
      player = this_player();
    index = transformation + ":" + name;
    if (undefinedp(table[index]))
      return 0;
    c = table[index];
    ret = clone_object(c->result);
    foreach (f in c->func)
      evaluate(f, ob, ret, player);
    if (ret->query_continuous()) {
        if ( ob->query_continuous() || ob->query_collective() ) {
            ret->set_amount(to_int(ob->query_amount() * c->factor));
        } else {
            weight_unit = ret->query_weight_unit();
            set_amount_of_ob( ret, to_int( ob->query_weight() * c->factor *
              weight_unit[1] / weight_unit[0] ) );
        }
    } else {
        if ( ob->query_continuous() || ob->query_collective() ) {
            weight_unit = ob->query_weight_unit();
            ret->set_weight(to_int(ob->query_amount() * c->factor *
                                   weight_unit[0] / weight_unit[1]));
        } else {
            ret->set_weight(to_int(ob->query_weight() * c->factor));
        }
    }
    log_file( "STATE_CHANGE", "Changed %d amount of %s to %d amount of %s via %s.\n",
      ob->query_amount(), ob->query_medium_alias(), ret->query_amount(),
      ret->query_medium_alias(), transformation );
    return ret;
}
void set_amount_of_ob( object ob, int amount ) {
  if ( !ob )
      return;
  if ( !amount )
      ob->dest_me();
  ob->set_amount( amount );
  return;
}

==================================================
FILE: handlers/taskmaster.c
==================================================

#include <tasks.h>
#define TIME_PER_USER 1800
#define SAVE_FILES "/save/tasks/"
#define LOG_STATS 2
#undef LOGGING
mapping stats;
nosave int last_save;
nosave int last;
nosave string skill;
nosave mixed *control;
nosave int * critical_chances;
varargs mixed perform_task( object person, string skill, int difficulty,
                         int tm_type, int degree );
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree );
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree );
int is_critical( int margin );
void create() {
   float a, b;
   seteuid( "Root" );
   critical_chances = allocate(100);
   a = 0.93260;
   b = 0.06978;
   for( int i = 0; i < 100; i++ ) {
      critical_chances[i] = a * exp( b * ( i + 1 ) );
   }
}
mapping query_stats( string s_name ) {
  if ( skill != s_name ) {
    skill = s_name;
    if ( file_size( SAVE_FILES + skill +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILES + skill :) );
    else
      stats = 0;
  }
  if ( !stats )
    stats = ([ ]);
  return copy( stats );
}
int query_last() { return last; }
mixed *query_control() { return control; }
void set_control( mixed *args ) { control = args; }
void reset_control() { control = 0; }
void award_made( string p_name, string o_name, string s_name, int level ) {
  user_event( "inform", p_name +" gains a level in "+ s_name +" from "+
              o_name + " at level " + level, "skill" );
#ifdef LOG_STATS
#if LOG_STATS == 1
  query_stats( s_name );
  if ( !stats[ level ] )
    stats[ level ] = ([ ]);
  stats[ level ][ explode( o_name, "#" )[ 0 ] ]++;
#else
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({ 0 , 0 }),  ({ 0, 0 }),  ({ 0, 0 }) , ({0,0})});
  switch(level) {
  case 0..149:
    stats[s_name][0] = ({ stats[s_name][0][0], stats[s_name][0][1]+1 });
    break;
  case 150..299:
    stats[s_name][1] = ({ stats[s_name][1][0], stats[s_name][1][1]+1 });
    break;
  case 300..599:
    stats[s_name][2] = ({ stats[s_name][2][0], stats[s_name][2][1]+1 });
    break;
  default:
    stats[s_name][3] = ({ stats[s_name][3][0], stats[s_name][3][1]+1 });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
#endif
#endif
}
#if LOG_STATS == 2
void skill_checked(string s_name, int level) {
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({0,0}), ({0,0}), ({0,0}), ({0,0}), ({0,0}) });
  switch(level) {
  case 0..49:
    stats[s_name][0] = ({ stats[s_name][0][0]+1, stats[s_name][0][1] });
    break;
  case 50..149:
    stats[s_name][1] = ({ stats[s_name][1][0]+1, stats[s_name][1][1] });
    break;
  case 150..299:
    stats[s_name][2] = ({ stats[s_name][2][0]+1, stats[s_name][2][1] });
    break;
  case 300..599:
    stats[s_name][3] = ({ stats[s_name][3][0]+1, stats[s_name][3][1] });
    break;
  default:
    stats[s_name][4] = ({ stats[s_name][4][0]+1, stats[s_name][4][1] });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
}
#endif
string *query_skill_files() {
  return unguarded( (: get_dir, SAVE_FILES +"*.o" :) );
}
void clear_skill_files() {
  string word;
  foreach ( word in unguarded( (: get_dir, SAVE_FILES +"*.o" :) ) )
    unguarded( (: rm, SAVE_FILES + word :) );
  skill = 0;
}
varargs mixed compare_skills( object offob, string offskill,
                              object defob, string defskill,
                              int modifier, int off_tm_type,
                              int def_tm_type, int degree )
{
  int offbonus, defbonus;
  int perc, chance;
  int success_margin, res, deg;
  if( !offob || !defob || !offskill || !defskill )
    return BARF;
  offbonus = offob->query_skill_bonus(offskill);
  defbonus = defob->query_skill_bonus(defskill);
  if( !defbonus ) {
    defbonus = 1;
  }
  if( !offbonus ) {
    offbonus = 1;
  }
  (offbonus > defbonus) ?
    perc = (50 * offbonus * offbonus) / (offbonus * defbonus) :
    perc = 100 - (50 * defbonus * defbonus) / (offbonus * defbonus);
  perc += modifier;
  if(perc > 99)
    perc = 99;
  if(perc < 1)
    perc = 1;
  chance = random(100);
  success_margin = perc - chance;
  if( success_margin > 0 ) {
    switch( perform_task( offob, offskill, defbonus-modifier,
                          off_tm_type, 0 ) )
    {
    case AWARD:
      res = OFFAWARD;
      break;
    default:
      res = OFFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  } else {
    switch( perform_task( defob, defskill, offbonus-modifier,
                          def_tm_type, 0 ) ) {
    case AWARD:
      res = DEFAWARD;
      break;
    default:
      res = DEFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( -success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( -success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  }
}
varargs mixed perform_task( object person, string skill, int difficulty,
                            int tm_type, int degree ) {
  mixed result;
  int bonus, upper;
  if( !person || !skill )
    return BARF;
  bonus = person->query_skill_bonus( skill );
  switch(tm_type) {
  case TM_FIXED:
    result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_FREE:
    result = attempt_task( difficulty, bonus, 25, 0, degree );
    break;
  case TM_CONTINUOUS:
    result = attempt_task( difficulty, bonus, 50, 0, degree );
    break;
  case TM_COMMAND:
    if( explode( skill, "." )[0] == "covert" )
      result = attempt_task_e
  ( difficulty, bonus, 60, 40, degree );
    else
      result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_RITUAL:
    result = attempt_task_e( difficulty, bonus, 50, 25, degree );
    break;
  case TM_SPELL:
    result = attempt_task_e( difficulty, bonus, 60, 40, degree );
    break;
  case TM_NONE:
    result = attempt_task_e(difficulty, bonus, 1, 0, degree);
    if(classp(result) && ( (class tasker_result)result )->result == AWARD) {
      result->result = SUCCEED;
    } else if( result == AWARD ) {
      result = SUCCEED;
    }
    break;
  default:
#ifdef LOGGING
    if(file_name(previous_object())[0..2] != "/w/")
      log_file("ATTEMPT_TASK",
               "%s Object %s using old perform_task [%d, %d]\n",
               ctime(time()), base_name(previous_object()), tm_type, degree );
#endif
    upper = tm_type;
    if ( !upper )
      upper = 100;
    result = attempt_task( difficulty, bonus, upper, 0, degree );
  }
  if(classp(result) && ( (class tasker_result)result )->result == AWARD ||
     result == AWARD) {
    if(person->advancement_restriction() ||
       !person->add_skill_level(skill, 1, previous_object())) {
      if(classp(result))
        result->result = SUCCEED;
      else
        result = SUCCEED;
    }
  }
  return result;
}
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree )
{
   int margin, success_margin, deg, res;
   float tmp;
#ifdef LOGGING
   if( call_stack(2)[1] != "perform_task" &&
       base_name( previous_object() ) != "/std/effects/fighting/combat" &&
       file_name( previous_object() )[0..2] != "/w/" )
   {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime( time() ), base_name( previous_object() ), call_stack(2) );
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
      skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
#ifdef DEBUG
      if(pointerp(control) && control[0]->query_name() == WATCH_PLAYER &&
         find_player(DEBUG))
      {
         tell_creator( DEBUG, "%^RED%^"
           + sprintf( "TM: %s Skill: %s [%d] [%d] Failed\n",
                      control[0]->query_name(), control[1], bonus, difficulty )
           + "%^RESET%^" );
      }
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if ( !extra )
      margin = 3 * sqrt( difficulty );
   else {
      if ( intp( extra ) )
         margin = extra;
      if ( pointerp( extra ) )
         margin = extra[ 0 ] + extra[ 1 ] * sqrt( difficulty );
   }
   if ( !margin )
      return BARF;
   if ( bonus > difficulty + margin ) {
#ifdef DEBUG
     if(pointerp(control) &&
        WATCH_PLAYER || control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] [%d] Succeeded\n", control[0]->query_name(), control[1], bonus, difficulty, margin) + "%^RESET%^");
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : SUCCEED,
                     degree : ( is_critical(100) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : 100 );
      } else {
         return SUCCEED;
      }
   }
   if(!margin)
     margin = 1;
   success_margin = ( ( 100 * ( bonus - difficulty ) ) / margin ) - random(100);
   if ( success_margin <= 0 ) {
#ifdef DEBUG
     if(pointerp(control) &&
        control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] Failed (2)\n", control[0]->query_name(), control[1], bonus, difficulty) + "%^RESET%^");
#endif
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify(upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
#ifdef DEBUG
   else
     if(find_player(DEBUG))
       tell_object(find_player(DEBUG), sprintf("No control: %O\n",
                                                 previous_object(-1)));
#endif
     if(!margin)
        margin = 1;
   if( random(100) < ( upper * ( difficulty + margin - bonus ) ) / margin )
      res = AWARD;
   else
      res = SUCCEED;
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree )
{
   float fail_chance;
   float tmp;
   int success_margin, deg, res;
#ifdef LOGGING
   if(call_stack(2)[1] != "perform_task" &&
      base_name(previous_object()) != "/std/effects/fighting/combat" &&
      file_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime(time()), base_name(previous_object()), call_stack(2));
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
     skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if( !half )
      half = 6 * sqrt( difficulty );
   if( !half )
      half = 1;
   fail_chance = exp( ( -0.693 * ( bonus - difficulty ) ) / half );
   success_margin = ( random( 1000 ) - ( 1000 * fail_chance ) ) / 10;
   if ( success_margin < 0 ) {
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify( upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - E_MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
   if ( random(1000) < ( upper * fail_chance * 10 )
    &&  bonus < difficulty + ( half * 5 ) ) {
      res = AWARD;
   } else {
      res = SUCCEED;
   }
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
int is_critical( int margin ) {
   if ( margin < 0 ) {
      margin *= -1;
   }
   if ( margin > 100 ) {
      margin = 100;
   }
   if ( margin == 0 ) {
      return 0;
   }
   return random(10000) < critical_chances[ margin - 1 ];
}

==================================================
FILE: handlers/team.c
==================================================

#define CREATOR "Ceres"
#include <login_handler.h>
#define SHADOW "/std/shadows/misc/team"
#define MAX_GROUP_SIZE 5
class group {
  object leader;
  int policy;
  object *members;
  int locked;
}
mapping groups,
        members;
private void check_group(string g_name);
private void disband_group(string g_name, string p_name);
private void tidy_members(string g_name);
void create() {
  members = ([ ]);
  groups = ([ ]);
}
void dest_me() {
  destruct(this_object());
}
void leaving(string p_name, string type) {
  class group record;
  string g_name;
  if((type != "logout") || (!members[p_name]))
    return;
  g_name = members[p_name];
  record = (class group)groups[g_name];
  map_delete(members, p_name);
  if(!record)
    return;
  if((record->leader == 0) || ((record->leader)->query_name() == p_name)) {
     disband_group(g_name, p_name);
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s has left the game, the %s has been "
                             "disbanded.\n", ctime(time()), p_name, g_name));
#endif
  } else {
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left the game while a member of the %s\n",
                             ctime(time()), p_name, g_name));
#endif
    record->members = delete(record->members,
                             member_array(0, record->members), 1);
  }
  return;
}
int new_group(string g_name, object leader, int policy) {
  class group record;
  if(!undefinedp(groups[g_name]))
    return 0;
  record = new(class group);
  record->leader = leader;
  record->policy = policy;
  record->members = ({ leader });
  groups[g_name] = record;
  members[leader->query_name()] = g_name;
  leader->set_title( "TEAM", "Team Leader of "+ g_name );
   clone_object( SHADOW )->setup_shadow( leader );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s created by %s\n", ctime(time()),
                           g_name, leader->query_name()));
#endif
  return 1;
}
int end_group(string g_name) {
  class group record;
  object player;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
   foreach( player in record->members )
      if ( player ) {
         map_delete( members, player->query_name() );
         player->remove_title( "TEAM" );
         player->destruct_team_shadow();
      }
  map_delete(groups, g_name);
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s disbanded\n", ctime(time()), g_name));
#endif
  return 1;
}
int join_group(string g_name, object player) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  record->members += ({ player });
  members[player->query_name()] = g_name;
   player->set_title( "TEAM", "Team Member of "+ g_name );
   clone_object( SHADOW )->setup_shadow( player );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s joined by %s\n", ctime(time()),
                           g_name, player->query_name()));
#endif
  return 1;
}
int leave_group(string g_name, object player) {
  class group record;
  if(player) {
    map_delete(members, player->query_name());
      player->remove_title( "TEAM" );
      player->destruct_team_shadow();
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left by %s\n", ctime(time()), g_name,
                             player->query_name()));
#endif
  }
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  if(member_array(player, record->members) == -1)
    return -1;
  record->members = delete(record->members,
                           member_array(player, record->members), 1);
  return 1;
}
object query_owner(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return record->leader;
}
object *query_members(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = groups[g_name];
  return (object *)record->members;
}
int query_policy(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  return (int)record->policy;
}
string query_group(object player) {
  if(undefinedp(members[player->query_name()]))
    return 0;
  return members[player->query_name()];
}
int test_group(string g_name) {
  if(undefinedp(groups[g_name]))
    return 0;
  return 1;
}
int query_full(string g_name) {
  class group record;
  object member;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = (class group)groups[g_name];
  if(sizeof(record->members) >= MAX_GROUP_SIZE)
    return 1;
  return 0;
}
int query_locked(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return (record->locked);
}
int set_locked(string g_name, int lock) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  record->locked = lock;
  return 1;
}
string *list_groups() {
  string frog;
  foreach (frog in keys(groups)) {
    check_group(frog);
  }
  return keys(groups);
}
private void disband_group(string g_name, string p_name) {
  class group record;
  object person;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members) {
    if(!member)
      break;
    map_delete(members, member->query_name());
    foreach(person in member->query_protectors())
      member->remove_protector(person);
    foreach(person in member->query_followers())
      member->remove_follower(person);
    tell_object(member, p_name+" has left the game and so the "+g_name+
                " has been disbanded.\n");
  }
  map_delete(groups, g_name);
}
private void check_group(string g_name) {
  class group record;
  record = (class group)groups[g_name];
  if (record->leader == 0) {
    disband_group(g_name, "Your leader");
  } else {
    record->members -= ({ 0 });
  }
}
private void tidy_members(string g_name) {
  class group record;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members)
    if(!member)
      record->members -= ({ 0 });
}

==================================================
FILE: handlers/term.c
==================================================

#define ANSI(p) sprintf("%c["+(p)+"m", 27)
#define ESC(p) sprintf("%c"+(p), 27)
#define CHAR(p) sprintf("%c", (p))
#define TERMINAL_DUMB "dumb"
private nosave mapping aliases, terms;
void create() {
  aliases = ([ "xterm-debian" : "xterm",
               "zmud" : "vt220",
               "amiga" : "vt220",
               "linux" : "vt220",
               "xterm-color" : "xterm",
               "vt102" : "vt100",
               "dec-vt100" : "vt100",
               "vt300" : "vt220",
               "vt100a" : "vt100",
               "vt100-ansi" : "vt100",
               "dec-vt220" : "vt220",
               "vt400" : "vt220",
               "vs100" : "xterm",
               "sun-cmd" : "vt220-nc",
               "unknown" : TERMINAL_DUMB,
               "ibm" : TERMINAL_DUMB,
               "iris-ansi-net" : "vt220",
               "network" : TERMINAL_DUMB,
               "vt320" : "vt220",
               "dtterm" : "vt220",
               "screen" : "vt220",
               "dec-vt320" : "vt220",
               "dec-vt100i" : "vt100",
               "ansii" : "ansi",
               "vt100i" : "vt100",
               "vt200-80" : "vt220",
               "ibm-3279-2-e" : TERMINAL_DUMB,
               "ibm-3279-2" : TERMINAL_DUMB,
               "vt200" : "vt220",
               "dec-vt200" : "vt220",
               "hft" : "vt220",
               "mac" : "vt220-nc",
               "vt340" : "vt220",
               "vt340-am" : "vt220",
               "ibm-3278-2" : TERMINAL_DUMB,
               "ibm-3278-2-e" : TERMINAL_DUMB,
               "kterm" : "xterm",
               "sun" : "vt220-nc",
               "sun1" : "vt220-nc",
               "xterms" : "xterm",
               "vs100s" : "xterm",
               "vt52" : TERMINAL_DUMB,
               "vt420" : "vt220",
               "dec-vt420" : "vt220",
               "aixterm-m" : "aixterm",
               "ibm-3151" : "ibm3151",
               "ibm-3278-5" : TERMINAL_DUMB,
               "du" : TERMINAL_DUMB,
               "dialup" : TERMINAL_DUMB,
               "dec-vt52" : TERMINAL_DUMB,
               "vt100-pro" : "vt100",
            ]);
  terms = ([ TERMINAL_DUMB : ([ "RESET" : "",
                         "BOLD" : "",
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "GREEN" : "",
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": "",
                         "UNDERLINE": "",
                         "%" : "%^",
                         ]),
             "ansi" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "ansi-no-flash" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "freedom" : ([ "RESET" : ESC("G0"),
                         "BOLD" : ESC("G@"),
                         "FLASH" : ESC("G2"),
                         "BLACK" : "",
                         "RED" : "",
                         "GREEN" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "BLACK" : "",
                         "WHITE" : "",
                         "B_RED" : ESC("GD"),
                         "B_GREEN" : ESC("GD"),
                         "B_ORANGE" : ESC("G4"),
                         "B_YELLOW" : ESC("G4"),
                         "B_BLUE" : ESC("G4"),
                         "B_CYAN" : ESC("GD"),
                         "B_BLACK" : ESC("GD"),
                         "B_WHITE" : ESC("G4"),
                         "B_MAGENTA" : ESC("G4"),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("G4"),
                         "UNDERLINE" : ESC("G8"),
                         "%" : "%^",
                         ]),
             "ansi-status": ([
                         "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS" : ESC("[23;24r") + ESC(8),
                         "WINDOW" : ESC(7)+ESC("[0;22r")+ESC("[22H\n"),
                         "INITTERM" : ESC("[H")+ESC("[J")+
                                      ESC("[23;24r")+ESC("23H\n"),
                         "ENDTERM" : ESC("[0r")+ESC("[H")+ESC("[J"),
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "xterm": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100" : (["RESET" : ANSI("39;49")+ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "hpterm" : (["RESET" : ESC("&v0S")+ESC("&d@"),
                         "BOLD" : ESC("&dB"),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ESC("&dB"),
                         "GREEN" : ESC("&dD"),
                         "ORANGE" : "",
                         "YELLOW" : ESC("&dB"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "WHITE" : "",
                         "B_RED" : "",
                         "B_GREEN" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLUE" : "",
                         "B_CYAN" : "",
                         "B_BLACK" : "",
                         "B_WHITE" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("&dB"),
                         "UNDERLINE" : ESC("&dD"),
                         "%" : "%^",
                         ]),
           "aixterm" : ([ "RESET" : ANSI("0;10")+ESC("(B"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ANSI(1),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC('p'),
                         "GREEN" : ESC('W'),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC('p'),
                         "UNDERLINE": ESC('W'),
                         "%" : "%^",
                         ]),
           "ibm3151" : ([ "RESET" : ESC("4@"),
                         "BOLD" : ESC("4H"),
                         "FLASH" : ESC("4D"),
                         "BLACK" : "",
                         "RED" : ESC("4H"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC("4A"),
                         "GREEN" : ESC("4B"),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC("4A"),
                         "UNDERLINE": ESC("4B"),
                         "%" : "%^",
                         ]),
             "vt220": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100-nc" : ([ "RESET" : ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI(37),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt220-nc" : ([ "RESET" : ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI("7;4"),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
          ]);
}
mixed set_network_term_type(string str) {
  string type;
  str = lower_case(str);
  if (!terms[str] && !(type = aliases[str])) {
#ifdef DEBUG
    log_file("TERMTYPES", "No entry for \"%s\" (%s).\n", str,
             this_player()->query_name());
#endif
    return 0;
  }
  if (type) {
     return terms[type];
  }
  return terms[str];
}
mapping set_term_type(string str) {
  if (!terms[str] && !(str = aliases[str])) {
    efun::tell_object(this_player(), "No entry for "+str+", using dumb.\n");
    str = TERMINAL_DUMB;
  }
  return terms[str];
}
string *query_term_types() {
  return m_indices(terms);
}
string *query_colour_codes() {
   return keys(terms[TERMINAL_DUMB]);
}

==================================================
FILE: handlers/terrain_handler.c
==================================================

#include <dirs.h>
#include <terrain.h>
#include <map.h>
#undef DEBUG_ROOM_SIZE
#undef DEBUG_CALC_EXITS
#define TP(x) tell_object(find_player("taffyd"), x);
#define BACKUP_TIME_OUT 1000000
inherit "/std/object";
string terrain_name;
mapping fixed_locations;
mixed *floating_locations;
private nosave int in_map;
private nosave mapping size_cache, cloned_locations, float_cache;
private nosave mapping std_types = ([ "north" : "path", "south" : "path",
  "east" : "path", "west" : "path", "northeast" : "hidden",
  "southwest" : "hidden", "southeast" : "hidden",
  "northwest" : "hidden", "up" : "stair", "down" : "stair" ]);
void setup() {
  size_cache = ([ ]);
  cloned_locations = ([ ]);
  float_cache = ([ ]);
  set_name("map");
  set_short("terrain map");
  add_adjective("terrain");
  set_long("This is a large map showing a large expanse of forest, desert, "
           "mountain or ocean.  A few locations of interest are marked on "
           "it, with most of the gaps between them blank or marked "
           "\"Here bee Draggons\" and the like, suggesting that the map-"
           "maker didn't know what was there either.\n" );
  add_adjective("terrain");
}
string member_cloned_locations(int *co_ords) {
  mapping tmp;
  if ((tmp = cloned_locations[terrain_name]) && (tmp = tmp[co_ords[0]]) &&
      (tmp = tmp[co_ords[1]])) {
      return tmp[co_ords[2]];
  }
  return 0;
}
string member_fixed_locations(int *co_ords) {
  int *loc_co_ords;
  string location;
  foreach (location, loc_co_ords in fixed_locations) {
    if ((co_ords[0] == loc_co_ords[0]) && (co_ords[1] == loc_co_ords[1]) &&
        (co_ords[2] == loc_co_ords[2])) {
      return location;
    }
  }
  return 0;
}
private int between(int limit1, int val, int limit2)
{
  if (limit1 < limit2) {
    return ((limit1 <= val) && (val <= limit2));
  } else {
    return ((limit2 <= val) && (val <= limit1));
  }
}
mixed *member_floating_locations(int *co_ords) {
  int *data;
  mixed *right_locations, *location;
  right_locations = ({ });
  foreach (location in floating_locations) {
    data = location[1];
    if (sizeof(data) == 6) {
      if (between(data[0], co_ords[0], data[3]) &&
          between(data[1], co_ords[1], data[4]) &&
          between(data[2], co_ords[2], data[5])) {
        right_locations += ({ location[0], location[2] });
      }
    } else {
      if ((co_ords[0] == data[0]) && (co_ords[1] == data[1]) &&
          (co_ords[2] == data[2])) {
        right_locations += ({ location[0], location[2] });
      }
    }
  }
  return right_locations;
}
string top_floating_location(int *co_ords) {
  int i, highest_level;
  string highest_location;
  mixed *right_locations;
  right_locations = member_floating_locations(co_ords);
  if (!sizeof(right_locations))
    return 0;
  highest_level = right_locations[1];
  highest_location = right_locations[0];
  for (i = 0; i < sizeof(right_locations); i += 2) {
    if (right_locations[i + 1] > highest_level) {
      highest_level = right_locations[i + 1];
      highest_location = right_locations[i];
    }
  }
  if (highest_location == "nothing")
    return 0;
  return highest_location;
}
private void init_data(string word) {
  terrain_name = word;
  fixed_locations = ([ ]);
  floating_locations = ({ });
}
int get_data_file(string word) {
  if (terrain_name != word) {
    if (file_size(RESTORE_PATH + word + ".o") > 0) {
      unguarded((: restore_object, RESTORE_PATH + word :));
    } else {
      init_data(word);
      return 0;
    }
  }
  return 1;
}
private void save_data_file(string word) {
  int number, last;
  string line, *lines;
  if (file_size(RESTORE_PATH + word +".o") > 0) {
    unguarded((: rename, RESTORE_PATH + word +".o",
               RESTORE_PATH +"backups/"+ word +"."+ time() :));
    lines = unguarded((: get_dir, RESTORE_PATH +"backups/"+ word +".*" :));
    if (sizeof(lines) > 3) {
      last = time() - BACKUP_TIME_OUT;
      foreach(line in lines) {
        sscanf(line, word +".%d", number);
        if (number < last)
          unguarded((: rm, RESTORE_PATH +"backups/"+ line :));
      }
    }
  }
  unguarded((: save_object, RESTORE_PATH + word :));
}
mapping query_cloned_locations(string terrain) {
  return cloned_locations[terrain];
}
mapping query_fixed_locations(string word) {
  get_data_file(word);
  return fixed_locations;
}
mixed *query_floating_locations(string word) {
  get_data_file(word);
  return floating_locations;
}
int *query_co_ord(string terrain, string file) {
  get_data_file(terrain);
  return fixed_locations[file];
}
string query_connection(string terrain, int *co_ords, string direc) {
  mapping connection_info, tmp;
  string connections;
  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && (tmp = tmp[co_ords[2]])) {
    return tmp[direc];
  }
  return 0;
}
int query_connected(string terrain, int *co_ords) {
  mapping connection_info, tmp;
  string connections;
  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && tmp[co_ords[2]]) {
    return 1;
  }
  return 0;
}
int add_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
}
private int add_connection(string terrain, int *co_ords, string direc,
                           string file) {
  mapping connection_info, tmp;
  string connections;
  if (!query_connection(terrain, co_ords, direc)) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      unguarded((: mkdir, RESTORE_PATH + terrain :));
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      connection_info = ([ co_ords[1] : ([ co_ords[2] : ([ direc : file ]) ])
                        ]);
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    } else {
      connections = unguarded((: read_file,
                                 RESTORE_PATH + terrain +"/"+ co_ords[0] :));
      connection_info = restore_variable(connections);
      if ((tmp = connection_info[co_ords[1]])) {
        if ((tmp = tmp[co_ords[2]])) {
          tmp[direc] = file;
        } else {
          connection_info[co_ords[1]][co_ords[2]] = ([ direc : file ]);
        }
      } else {
        connection_info[co_ords[1]] = ([ co_ords[2] : ([ direc : file ]) ]);
      }
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    }
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
}
int add_floating_location(string terrain, string file, int *co_ords,
                          int level) {
  get_data_file(terrain);
  if ((sizeof(co_ords) != 6) && (sizeof(co_ords) != 3)) {
    return 0;
  }
  if (member_array(({ file, co_ords, level }), floating_locations) != -1) {
    return 0;
  }
  floating_locations += ({ ({ file, co_ords, level }) });
  save_data_file(terrain_name);
  return 1;
}
private void add_cloned_location(string terrain, string file, int *co_ords) {
  mapping tmp, location_m;
  if (!(location_m = cloned_locations[terrain])) {
    cloned_locations[terrain] = ([ file : co_ords,
                                   co_ords[0] : ([ co_ords[1] :
                                                   ([ co_ords[2] : file ]) ])
                                ]);
  } else {
    location_m[file] = co_ords;
    if ((tmp = location_m[co_ords[0]])) {
      if ((tmp = tmp[co_ords[1]])) {
        tmp[co_ords[2]] = file;
      } else {
        location_m[co_ords[0]][co_ords[1]] = ([ co_ords[2] : file ]);
      }
    } else {
      location_m[co_ords[0]] = ([ co_ords[1] : ([ co_ords[2] : file ]) ]);
    }
  }
}
int modify_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
}
int delete_cloned_location(string terrain, string file) {
  int *co_ords;
  mapping tmp, location_m;
  if (!((location_m = cloned_locations[terrain]) &&
        (co_ords = location_m[file]))) {
    return 0;
  }
  map_delete(location_m, file);
  tmp = location_m[co_ords[0]][co_ords[1]];
  map_delete(tmp, co_ords[2]);
  if (!sizeof(tmp)) {
    tmp = location_m[co_ords[0]];
    map_delete(tmp, co_ords[1]);
    if (!sizeof(tmp)) {
      map_delete(location_m, co_ords[0]);
      if (!sizeof(location_m)) {
        map_delete(cloned_locations, terrain);
      }
    }
  }
  return 1;
}
int delete_fixed_location(string terrain, string file) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  map_delete(fixed_locations, file);
  save_data_file(terrain_name);
  return 1;
}
int delete_floating_location(string terrain, string file, int *co_ords) {
  int i, j, flag_d, flag_m, *data;
  get_data_file(terrain);
  for (i = 0; i < sizeof(floating_locations); i++) {
    if (floating_locations[i][0] == file) {
      data = floating_locations[i][1];
      if (sizeof(data) != sizeof(co_ords)) {
        continue;
      }
      flag_m = 0;
      for (j = 0; j < sizeof(data); j++) {
        if (data[j] != co_ords[j]) {
          flag_m = 1;
          break;
        }
        if (!flag_m) {
          floating_locations = delete(floating_locations, i, 1);
          flag_d = 1;
        }
      }
    }
  }
  save_data_file(terrain_name);
  return flag_d;
}
void clear_cloned_locations(string terrain) {
  map_delete(cloned_locations, terrain);
}
void clear_connections(string terrain) {
  string line, *lines;
  if (file_size(RESTORE_PATH + terrain) != -2) {
    return;
  }
  lines = unguarded((: get_dir, RESTORE_PATH + terrain +"
private int right_co_ords(int *new_co_ords, int *co_ords, int delta,
                          int *vector) {
  int i;
  for (i = 0; i < 3; i++) {
    if (new_co_ords[i] + delta * vector[i] != co_ords[i]) {
      return 0;
    }
  }
  return 1;
}
int get_room_size(string file, int level) {
  int i, number, roomsize, *mapsize;
  string bname, parent, *lines;
  bname = base_name(file);
  if (size_cache[bname]) {
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (cached) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }
  if (find_object(file)) {
    size_cache += ([ bname : file->query_room_size() ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (loaded) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }
  if (!in_map) {
    in_map = 1;
    mapsize = MAP_HANDLER->query_room_size(bname);
    in_map = 0;
  } else {
#ifdef DEBUG_ROOM_SIZE
    TP("GRS says recursion!\n");
#endif
    mapsize = 0;
  }
  if (mapsize) {
    size_cache += ([ bname : mapsize[0] ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (map) %s is %d\n", file, size_cache[bname]));
#endif
    return mapsize[0];
  }
  file = bname + ".c";
  if (file_size(file) < 0) {
    return 10;
  }
  lines = explode(read_file(file), "\n");
  roomsize = 10;
  for (i = 0; i < sizeof(lines); i++) {
    if (level < 4 &&
        sscanf(lines[i], "%*sinherit%*s\"%s\"%*s;", parent) == 4) {
      if (parent[<2..] != ".c") {
        parent += ".c";
      }
      roomsize = get_room_size(parent, level + 1);
    } else if (sscanf(lines[i], "%*sset_room_size(%*s%d%*s", number) == 4) {
      roomsize = number;
      break;
    }
  }
  size_cache += ([ bname : roomsize ]);
#ifdef DEBUG_ROOM_SIZE
  TP(sprintf("GRS says (parsed) %s is %d\n", file, size_cache[bname]));
#endif
  return roomsize;
}
private void add_exit(object place, string direc, string dest) {
  string type;
  type = (string)place->query_exit_type(direc, dest);
  if (!type) {
    type = std_types[direc];
  } else {
    if (type == "none") {
      return;
    }
  }
  place->add_exit(direc, dest, type);
}
private void calculate_exits(object place, int *co_ords) {
  int i, j, k, connected, delta, *new_co_ords;
  string actual, *exit_dirs;
  connected = query_connected(terrain_name, co_ords);
  exit_dirs = (string *)place->query_direc();
  for (i = 0; i < 20; i += 2) {
    if (member_array(STD_ORDERS[i], exit_dirs) != -1) {
      continue;
    }
    actual = query_connection(terrain_name, co_ords, STD_ORDERS[i]);
    if (actual) {
#ifdef DEBUG_CALC_EXITS
      TP(sprintf("actual room %s found\n", actual));
#endif
      add_exit(place, STD_ORDERS[i], actual);
      continue;
    }
    if (connected) {
#ifdef DEBUG_CALC_EXITS
      TP("connected, but no actual room\n");
#endif
      continue;
    }
    new_co_ords = copy(co_ords);
    for (k = 0; k < 3; k++) {
      new_co_ords[k] -= place->query_room_size() * STD_ORDERS[i+1][k];
    }
    reset_eval_cost();
    for (j = 0; j < 100; j++) {
      for (k = 0; k < 3; k++) {
        new_co_ords[k] -= 5 * STD_ORDERS[i+1][k];
      }
      if ((actual = member_fixed_locations(new_co_ords)) ||
          (actual = member_cloned_locations(new_co_ords)) ||
          (actual = top_floating_location(new_co_ords))) {
        delta = (int)place->query_room_size() + get_room_size(actual, 0);
        if (!right_co_ords(new_co_ords, co_ords, delta, STD_ORDERS[i+1])) {
          continue;
        }
#ifdef DEBUG_CALC_EXITS
        TP(sprintf("adding connection for %s\n", actual));
#endif
        add_connection(terrain_name, co_ords, STD_ORDERS[i],
                       base_name(actual));
        add_exit(place, STD_ORDERS[i], actual);
        break;
      }
    }
  }
}
object find_location(string terrain, int *co_ords) {
  string dest_name;
  object destination;
  if (!(get_data_file(terrain)) || (sizeof(co_ords) != 3)) {
    return 0;
  }
  reset_eval_cost();
  if ((dest_name = member_fixed_locations(co_ords))) {
    if (!(destination = find_object(dest_name))) {
      destination = load_object(dest_name);
    }
    return destination;
  }
  if (dest_name = member_cloned_locations(co_ords)) {
    if ((destination = find_object(dest_name))) {
      return destination;
    } else {
      delete_cloned_location(terrain, dest_name);
    }
  }
  if (dest_name = top_floating_location(co_ords)) {
    destination = clone_object(dest_name);
    destination->set_co_ord(co_ords);
    destination->set_terrain(terrain_name);
    calculate_exits(destination, co_ords);
    add_cloned_location(terrain, file_name(destination), co_ords);
    return destination;
  }
  return 0;
}
void setup_location(object place, string terrain) {
  int *co_ords;
  get_data_file(terrain);
  if (!fixed_locations[base_name(place)]) {
    return;
  }
  co_ords = fixed_locations[base_name(place)];
  place->set_co_ord(co_ords);
  calculate_exits(place, co_ords);
}
mixed *stats() {
  return ::stats() + ({
    ({ "roomsize cache size", sizeof(size_cache) }),
      ({ "cloned_locations", sizeof(cloned_locations) }),
        ({ "float_cache", sizeof(float_cache) }),
          ({ "terrain name", terrain_name }),
            ({ "fixed locations", sizeof(fixed_locations) }),
              ({ "floating locations", sizeof(floating_locations) }),
  });
}

==================================================
FILE: handlers/title_handler.c
==================================================

#include <login.h>
private mapping _pending;
private mapping _titles;
private nosave string* _allowed_multiple;
#define SAVE_FILE "/save/titles"
void load_me();
void save_me();
class blob {
   string ob;
   string func;
}
void create() {
   _pending = ([ ]);
   _titles = ([ ]);
   load_me();
   _allowed_multiple = ({ "very reverend", "mostly reverend",
                          "reverend mother", "mad granny",
                          "mad nanny", "mad mr", "mad ms", "mad miss",
                          "mad mrs" });
}
int is_allowed_multiple_title(string title) {
   return member_array(lower_case(title), _allowed_multiple) != -1;
}
string* query_allowed_multiple_titles() {
   return _allowed_multiple;
}
void add_title_to_player(string person, string title) {
   object ob;
   ob = find_player(person);
   if (ob) {
      ob->add_player_title(title);
      return ;
   }
   if (!_pending[person]) {
      _pending[person] = ({ });
   }
   _pending[person] += ({ title });
   save_me();
}
string* query_pending_titles(string person) {
   if (_pending[person]) {
      return _pending[person];
   }
   return ({ });
}
void add_controlled_title(string title, string ob, string func) {
   class blob fluff;
   fluff = new(class blob);
   fluff->ob = ob;
   fluff->func = func;
   _titles[title] = fluff;
   save_me();
}
protected class blob query_controlled_title(string title) {
   return _titles[title];
}
void check_player(object player) {
   string* titles;
   string title;
   if (!player) {
      return ;
   }
   if (_pending[player->query_name()]) {
      foreach (title in _pending[player->query_name()]) {
         player->add_player_title(title);
      }
      map_delete(_pending, player->query_name());
      save_me();
   }
   titles = player->query_all_player_titles();
   foreach (title in titles) {
      if (_titles[title]) {
         if(!find_object(_titles[title]->ob) ||
            !call_other(_titles[title]->ob, _titles[title]->func,
                        player->query_name())) {
           player->remove_player_title(title);
         }
      }
   }
}
void login_handler_call(string person, string type) {
   if (type == LOGIN) {
      call_out((: check_player(find_player($1)) :), 2, person);
   }
}
void save_me() {
   unguarded((: save_object(SAVE_FILE) :));
}
void load_me() {
   unguarded((: restore_object(SAVE_FILE, 1) :));
}

==================================================
FILE: handlers/tokeniser.c
==================================================

#include "tokenise.h"
mapping token;
void create() {
  token = ([
           '+' : TOK_PLUS,
           '-' : TOK_MINUS,
           '*' : TOK_MULT,
           '/' : TOK_DIV,
           '(' : TOK_OBRAC,
           ')' : TOK_CBRAC,
           '{' : TOK_SARRAY,
           '}' : TOK_EARRAY,
           '[' : TOK_SMAPPING,
           ']' : TOK_EMAPPING,
           ':' : TOK_COLON,
           ',' : TOK_COMMA,
           '.' : TOK_DOT,
           '\t' : TOK_TAB,
           '=' : TOK_ASSIGN,
#ifdef BOOLEAN
           '>' : TOK_GREATOR,
           '<' : TOK_LESS,
           "==" : TOK_EQUAL,
           ">=" : TOK_GREATOREQ,
           "<=" : TOK_LESSEQUAL,
#endif
           "->" : TOK_CALL,
           ".." : TOK_DOTDOT,
           ]);
}
mixed tokenise(string inp) {
  string *bits, *cur;
  int pos, num;
  int start_pos;
  cur = ({ });
  while (pos < strlen(inp))
    switch (inp[pos++]) {
      case ' ' :
      case '\t' :
        break;
      case '\'' :
      case '"' :
      case '`' :
        bits = explode("#"+inp[pos-1..]+"#", inp[pos-1..pos-1]);
        if (!bits || sizeof(bits) < 2) {
          write("Error processing the string.\n");
          return 0;
        }
        pos += strlen(bits[1])+1;
        cur += ({ ({ bits[1] }) });
        break;
      case '.' :
      case '0' :
      case '1' :
      case '2' :
      case '3' :
      case '4' :
      case '5' :
      case '6' :
      case '7' :
      case '8' :
      case '9' :
        start_pos = pos;
        while ((inp[pos] >= '0' && inp[pos] <= '9') || (inp[pos] == '.')) {
          pos++;
        }
        if (strsrch(inp[start_pos..pos], ".") != -1) {
          sscanf(inp[start_pos-1..pos], "%f", num);
        } else {
          sscanf(inp[start_pos-1..pos], "%d", num);
        }
        cur += ({ ({ num }) });
        break;
      case '+' :
      case '*' :
      case ':' :
      case ',' :
      case '{' :
      case '}' :
      case '(' :
      case ')' :
      case '[' :
      case ']' :
        cur += ({ token[inp[pos-1]] });
        break;
      case '>' :
      case '<' :
      case '=' :
      case '-' :
      case '/' :
      case '.' :
        if (inp[pos-1] != '/') {
          if ((num = token[inp[pos-1..pos]])) {
            cur += ({ num });
            pos++;
            break;
          }
          num = token[inp[pos-1]];
          if (num) {
            cur += ({ num });
            break;
          }
        } else {
          if (sizeof(cur) && !stringp(cur[sizeof(cur)-1])) {
            cur += ({ token[inp[pos-1]] });
            break;
          }
        }
      default :
        num = pos-1;
        while (pos < strlen(inp) && (!token[inp[pos++]] || inp[pos-1] == '/'));
        if (pos == num+1)
          break;
        if (token[inp[pos-1]])
          pos--;
        cur += ({ inp[num..pos-1] });
        break;
    }
  return cur;
}

==================================================
FILE: handlers/top_ten_handler.c
==================================================

#include <library.h>
#include <skills.h>
#include <top_ten_tables.h>
#include <clubs.h>
#include <player.h>
#include <player_handler.h>
#define SAVE_FILE "/save/top_ten_tables"
#define TOP_TEN_SIZE 15
#define GUILD_TOP_TEN_SIZE 10
#define ARCHIVE_TIME 50 * 24 * 60 * 60
#define ARCHIVE_RATING 30000
#define APEX_LIMIT 10000
#define AGE_DIVIDER 100
#define AGE calculate_age_modifier( thing, 0 )
mapping guild_top_tens;
mixed *archive, *top_ten;
nosave int average;
nosave mixed *skills;
string _family_largest;
int _family_largest_num;
string _family_qp;
int _family_qp_num;
string _family_age;
int _family_age_num;
mapping _family_guilds;
mapping _family_guilds_num;
string _family_pk;
int _family_pk_num;
string _family_single_gender;
int _family_single_gender_num;
string _family_start_time;
int _family_start_time_num;
string _family_relationships;
int _family_relationships_num;
string _club_largest;
int _club_largest_num;
string _club_qp;
int _club_qp_num;
string _club_age;
int _club_age_num;
mapping _club_guilds;
mapping _club_guilds_num;
string _club_pk;
int _club_pk_num;
string _club_single_gender;
int _club_single_gender_num;
string _club_start_time;
int _club_start_time_num;
void calculate_family_and_club_info();
void create() {
    seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
    guild_top_tens = ([ ]);
    _family_guilds = ([ ]);
    _club_guilds = ([ ]);
    _family_guilds_num = ([ ]);
    _club_guilds_num = ([ ]);
    archive = ({ });
    top_ten = ({ });
    call_out( "check_tables", 5 );
    call_out( "check_family_and_club_info", 10 );
    if ( file_size( SAVE_FILE +".o" ) > 0 ) {
        unguarded( (: restore_object, SAVE_FILE :) );
        if (!_family_guilds_num) {
            _family_guilds_num = ([ ]);
        }
        if (!_club_guilds_num) {
            _club_guilds_num = ([ ]);
        }
    }
}
private void save_me() {
    unguarded( (: save_object, SAVE_FILE :) );
}
int query_average() { return average; }
mixed *query_skills() { return skills; }
mapping query_guild_top_tens() { return guild_top_tens; }
void set_guild_top_tens( mapping map ) {
    guild_top_tens = map;
    save_me();
}
void add_guild_top_ten( string word ) {
    if ( guild_top_tens[ word ] ) {
        return;
    }
    guild_top_tens[ word ] = ({ });
    save_me();
}
mixed *query_archive() { return archive; }
void set_archive( mixed *args ) {
    archive = args;
    save_me();
}
mixed *query_top_ten() { return top_ten; }
void set_top_ten( mixed *args ) {
    top_ten = args;
    save_me();
}
int check_person( mixed *args, string guild ) {
    int i;
    string word;
    if ( !guild ) {
        sscanf( args[ 0 ], "%s (%s)", word, guild );
    } else {
        word = args[ 0 ];
    }
    if ( !PLAYER_HANDLER->test_user( word ) ||
      !PLAYER_HANDLER->test_active( word ) ||
      PLAYER_HANDLER->test_creator( word ) ||
      PLAYER_HANDLER->test_property( word, "no_score" ) ||
      PLAYER_HANDLER->test_property( word, "no score" ) ) {
        return 0;
    }
    if ( "/obj/handlers/player_handler"->test_guild( word, guild ) != "/std/guilds/"+ guild )
        return 0;
    if ( ( (int)PLAYER_HANDLER->test_last( word ) < time() - ARCHIVE_TIME ) ) {
        if ( args[ 1 ] > ARCHIVE_RATING ) {
            args[ 0 ] = word +" ("+ guild +")";
            for ( i = sizeof( archive ) - 1; i > -1; i-- ) {
                if ( archive[ i ][ 0 ] == args[ 0 ] ) {
                    if ( archive[ i ][ 1 ] > args[ 1 ] )
                        archive[ i ] = args + ({ time() });
                    break;
                }
            }
            if ( i == -1 ) {
                archive += ({ args + ({ time() }) });
            }
        }
        return 0;
    }
    return 1;
}
void check_tables() {
    int i;
    string word;
    for ( i = sizeof( top_ten ) - 1; i > -1; i-- ) {
        if ( !check_person( copy( top_ten[ i ] ), 0 ) ) {
            top_ten = delete( top_ten, i, 1 );
        }
    }
    foreach ( word in keys( guild_top_tens ) ) {
        for ( i = sizeof( guild_top_tens[ word ] ) - 1; i > -1; i-- ) {
            if ( !check_person( copy( guild_top_tens[ word ][ i ] ), word ) ) {
                guild_top_tens[ word ] = delete( guild_top_tens[ word ], i, 1 );
            }
        }
    }
    save_me();
}
mixed *query_ordered_table( string table_name ) {
    int i, highest_loc, highest_num;
    mixed *ret, *args;
    if ( !table_name || table_name == "main") {
        args = top_ten;
    } else {
        if ( table_name == "archive" ) {
            args = archive;
        } else {
            if ( !guild_top_tens[ table_name ] ) {
                return ({ });
            }
            args = guild_top_tens[ table_name ];
        }
    }
    ret = ({ });
    while ( sizeof( args ) ) {
        highest_loc = highest_num = 0;
        for ( i = 0; i < sizeof( args ); i++ ) {
            if ( args[ i ][ TOP_TEN_RATING ] > highest_num ) {
                highest_num = args[ i ][ TOP_TEN_RATING ];
                highest_loc = i;
            }
        }
        ret += ({ args[ highest_loc] });
        args = args[ 0 .. highest_loc - 1 ] + args[ highest_loc + 1 .. ];
    }
    return ret;
}
mixed *remove_name( string word, mixed *args ) {
    int i;
    if ( !sizeof( args ) ) {
        return ({ });
    }
    for ( i = sizeof( args ) - 1; i > -1; i-- ) {
        if ( word == explode( args[ i ][ TOP_TEN_NAME ], " " )[ 0 ] ) {
            args = delete( args, i, 1 );
        }
    }
    return args;
}
int *find_lowest( mixed *args ) {
    int i, lowest_loc, lowest_num;
    if ( !sizeof( args ) ) {
        return ({ 0, 0 });
    }
    lowest_loc = 0;
    lowest_num = args[ 0 ][ TOP_TEN_RATING ];
    for ( i = 1; i < sizeof( args ); i++ ) {
        if ( lowest_num > args[ i ][ TOP_TEN_RATING ] ) {
            lowest_loc = i;
            lowest_num = args[ i ][ TOP_TEN_RATING ];
        }
    }
    return ({ lowest_loc, lowest_num });
}
int query_skill_weight( string skill ) {
    int total;
    string *next;
    next = (string *)SKILL_OB->query_immediate_children( skill );
    if ( !sizeof( next ) ) {
        return 1;
    }
    foreach ( skill in next ) {
        total += query_skill_weight( skill );
    }
    return total;
}
int calculate_age_modifier( object thing, int algorithm ) {
    if ( algorithm ) {
        return ( -( thing->query_time_on() - ( thing->query_refresh_time() ? ( time() - thing->query_refresh_time() ) + thing->query_time_on() : 0 ) ) / 86400 );
    }
    return ( -thing->query_time_on() / 86400 );
}
int calculate_rating( object thing ) {
    int i, j, rating, *bonuses;
    rating = (int)thing->query_level();
    if ( !skills ) {
        skills = ({ });
        for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
            skills += ({
              (string *)SKILL_OB->query_immediate_children( STD_SKILLS[ i ] )
            });
            skills += ({
              sizeof( skills[ <1 ] ),
              query_skill_weight( STD_SKILLS[ i ] )
            });
            average += skills[ <1 ];
        }
        average /= sizeof( skills ) / 3;
    }
    bonuses = allocate( sizeof( skills ) / 3 );
    for ( i = sizeof( bonuses ) - 1; i > -1; i-- ) {
        for ( j = skills[ 3 * i + 1 ] - 3; j > -1; j-- ) {
            bonuses[ i ] +=
            (int)thing->query_skill_bonus( skills[ 3 * i ][ j ], 1 );
        }
        bonuses[ i ] = ( ( bonuses[ i ] / skills[ 3 * i + 1 ] ) *
          skills[ 3 * i + 2 ] ) / average;
    }
    bonuses = sort_array( bonuses, -1 );
    j = sizeof( bonuses );
    for ( i = 0; i < j; i++ ) {
        rating = 2 * rating + bonuses[ i ];
        if ( !i && userp( thing ) ) {
            rating += (int)LIBRARY->
            query_quest_points( (string)thing->query_name() );
        }
    }
    if( rating > APEX_LIMIT && userp( thing ) ) {
        rating = AGE * (rating - APEX_LIMIT) / AGE_DIVIDER + APEX_LIMIT;
    }
    return rating;
}
void player_skill_advance( string word, object thing ) {
    int rating, *lowest;
    string name;
    mixed *guild_top_ten;
    if ( thing->query_creator() ) {
        return;
    }
    if ( thing->query_property( "guest" ) ) {
        return;
    }
    if ( thing->query_property( "no_score" ) ) {
        return;
    }
    if ( thing->query_property( "no score" ) ) {
        return;
    }
    guild_top_ten = guild_top_tens[ word ];
    if ( !guild_top_ten ) {
        return;
    }
    name = (string)thing->query_name();
    rating = calculate_rating( thing );
    guild_top_ten = remove_name( name, guild_top_ten );
    lowest = find_lowest( guild_top_ten );
    if ( sizeof( guild_top_ten ) < GUILD_TOP_TEN_SIZE ) {
        guild_top_ten += ({
          ({ name, rating, (int)thing->query_level(),
            -(int)thing->query_time_on() }) });
    } else {
        if ( rating > lowest[ 1 ] ) {
            guild_top_ten[ lowest[ 0 ] ] =
            ({ name, rating, (int)thing->query_level(),
              -(int)thing->query_time_on() });
        }
    }
    guild_top_tens[ word ] = guild_top_ten;
    top_ten = remove_name( name, top_ten );
    lowest = find_lowest( top_ten );
    if ( sizeof( top_ten ) < TOP_TEN_SIZE ) {
        top_ten += ({
          ({ name +" ("+ word +")", rating,
            (int)thing->query_level(), -(int)thing->query_time_on() }) });
    } else {
        if ( rating > lowest[ 1 ] ) {
            top_ten[ lowest[ 0 ] ] =
            ({ name +" ("+ word +")", rating,
              (int)thing->query_level(), -(int)thing->query_time_on() });
        }
    }
}
varargs void excise_name( string word1, string word2 ) {
    if ( !word2 ) {
        top_ten = remove_name( word1, top_ten );
    } else {
        if ( guild_top_tens[ word2 ] ) {
            guild_top_tens[ word2 ] = remove_name( word1,
              guild_top_tens[ word2 ] );
        }
    }
    save_me();
}
void check_family_and_club_info() {
    int offset;
    string bing;
    string guild;
    _family_qp_num = 0;
    _family_age_num = 0;
    _family_largest_num = 0;
    if (!mapp(_family_guilds)) {
        _family_guilds = ([ ]);
    }
    if (!mapp(_club_guilds)) {
        _club_guilds = ([ ]);
    }
    if (_family_qp && !CLUB_HANDLER->is_family(_family_qp)) {
        _family_qp = 0;
        _family_qp_num = 0;
    }
    if (_family_age && !CLUB_HANDLER->is_family(_family_age)) {
        _family_age = 0;
        _family_age_num = 0;
    }
    if (_family_largest && !CLUB_HANDLER->is_family(_family_largest)) {
        _family_largest = 0;
        _family_largest_num = 0;
    }
    if (_family_single_gender && !CLUB_HANDLER->is_family(_family_single_gender)) {
        _family_single_gender = 0;
        _family_single_gender_num = 0;
    }
    if (_family_pk && !CLUB_HANDLER->is_family(_family_pk)) {
        _family_pk = 0;
        _family_pk_num = 0;
    }
    if (_club_qp && !CLUB_HANDLER->is_club(_club_qp)) {
        _club_qp = 0;
        _club_qp_num = 0;
    }
    if (_club_age && !CLUB_HANDLER->is_club(_club_age)) {
        _club_age = 0;
        _club_age_num = 0;
    }
    if (_club_largest && !CLUB_HANDLER->is_club(_club_largest)) {
        _club_largest = 0;
        _club_largest_num = 0;
    }
    if (_club_single_gender && !CLUB_HANDLER->is_club(_club_single_gender)) {
        _club_single_gender = 0;
        _club_single_gender_num = 0;
    }
    if (_club_pk && !CLUB_HANDLER->is_club(_club_pk)) {
        _club_pk = 0;
        _club_pk_num = 0;
    }
    offset = 3;
    foreach (guild, bing in _family_guilds) {
        if (stringp(bing)) {
            if (!CLUB_HANDLER->is_family(bing)) {
                map_delete(_family_guilds, guild);
                map_delete(_family_guilds_num, guild);
            }
        } else {
            map_delete(_family_guilds, guild);
            map_delete(_family_guilds_num, guild);
        }
    }
    foreach (guild, bing in _club_guilds) {
        if (stringp(bing)) {
            if (!CLUB_HANDLER->is_club(bing)) {
                map_delete(_club_guilds, guild);
                map_delete(_club_guilds_num, guild);
            }
        } else {
            map_delete(_club_guilds, guild);
            map_delete(_club_guilds_num, guild);
        }
    }
    save_me();
}
void inform_of_club(string club,
  int family,
  int type,
  mixed num) {
    string str;
    int bing;
    if (family) {
        switch (type) {
        case TOP_TEN_LARGEST_FAMILY:
            if (_family_largest_num < num ||
              _family_largest == club) {
                _family_largest_num = num;
                _family_largest = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_FAMILY:
            if (_family_age_num < num ||
              _family_age == club) {
                _family_age_num = num;
                _family_age = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_QUEST_POINTS:
            if (_family_qp_num < num ||
              _family_qp == club) {
                _family_qp_num = num;
                _family_qp = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_GUILD:
            foreach (str, bing in num) {
                if (_family_guilds_num[str] < bing ||
                  _family_guilds[str] == club) {
                    _family_guilds_num[str] = bing;
                    _family_guilds[str] = club;
                    save_me();
                }
            }
            break;
        case TOP_TEN_MOST_PKS:
            if (_family_pk_num < num ||
              _family_pk == club) {
                _family_pk_num = num;
                _family_pk = club;
                save_me();
            }
            break;
        case TOP_TEN_SINGLE_GENDER:
            if (_family_single_gender_num < num ||
              _family_single_gender == club) {
                _family_single_gender_num = num;
                _family_single_gender = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_LOGONS:
            if (_family_start_time_num < num ||
              _family_start_time == club) {
                _family_start_time_num = num;
                _family_start_time = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_RELATIONSHIPS:
            if (_family_relationships_num < num ||
              _family_relationships == club) {
                _family_relationships_num = num;
                _family_relationships = club;
                save_me();
            }
            break;
        }
    } else {
        switch (type) {
        case TOP_TEN_LARGEST_FAMILY:
            if (_club_largest_num < num ||
              _club_largest == club) {
                _club_largest_num = num;
                _club_largest = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_FAMILY:
            if (_club_age_num < num ||
              _club_age == club) {
                _club_age_num = num;
                _club_age = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_QUEST_POINTS:
            if (_club_qp_num < num ||
              _club_qp == club) {
                _club_qp_num = num;
                _club_qp = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_GUILD:
            foreach (str, bing in num) {
                if (_club_guilds_num[str] < bing ||
                  _club_guilds[str] == club ||
                  !_club_guilds[str]) {
                    _club_guilds_num[str] = bing;
                    _club_guilds[str] = club;
                    save_me();
                }
            }
            break;
        case TOP_TEN_MOST_PKS:
            if (_club_pk_num < num ||
              _club_pk == club) {
                _club_pk_num = num;
                _club_pk = club;
                save_me();
            }
            break;
        case TOP_TEN_SINGLE_GENDER:
            if (_club_single_gender_num < num ||
              _club_single_gender == club) {
                _club_single_gender_num = num;
                _club_single_gender = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_LOGONS:
            if (_club_start_time_num < num ||
              _club_start_time == club) {
                _club_start_time_num = num;
                _club_start_time = club;
                save_me();
            }
            break;
        }
    }
}
mixed *query_family_info() {
    return ({ _family_largest,
      _family_age,
      _family_qp,
      _family_guilds,
      _family_pk,
      _family_single_gender,
      _family_start_time,
      _family_relationships });
}
mixed *query_club_info() {
    return ({ _club_largest,
      _club_age,
      _club_qp,
      _club_guilds,
      _club_pk,
      _club_single_gender,
      _club_start_time });
}
void dest_me() {
    save_me();
    destruct(this_object());
}
void reset() {
    save_me();
}

==================================================
FILE: handlers/trig.c
==================================================

int *sintab, *pow;
create()
{
   pow = ({ 296296, 308556, 321324, 334621, 348467, 362887, 377903,
            393541, 409825, 426784, 444444, 462835, 481987, 501931,
            522701, 544331, 566855, 590311, 614738, 640176, 666666,
            694253, 722981, 752897, 784052, 816496, 850283, 885467,
            922107, 960264, 1000000,
            1041379, 1084471, 1129346, 1176079, 1224744, 1275424,
            1328201, 1383161, 1440396, 1500000, 1562069, 1626707,
            1694020, 1764118, 1837117, 1913136, 1992301, 2074742,
            2160595, 2250000, 2343104, 2440061, 2541030, 2646177,
            2755675, 2869705, 2988452, 3112114, 3240892, 3375000
   });
   sintab = ({
      0, 17452, 34899, 52335, 69756, 87155, 104528, 121869, 139173, 156434,
      173648, 190808, 207911, 224951, 241921, 258819, 275637, 292371,
      309016, 325568, 342020, 358367, 374606, 390731, 406736, 422618,
      438371, 453990, 469471, 484809, 500000, 515038, 529919, 544639,
      559192, 573576, 587785, 601815, 615661, 629320, 642787, 656059,
      669130, 681998, 694658, 707106, 719339, 731353, 743144, 754709,
      766044, 777145, 788010, 798635, 809016, 819152, 829037, 838670,
      848048, 857167, 866025, 874619, 882947, 891006, 898794, 906307,
      913545, 920504, 927183, 933580, 939692, 945518, 951056, 956304,
      961261, 965925, 970295, 974370, 978147, 981627, 984807, 987688,
      990268, 992546, 994521, 996194, 997564, 998629, 999390, 999847, 1000000
   });
}
int sin(int angle)
{
   while (angle < 0) angle += 360;
   while (angle >= 360) angle -= 360;
   if (angle >= 270) return -sintab[360 - angle];
   if (angle >= 180) return -sintab[angle - 180];
   if (angle >= 90) return sintab[180 - angle];
   return sintab[angle];
}
int cos(int angle)
{
   return sin(90 - angle);
}
int tan(int angle)
{
   return 1000 * sin(angle) / (sin(90 - angle) / 1000);
}
int pow1_5(int n)
{
   if (n > 30) n = 30;
   else if (n < -30) n = -30;
   return pow[30-n];
}

==================================================
FILE: handlers/twiki.c
==================================================

#include <board.h>
void do_check_changes();
#define SAVE_FILE "/save/twiki"
#define CHECK_TIME (7 * 24 * 60 * 60)
#define TWIKI_CHANGE_FILE "/.changes"
#define TWIKI_DATA_DIRECTORY "/twiki/data/"
private nosave string* _databases;
private int _last_check;
private mapping _last_change;
void create() {
   _databases = ({ "Main", "Am", "Ram", "Cwc", "Sur", "Klatch",
                   "Forn", "Underworld", "Other", "Playtesters" });
   seteuid(getuid());
   restore_object(SAVE_FILE);
   if (_last_check + CHECK_TIME < time()) {
      do_check_changes();
   }
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
   if (!_last_change) {
      _last_change = ([ ]);
   }
   call_out("do_change_inform", 60 * 5);
}
mapping find_changed_pages(int limit, string database) {
   string* lines;
   int i;
   int tim;
   string page;
   string author;
   mixed* bits;
   mapping changes_pages;
   lines = explode(read_file(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE), "\n");
   changes_pages = ([ ]);
   for (i = 1; i < sizeof(lines); i++) {
      bits = reg_assoc(lines[<i], ({ "([a-zA-Z][a-zA-Z0-9]+)", "[0-9]+" }), ({ 1, 2 }) );
      if (sizeof(bits[0]) == 9 || sizeof(bits[0]) == 7) {
         page = bits[0][1];
         author = bits[0][3];
         sscanf(bits[0][5], "%d", tim);
         if (tim > limit) {
            if (page[0..4] != "TWiki" &&
                page[0..9] != "Underworld" &&
                author != "PeterThoeny" &&
                page != author &&
                page != "WebPreferences") {
               if (file_size("/twiki/data/" + database + "/" + page + ".txt") > 0 &&
                   strsrch(read_file("/twiki/data/" + database + "/" + page + ".txt"),
                           "\t* Login Name:") == -1) {
                  if (!changes_pages[page]) {
                     changes_pages[page] = ({ });
                  }
                  if (member_array(author, changes_pages[page]) == -1) {
                     changes_pages[page] += ({ author });
                  }
               }
            }
         } else {
            break;
         }
      } else {
         break;
      }
   }
   return changes_pages;
}
string find_changes(int limit) {
   mapping changes_pages;
   string ret;
   string page;
   string database;
   ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   foreach (database in _databases) {
      changes_pages = find_changed_pages(limit, database);
      foreach (page in sort_array(keys(changes_pages), 1)) {
         ret += sprintf("%-30s changed by %s\n", database + "." + page,
                         query_multiple_short(changes_pages[page]));
      }
   }
   return ret;
}
string find_changes_in_database(string database, int limit) {
   mapping changes_pages;
   string ret;
   string page;
   if (database == "Playtesters") {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   } else {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   }
   changes_pages = find_changed_pages(limit, database);
   foreach (page in sort_array(keys(changes_pages), 1)) {
      ret += sprintf("%-30s changed by %s\n", database + "." + page,
                      query_multiple_short(changes_pages[page]));
   }
   return ret;
}
string query_file(string fname) {
   if (strsrch(fname, ".") > 0) {
      fname = "/twiki/data/" + replace_string(fname, ".", "/") + ".txt";
   } else {
      fname = "/twiki/data/Main/" + fname + ".txt";
   }
   if (sizeof(stat(fname))) {
      return read_file(fname);
   }
   return 0;
}
void do_check_changes() {
   string changes;
   changes = find_changes(_last_check);
   BOARD_HAND->add_message("commonroom", "Twiki Database",
                           "Changes in the Twiki database",
                           changes);
   _last_check = time();
   save_object(SAVE_FILE);
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
}
void do_change_inform() {
   int changed;
   mapping changed_pages;
   string page;
   string* changers;
   int dosave;
   string database;
   if (!mapp(_last_change)) {
      _last_change = ([ ]);
   }
   foreach (database in _databases) {
      if (!_last_change[database]) {
         _last_change[database] = time();
         dosave = 1;
      } else {
         changed = stat(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE)[1];
         if (changed != _last_change[database]) {
            changed_pages = find_changed_pages(_last_change[database], database);
            _last_change[database] = changed;
            dosave = 1;
            foreach (page, changers in changed_pages) {
               user_event( "inform",
                           sprintf( "%s changes the twiki page %s.%s",
                                    query_multiple_short(changers), database,
                                    page),
                           "message",
                           this_player() );
            }
         }
      }
   }
   if (dosave) {
      save_object(SAVE_FILE);
   }
   call_out("do_change_inform", 60 * 5);
}

==================================================
FILE: handlers/vhandler.c
==================================================

mapping stored_variables;
void create()
{
  seteuid(geteuid(this_object()));
  stored_variables=([ ]);
  restore_object(file_name(this_object()));
}
mixed query_variable_status(string vname)
{
  return stored_variables[vname];
}
int set_variable_status(string vname, mixed vvalue)
{
  stored_variables[vname]=vvalue;
  save_object(file_name(this_object()));
}

==================================================
FILE: handlers/virtuals.c
==================================================

#define SAVE_FILE "/save/virtuals"
#define MAX_NUMBERS 50
mapping load_data;
string *paths;
string *missing_paths;
string *forbidden_paths;
void create() {
   seteuid( "/secure/master"->creator_file( file_name( this_object() ) ) );
   load_data = ([ ]);
   paths = ({ });
   missing_paths = ({ });
   forbidden_paths = ({ });
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
void add_data( string path ) {
  object junk_item;
  string tmp_str;
  int tmp_int;
  junk_item = clone_object( path );
  load_data[ path ] = ({ stat( path )[1], junk_item->query_static_auto_load() });
  destruct( junk_item );
  paths -= ({ path });
  paths += ({ path });
  if( sizeof( paths ) > MAX_NUMBERS ) {
    tmp_int = sizeof( paths ) - (MAX_NUMBERS + 1);
    paths = paths[tmp_int+1..tmp_int+MAX_NUMBERS];
  }
  foreach( tmp_str in keys( load_data ) ) {
    if( member_array( tmp_str, paths ) == -1 ) {
      map_delete( load_data, tmp_str );
    }
  }
  save_me();
}
mapping new_data( string path ) {
  if( ( !load_data[path] ) || ( !sizeof( stat( path ) ) ) || ( load_data[path][0] < stat( path )[1] ) ) {
    if( !sizeof( stat( path ) ) ) {
      return 0;
    }
    add_data( path );
  }
  return load_data[path][1];
}
string *query_missing_paths() { return missing_paths; }
int add_missing( string path ) {
  if( !missing_paths )
    missing_paths = ({ });
  if( member_array( path, missing_paths ) != -1 )
    return 0;
  if( path[0..2] == "/w/" )
    return 0;
  missing_paths += ({ path });
  save_me();
  return 1;
}
void remove_missing( string path ) {
  missing_paths -= ({ path });
  save_me();
}
int query_forbidden( string path ) {
  return ( member_array( path, forbidden_paths ) != -1 );
}
string *query_forbidden_paths( ) { return forbidden_paths; }
int add_forbidden( string path ) {
  if( !forbidden_paths )
    forbidden_paths = ({ });
  if( member_array( path, forbidden_paths ) != -1 )
    return 0;
  forbidden_paths += ({ path });
  save_me();
  return 1;
}
void remove_forbidden( string path ) {
  forbidden_paths -= ({ path });
  save_me();
}

==================================================
FILE: handlers/wander_handler.c
==================================================

#include <player.h>
#define MH "/obj/handlers/map"
#define LAST_LOC_PROPERTY "last locations"
void do_move_after();
class route_traveller {
  object monster;
  int movetime;
  int delay;
  string dest;
}
class wander_group {
  object *monsters;
  int movetime;
}
private class wander_group *wanderers = ({});
private mapping wanderpos = ([]);
private class route_traveller *travellers = ({});
private mapping travelpos = ([]);
private int move_call_out_id;
private int after_call_out_id;
private void do_move_after();
private void move_monsters();
void delete_move_after( object monster );
private void do_wander(int running_away, object monster);
mixed query_next_mover() {
  return wanderers[0];
}
mixed query_anything(string thing){
  return copy(fetch_variable(thing));
}
int query_moving_monster(object ob) {
  return member_array(ob, travellers) != -1;
}
mixed query_route_monster() {
  return travellers[0];
}
int find_pos(mixed *arr, function func, int val, int ref found){
  int mid, high, low;
  high = sizeof(arr) - 1;
  low = 0;
  while(high >= low){
    mid = (high + low) / 2;
    if(val < (*func)(arr[mid]))
      high = mid - 1;
    else if(val > (*func)(arr[mid]))
      low = mid + 1;
    else break;
  }
  found = !(high < low);
  return mid;
}
private void add_traveller(class route_traveller new_traveller){
  if(sizeof(travellers)){
    int found, mid;
    mid = find_pos(travellers, (: $1->movetime :), new_traveller->movetime,
                   ref found);
    if(!found){
      if(new_traveller->movetime > travellers[mid]->movetime)
        mid++;
      if(mid == sizeof(travellers)){
        travellers += ({new_traveller});
        if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
          move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
        }
        return;
      }
    }
    if(mid == 0){
      travellers = ({new_traveller}) + travellers;
      remove_call_out(move_call_out_id);
      move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
    } else {
        travellers = insert(travellers, new_traveller, mid);
    }
  } else {
    travellers = ({ new_traveller });
    move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
  }
}
int move_me_please(int delay, string dest) {
  class route_traveller new_traveller;
  object monster;
  monster = previous_object();
  if(!intp(delay))
    return 0;
  if(travelpos[monster])
    travelpos[monster]->monster = 0;
  if(delay < 5)
    delay = 5;
  new_traveller = new (class route_traveller, monster:monster, delay:delay,
             movetime:time() + delay, dest:dest);
  travelpos[monster] = new_traveller;
  add_traveller(new_traveller);
}
private void move_monsters(){
  class route_traveller tmp;
  int virtual_move, right, refuse;
  object monster;
  string true_location, destination, direc;
  tmp = travellers[0];
  monster = tmp->monster;
  if(sizeof(travellers) > 1)
    travellers = travellers[1..];
  else
    travellers = ({});
  if (monster) {
    virtual_move = monster->query_virtual_move();
    true_location = monster->query_true_location();
    direc = monster->get_next_route_direction();
    if (direc) {
      if ( !virtual_move ){
        if(catch(monster->do_command(direc)))
          catch(monster->do_command(direc));
      } else {
        if ( "/room/virtual" != file_name( environment( monster ) ) )
          right = 1;
        if ( right ) {
          environment( monster )->set_destination( direc );
          destination = environment( monster )->query_destination( direc, monster );
        } else
          destination = (string)MH->qdes( direc, true_location );
        if ( right ) {
          if ( monster->check_anyone_here() || find_object( destination ) ){
            if(catch(monster->do_command( direc )))
              catch(monster->do_command( direc ));
          } else {
            "/room/virtual"->force_load();
            monster->move( find_object( "/room/virtual" ) );
            true_location = destination;
            monster->set_true_location( true_location );
          }
        } else {
          if ( !find_object( destination ) ) {
            true_location = destination;
            monster->set_true_location( true_location );
          } else {
            object ob = environment(monster);
            ob->remove_exit(direc);
            ob->add_exit(direc, destination,
               "plain" );
            monster->do_command(direc);
            ob->remove_exit(direc);
          }
        }
      }
    }
    tmp->movetime = time() + tmp->delay;
    if ( direc && (!(refuse = monster->query_stop_moving()))) {
      add_traveller( tmp );
    } else {
      if(!refuse)
        refuse = (file_name(environment(tmp->monster)) != tmp->dest);
      tmp->monster->stopped_route(!refuse);
      map_delete( travelpos, tmp->monster );
    }
  } else
    travelpos = filter(travelpos, (: $1 :));
  if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
    move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
  }
}
private void add_move_after(object monster, int movetime) {
  if(sizeof(wanderers)){
    int found, mid;
    reset_eval_cost();
    if(sizeof(wanderers) > 5000){
      wanderers=filter(wanderers, function(class wander_group thing){
        return sizeof(filter(thing->monsters, (:$1:)));
      });
      reset_eval_cost();
    }
    if (find_call_out(after_call_out_id) == -1)
      after_call_out_id = call_out((: do_move_after :), 0);
    mid = find_pos(wanderers, (: $1->movetime :), movetime, ref found);
    if(!found){
      if(movetime > wanderers[mid]->movetime)
        mid++;
      if(mid == sizeof(wanderers)){
        wanderers += ({ new(class wander_group, monsters:({monster}),
                            movetime:movetime) });
        wanderpos[monster] = wanderers[<1];
        return;
      }
      if(mid == 0){
        wanderers = ({ new(class wander_group, monsters:({monster}),
                           movetime:movetime) }) + wanderers;
        wanderpos[monster] = wanderers[0];
        remove_call_out(after_call_out_id);
        after_call_out_id = call_out((: do_move_after :), movetime - time());
        return;
        }
      wanderers = insert(wanderers, new(class wander_group,
                                        monsters:({monster}),
                                        movetime:movetime), mid);
      wanderpos[monster] = wanderers[mid];
      return;
    } else {
      wanderers[mid]->monsters += ({ monster });
      wanderpos[monster] = wanderers[mid];
      return;
    }
  } else {
    wanderers = ({ new(class wander_group, monsters:({monster}),
                       movetime:movetime) });
    wanderpos[monster] = wanderers[0];
    after_call_out_id = call_out((: do_move_after :), movetime - time());
  }
}
void move_after( int runaway ) {
  mixed move_after;
  if(runaway)
    return do_wander(runaway, previous_object());
  move_after = previous_object()->query_move_after();
  delete_move_after(previous_object());
  if (!arrayp(move_after) || (!move_after[0] && !move_after[1])) {
    return;
  }
  add_move_after(previous_object(), time() + move_after[ 0 ] +
                 random( move_after[ 1 ] ));
}
void delete_move_after(object monster) {
  if(wanderpos[monster]) {
    ((class wander_group)wanderpos[monster])->monsters -= ({monster});
  }
  map_delete(wanderpos, monster);
}
private void do_wander(int running_away, object monster) {
  int right, virtual_move;
  string destination, *direcs, *room_zones, true_location, *move_zones,
         *last_locs;
  if ( !monster )
    return ;
  if ( !environment( monster ) || monster->query_property( PASSED_OUT_PROP ) )
    return ;
  if ( !running_away &&
       sizeof( (object *)monster->query_attacker_list() ) )
    return ;
  if ( (int)monster->query_hp() <= 0 )
    return ;
  virtual_move = monster->query_virtual_move();
  true_location = monster->query_true_location();
  if (1 || !virtual_move ||
       (virtual_move && "/room/virtual" != file_name(environment(monster))))
    right = 1;
  if ( right )
   direcs = (string *)environment( monster )->query_direc( monster );
  else
    direcs = (string *)MH->qdir( true_location );
  last_locs = monster->query_propery( LAST_LOC_PROPERTY );
  if (!pointerp(last_locs))
    last_locs = ({ });
   if (!direcs) direcs = ({ });
  direcs = shuffle( direcs );
  while ( sizeof( direcs ) ) {
    if ( right ) {
      direcs[ 0 ] = (string)environment( monster )->expand_alias( direcs[ 0 ] );
      destination = environment( monster )->query_destination( direcs[0], monster );
    } else
      destination = (string)MH->qdes( direcs[ 0 ], true_location );
    if ( (!destination && !virtual_move) || (sizeof(direcs) > 1 &&
                          member_array(destination, last_locs) != -1 ) ||
         (0 && stringp(destination) && !find_object(destination) && !virtual_move) ) {
      direcs = direcs[1..];
      continue;
    }
    move_zones = (string *)monster->query_move_zones();
    if ( sizeof( move_zones ) ) {
      if ( find_object( destination ) )
        room_zones = (string *)destination->query_zones();
      else
        room_zones = (string *)MH->query_zones( destination );
      if (!room_zones ||
          (sizeof(room_zones) == sizeof(room_zones - move_zones))) {
        direcs = direcs[1..];
        continue;
      }
    }
    break;
  }
  last_locs += ({ destination });
  if (sizeof(last_locs) > 4)
    last_locs = last_locs[sizeof(last_locs)-4..];
  monster->add_property( LAST_LOC_PROPERTY, last_locs);
  if (sizeof(direcs)) {
    if (1 || !virtual_move ||
        (right && monster->check_anyone_here()) ||
        (find_object( destination ) ) ) {
      object ob;
      if (!right) {
        ob = environment(monster);
        ob->remove_exit(direcs[0]);
        ob->add_exit(direcs[0], destination, "plain");
        reset_eval_cost();
      }
      monster->do_move(direcs[0]);
      if(!right)
        ob->remove_exit(direcs[0]);
    } else {
      if (virtual_move) {
        "/room/virtual"->force_load();
        monster->move( find_object("/room/virtual"));
        monster->set_true_location(destination);
      }
    }
  }
}
private void do_move_after() {
  object monster;
  int movetime, *move_after, zero;
  class wander_group tmp;
  reset_eval_cost();
  if(sizeof(wanderers) > 5000){
    wanderers=filter(wanderers, function(class wander_group thing){
      return sizeof(filter(thing->monsters, (:$1:)));
    });
    reset_eval_cost();
  }
  while (sizeof(wanderers) && wanderers[0]->movetime <= time()) {
    reset_eval_cost();
    tmp = wanderers[0];
    wanderers = wanderers[1..];
    foreach(monster in tmp->monsters){
      map_delete(wanderpos, monster);
      if (objectp(monster) && environment(monster)) {
        move_after = monster->query_move_after();
        if (move_after[0] || move_after[1]) {
          movetime = time() + move_after[ 0 ] + random( move_after[ 1 ] );
          if( movetime < (time() + 2) ) {
            movetime = time() + 2;
          }
          add_move_after( monster, movetime );
          reset_eval_cost();
          if (!travelpos[monster]) {
            do_wander(0, monster);
          }
        }
      } else {
        zero = 1;
      }
    }
  }
  if (find_call_out(after_call_out_id) == -1 && sizeof(wanderers)) {
    after_call_out_id = call_out((: do_move_after :),
                                        wanderers[0]->movetime - time());
  }
  if(zero) {
    wanderpos = filter(wanderpos, (: $1 :));
  }
}
mapping query_dynamic_auto_load() {
   return ([
    "wanderers" : wanderers,
    "wanderpos" : wanderpos,
    "travellers" : travellers,
    "travelpos" : travelpos
     ]);
}
void init_dynamic_arg(mapping map) {
  if (map) {
     wanderers = map["wanderers"];
     wanderpos = map["wanderpos"];
     travellers = map["travellers"];
     travelpos = map["travelpos"];
     do_move_after();
  }
}

==================================================
FILE: handlers/weather.c
==================================================

#include <climate.h>
#include <am_time.h>
#include <weather.h>
#define FILE_NAME "/save/nweather"
#define UPDATE_SPEED 300
#define CYCLE_SPEED  3600
#define DIY 400
#define DIF(x, y) (x > y) ? (x-y) : (y-x)
private mapping _pattern;
private mapping _current;
private int *_variance;
private nosave mapping _rooms;
private nosave int _lastupdate;
private nosave int _day;
private nosave int _sunrise;
private nosave int _sunset;
private nosave int _toy;
private int mooncycle;
private int moonupdate;
void set_day();
void update_pattern();
int calc_actual(object env, int type);
int cloud_index(object env);
int query_day(object env);
int query_rain_type(int temp, int rain);
string sun_direction(int which);
int temperature_index(object env);
int rain_index(object env);
void create() {
  string str;
  _rooms = ([ ]);
  unguarded((: restore_object, FILE_NAME :));
  if(!_pattern)
    _pattern = ([ ]);
  if(!_current)
    _current = ([ ]);
  if(!_variance)
    _variance = ({ 10, 75, 20 });
  foreach(str in CLIMATES) {
    if(!_pattern[str])
      _pattern[str] =  ({ 0, 0, 0 });
    if(!_current[str])
      _current[str] =  ({ 0, 0, 0 });
  }
  call_out("update_weather", UPDATE_SPEED);
  set_day();
  update_pattern();
}
int weather_notify( object which_room, int notifications ) {
  if(notifications < 0 || notifications >
     (NOTIFY_TEMPERATURE | NOTIFY_CLOUD | NOTIFY_RAIN | NOTIFY_DAY)) {
    return 0;
  }
  _rooms[which_room] = notifications;
  return 1;
}
void test_notifications() {
  object room;
  string w;
  foreach( room in keys(_rooms)) {
    w = sprintf("%O notified of %s%s%s%s\n", room,
    ((_rooms[room] & NOTIFY_TEMPERATURE) ? "Temperature " : ""),
                ((_rooms[room] & NOTIFY_CLOUD) ? "Clouds " : ""),
                ((_rooms[room] & NOTIFY_RAIN) ? "Rain " : ""),
                ((_rooms[room] & NOTIFY_DAY) ? "Day" : ""));
    write( w );
  }
  write("test_notifications() done\n");
}
int day_number() {
  return ( time() % AM_SECONDS_PER_HALF_YEAR ) / AM_SECONDS_PER_DAY;
}
int minute_number() {
  return (( time() % AM_SECONDS_PER_DAY ) / AM_SECONDS_PER_MINUTE);
}
string query_moon_string(object env) {
  string str;
  if(mooncycle > 10)
    return "It is night and there is no moon.\n";
  if(calc_actual(env, CLOUD) > 70)
    str = "It is night and the %s is hidden by the clouds.\n";
  else if(env && env->query_water())
    str = "The water is lit up by the eerie light of the %s.\n";
  else
    str = "The land is lit up by the eerie light of the %s.\n";
  return sprintf(str, ({"waxing crescent moon",
                        "waxing quarter moon",
                        "waxing half moon",
                        "waxing three quarter moon",
                        "waxing gibbous moon",
                        "full moon",
                        "waning gibbous moon",
                        "waning three quarter moon",
                        "waning half moon",
                        "waning quarter moon",
                        "waning crescent moon",
                        "no moon",
                        "no moon",
                        "no moon",
                      })[mooncycle]);
}
int query_moon_state() {
  if(mooncycle < 6)
    return mooncycle+1;
  if(mooncycle < 11)
    return (11 - mooncycle);
  return 0;
}
string query_moon_phase() {
  return ({"crescent",
           "quarter",
           "half",
           "three quarter",
           "gibbous",
           "full",
           "gibbous",
           "three quarter",
           "half",
           "quarter",
           "crescent",
           "",
           "",
           "",
         })[mooncycle];
}
int query_stars( object env ) {
    int clouds, stars ;
    clouds = cloud_index(env) ;
    if ( query_day(env) || clouds > 70 ) {
        return 0 ;
    }
    switch( clouds ) {
        case 0:
            stars = 100 ;
            break ;
        case 1..39:
            stars = 80 ;
            break ;
        case 40..59:
            stars = 40 ;
            break ;
        case 60..69:
            stars = 20 ;
            break ;
        default:
            stars = 10 ;
            break ;
    }
    return stars ;
}
string query_star_string( object env ) {
    string str ;
    if ( query_day(env) ) {
        return "There are no stars visible during the day.\n" ;
    }
    switch( query_stars(env) ) {
        case 1..20:
            str = "one or two bright stars" ;
            break ;
        case 21..40:
            str = "a few stars" ;
            break ;
        case 41..60:
            str = "quite a few stars" ;
            break ;
        case 61..80:
            str = "lots of stars" ;
            break ;
        case 81..100:
            str = "countless stars" ;
            break ;
        default:
            str = "no stars" ;
            break ;
    }
    return "Tonight, there are " + str + " visible.\n" ;
}
string query_season() {
  switch(day_number()) {
  case 0..50: return "winter";
  case 51..150: return "spring";
  case 151..250: return "summer";
  case 251..350: return "autumn";
  case 351..400: return "winter";
  }
}
string query_tod() {
  if((minute_number() < _sunrise) || (minute_number() > _sunset))
    return "night";
  switch(minute_number()) {
  case 0..700:
    return "morning";
  case 701..740:
    return "midday";
    break;
  case 741..1080:
    return "afternoon";
    break;
  default:
    return "evening";
  }
}
int query_day(object env) {
  return _day;
}
int query_darkness(object env) {
  int result, cloud, day;
  result = 10;
  day = query_day(env);
  if(day == 10)
    return 100;
  if(mooncycle <= 10) {
    if(mooncycle < 6)
      result += mooncycle * 10;
    else
      result += (5 - (mooncycle % 6)) * 10;
    }
  if((cloud = cloud_index(env)) > 0)
    result -= (cloud_index(env) / 15);
  if(result < 0)
    result = 0;
  if(day > 0)
    result += (100 - result) / (10 - day);
  return result;
}
int query_visibility(object env) {
  int result;
  int temp;
  int rain;
  int rt;
  result = 100;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt ==  WEATHER_SNOW_TYPE) {
     rain += 50;
  } else if (rt == WEATHER_SLEET_TYPE) {
     rain += 20;
  }
  if (rain > 0) {
     if (rain > 100) {
        result = 0;
     } else {
        result = (result * (100 - rain)) / 100;
     }
  }
  return result;
}
int calc_actual(object env, int type) {
  int *clim;
  string climate;
  if(env) {
    climate = env->query_climate();
    clim = (int *)env->query_property("climate");
  }
  if(!climate)
    climate = DEFAULT_CLIMATE;
  if(!clim)
    return _current[climate][type];
  return _current[climate][type] + clim[type];
}
int temperature_index(object env) {
  int temp, tod, j, diurnal;
  string climate;
  temp = calc_actual(env, TEMP);
  if(env)
    climate = env->query_climate();
  if(!climate)
    climate = DEFAULT_CLIMATE;
  tod = 10 - query_day(env);
  if(tod) {
    switch(climate) {
    case "Af":
    case "Am":
    case "Aw":
      diurnal = 10;
      break;
    case "Bw":
    case "Bs":
      diurnal = 15 + (_pattern[climate][0] / 2);
      break;
    case "Cfa":
    case "Cs":
    case "Cfb":
    case "Dw":
    case "Ds":
    case "Df":
      diurnal = 15;
      break;
    case "Et":
    case "Ef":
    case "H":
      diurnal = 20;
      break;
    }
    temp -= (diurnal * tod) / 10;
  }
  j = sqrt(_current[climate][CLOUD]);
  if(j < 0)
    j = 0;
  if(temp < 10 && tod == 10)
    temp += j;
  else if(temp > 30 && !tod)
    temp -= j;
  temp -= sqrt(_current[climate][WINDSP]);
  return temp;
}
int cloud_index(object env) {
  int cloud;
  cloud = calc_actual(env, CLOUD);
  if(cloud < 0)
    cloud = 0;
  return cloud;
}
int rain_index(object env) {
  int rain;
  rain = calc_actual(env, CLOUD) - (calc_actual(env, TEMP) / 2) - 100;
  return (rain > 0)? rain : 0;
}
string temp_string(int temp) {
  switch(temp) {
    case 51..1000: return "incredibly, unbelievably hot"; break;
    case 46..50: return "amazingly hot"; break;
    case 41..45: return "damn hot"; break;
    case 36..40: return "very hot"; break;
    case 31..35: return "hot"; break;
    case 26..30: return "reasonably hot"; break;
    case 23..25: return "very warm"; break;
    case 20..22: return "warm"; break;
    case 16..19: return "pleasantly warm"; break;
    case 13..15: return "cool"; break;
    case 10..12: return "slightly chilly"; break;
    case 7..9: return "chilly"; break;
    case 4..6: return "very chilly"; break;
    case 1..3: return "cold"; break;
    case -3..0: return "very cold"; break;
    case -10..-4: return "freezing cold"; break;
    case -20..-11: return "damn cold"; break;
    case -30..-21: return "dangerously cold"; break;
    case -50..-31: return "incredibly, unbelievably cold"; break;
  }
}
private string precipitation_string(int rain, int rt, int wind) {
  switch(rain) {
  case -1000..20:
    return "lightly";
    break;
  case 21..40:
    if(wind < 20) {
      return "steadily";
    } else {
      return "hard";
    }
    break;
  case 41..60:
    return "heavily";
    break;
  case 61..500:
    if(rt == WEATHER_RAIN_TYPE) {
      return "torrentially";
    } else {
      return "very heavily";
    }
    break;
  }
}
string rain_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_RAIN_TYPE) {
    return "There is no rain";
  }
  return "It is raining " + precipitation_string(rain, rt, wind);
}
string snow_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SNOW_TYPE) {
    return "There is no snow";
  }
  return "It is snowing " + precipitation_string(rain, rt, wind);
}
string sleet_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SLEET_TYPE) {
    return "There is no sleet";
  }
  return "It is sleeting " + precipitation_string(rain, rt, wind);
}
string cloud_string(object env) {
  int cloud;
  string str;
  cloud = cloud_index(env);
  switch(cloud) {
    case -1000..5:
       str = "a beautifully clear sky";
       break;
    case 6..10:
       str = "a few high level cirrus clouds";
       break;
    case 11..25:
       str = "scattered puffy clouds";
       break;
    case 26..40:
       str = "some puffy clouds";
       break;
    case 41..60:
       str = "many puffy clouds";
       break;
    case 61..80:
       str = "medium cloud cover";
       break;
    case 81..110:
       str = "dense cloud cover";
       break;
    case 111..130:
       str = "packed cloud cover";
       break;
    case 131..160:
       str = "thick black clouds";
       break;
    case 161..1000:
       str = "thick heavy storm clouds";
       break;
  }
  return str;
}
varargs string weather_string(object env, string obscured) {
  int temp, cloud, wind, rain, rt;
  int *warray;
  string str, tstr;
   if ( !env )
     return 0;
  temp = temperature_index(env);
  cloud = cloud_index(env);
  wind = calc_actual(env, WINDSP);
  rain = rain_index(env);
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temp, cloud, wind, rain))) {
    temp = warray[0];
    cloud = warray[1];
    wind = warray[2];
    rain = warray[3];
  }
  rt = query_rain_type(temp, rain);
  str = "It is ";
  tstr = temp_string(temp);
  switch(tstr[0]) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
    str += "an ";
    break;
  default:
    str += "a ";
  }
  str += tstr + " ";
  switch((time() % (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 51..150:
    str += "spring prime";
    break;
  case 151..250:
    str += "summer prime";
    break;
  case 251..350:
    str += "autumn prime";
    break;
  case 351..450:
    str += "spindlewinter";
    break;
  case 451..550:
    str += "secundus spring";
    break;
  case 551..650:
    str += "secundus summer";
    break;
  case 651..750:
    str += "secundus autumn";
    break;
  default:
    str += "backspindlewinter";
  }
  str += "'s "+ query_tod() +" with ";
  switch(wind) {
    case -1000..5: str += "almost no wind"; break;
    case 6..10: str += "a gentle breeze"; break;
    case 11..15: str += "a steady breeze"; break;
    case 16..20: str += "a strong breeze"; break;
    case 21..30: str += "a steady wind"; break;
    case 31..40: str += "gusty winds"; break;
    case 41..50: str += "strong winds"; break;
    case 51..60: str += "gale-force winds"; break;
    case 61..1000: str += "storm-force winds"; break;
    default: str += "no wind at all"; break;
  }
  if (!obscured) {
    if(rain)
      str += ", ";
    else
      str += " and ";
    switch(cloud) {
      case -1000..5: str += "a beautifully clear sky"; break;
      case 6..10: str += "a few high level cirrus clouds"; break;
      case 11..25: str += "scattered puffy clouds"; break;
      case 26..40: str += "some puffy clouds"; break;
      case 41..60: str += "many puffy clouds"; break;
      case 61..80: str += "medium cloud cover"; break;
      case 81..110: str += "dense cloud cover"; break;
      case 111..130: str += "packed cloud cover"; break;
      case 131..160: str += "thick black clouds"; break;
      case 161..1000: str += "thick heavy storm clouds"; break;
    }
  }
  if(rain) {
    str += " and ";
    switch(rain) {
      case -1000..20: str += "light"; break;
      case 21..40:
        if(wind < 20)
          str += "steady";
        else
          str += "driving";
      break;
      case 41..60: str += "heavy"; break;
      case 61..500:
        if(rt == WEATHER_RAIN_TYPE)
          str += "torrential";
        else
          str += "very heavy";
      break;
    }
    str += " ";
    str += ({"", "snow", "sleet", "rain"})[rt];
  }
  if (obscured) {
    str += ".  " + obscured;
  }
  if((rain > 20) && (wind > 30)) {
    if (obscured)
      str += ".\nPeals of thunder echo overhead";
    else
      str += ".\nPeals of thunder and streaks of lightning rend the sky";
  }
  return str;
}
int next_update() {
  return _lastupdate + UPDATE_SPEED;
}
void dest_me() {
  unguarded((: save_object, FILE_NAME :));
}
int query_rain_type(int temp, int rain) {
  int type;
  if (rain > 0)
    switch(temp) {
    case -1000..-2:
      type = WEATHER_SNOW_TYPE;
      break;
    case -1..3:
      type = WEATHER_SLEET_TYPE;
      break;
    case 4..1000:
      type = WEATHER_RAIN_TYPE;
      break;
    }
  else
    type = WEATHER_NO_RAIN_TYPE;
  return type;
}
int query_snowing(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return (query_rain_type(warray[0], warray[3]) == WEATHER_SNOW_TYPE)? 1 : 0;
  return (query_rain_type(temperature_index(env),
                          rain_index(env)) == WEATHER_SNOW_TYPE) ? 1 : 0;
}
int query_raining(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
  {
    return (query_rain_type(warray[0], warray[3]) > WEATHER_SNOW_TYPE) ? 1 : 0;
  }
  return (query_rain_type(temperature_index(env),
                          rain_index(env)) > WEATHER_SNOW_TYPE) ? 1 : 0;
}
int query_temperature(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[0];
  return temperature_index(env);
}
int query_cloud(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[1];
  return cloud_index(env);
}
int query_windsp(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[2];
  return calc_actual(env, WINDSP);
}
int calc_variance(string climate, int type, int seasonal) {
  int diff, ret;
  diff = seasonal - _pattern[climate][type];
  if(diff < 0)
    ret = - random(diff * 2);
  else
    ret = random(diff * 2);
  if(random(2))
    ret += random(_variance[type]);
  else
    ret -= random(_variance[type]);
  return ret;
}
void set_day() {
  int min;
  _toy = (day_number() < (DIY / 2)) ? day_number() :
  (DIY / 2) - (day_number() % (DIY / 2));
  min = minute_number();
  _sunrise = 6 * AM_MINUTES_PER_HOUR;
  _sunset = 20 * AM_MINUTES_PER_HOUR;
  _sunrise += (100 - _toy);
  _sunset -= (100 - _toy);
  if((min <= _sunrise) || (min >= _sunset))
    _day = 0;
  else {
    if((min > _sunrise) && (min < _sunrise + 30))
      _day = (min-_sunrise) / 3;
    else if((min < _sunset) && (min > _sunset - 30))
      _day = (_sunset-min) / 3;
    else
      _day = 10;
  }
}
void migrate(string climate, int type) {
  int diff;
  diff = _pattern[climate][type] - _current[climate][type];
  if(diff > (_variance[type] / 2))
    diff = _variance[type] / 2;
  if(diff < 0)
    _current[climate][type] -= random(random(-diff));
  else
    _current[climate][type] += random(random(diff));
}
int check_umbrella(object ob) {
  if ( ob )
    return (int)ob->query_property( "umbrella" );
  return 0;
}
void do_inform(object who, int old_temp, int old_cloud, int old_rain,
               int old_day) {
  string str, where;
  int new_temp, new_cloud, new_wind, new_rain;
  int old_rain_type, new_rain_type;
  int *warray;
  new_temp = temperature_index(environment(who));
  new_rain = rain_index(environment(who));
  new_wind = calc_actual(environment(who), WINDSP);
  new_cloud = cloud_index(environment(who));
  if(function_exists("room_weather", environment(who)) &&
     !catch(warray = (int *)environment(who)->room_weather(new_temp, new_cloud,
                                                   new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }
  if(who->query_name() == "ceres")
    tell_object(who, sprintf("%s: ot %d, or: %d, oc: %d, "
                             "nt %d, nr: %d, nc: %d, nw: %d",
                             who->query_name(),
                             old_temp, old_rain, old_cloud, new_temp,
                             new_rain, new_cloud, new_wind));
  old_rain_type = query_rain_type(old_temp, old_rain);
  new_rain_type = query_rain_type(new_temp, new_rain);
  str = "";
  if(_day != old_day) {
    where = sun_direction( 1 );
    if((old_day == 10)  && (_day < 10))
      str += "The sun starts to set slowly on the "+where+" horizon.\n";
    else if((old_day > 0) && (_day == 0))
      str += "The sun disappears from view below the "+where+" horizon.\n";
    else if((old_day > _day) && (_day < 9) && (_day > 0))
      str += "The sun sinks further below the "+where+" horizon.\n";
    where = sun_direction( 0 );
    if((_day > 0) && (old_day == 0))
      str += "The "+where+" sky starts to lighten as the sun peeks over the "+
        "horizon.\n";
    else if((_day == 10) && (old_day < 10))
      str += "The sun rises above the "+where+" horizon and greets you "+
        "for a new day.\n";
    else if((_day > old_day) && (_day < 9) && (_day > 0))
      str += "The sun rises further above the "+where+" horizon lightening "+
        "the sky as morning arrives.\n";
  }
  if(_day && (old_cloud != new_cloud)) {
    if((old_cloud < 60) && (new_cloud > 20) && (!(new_cloud % 2)))
      str += "The " + query_tod()+ " sun disappears behind a cloud.\n";
    else if((old_cloud > 20) && (new_cloud < 60) && (new_cloud % 2))
      str += "The " + query_tod() + " sun peeks out from behind a cloud.\n";
  }
  if(old_rain_type != new_rain_type) {
    str += ({"", "It has stopped snowing", "It has stopped sleeting",
             "It has stopped raining"})[old_rain_type];
    if(old_rain_type && new_rain_type)
      str += " and started ";
    else if(new_rain_type)
      str += "It has started ";
    str += ({"", "snowing", "sleeting", "raining"})[new_rain_type];
    str += ".\n";
  } else if(new_rain_type > 0)
    str += "The "+({"", "snow", "sleet", "rain"})[new_rain_type]+
      " continues to fall.\n";
  if(new_rain_type)
    if((!sizeof(filter_array(who->query_holding(), "check_umbrella",
                            this_object())) &&
       !sizeof(filter_array(who->query_wearing(), "check_umbrella",
                          this_object()))) || !random(50))
    {
      who->add_effect("/std/effects/other/wetness",
                      ((new_rain * new_rain_type) / 2) * (UPDATE_SPEED/60));
    }
  if(str != "")
    tell_object(who, who->colour_event("weather", "%^ORANGE%^")+str+
                "%^RESET%^");
}
string sun_direction(int which) {
  switch(((time()+(AM_SECONDS_PER_HALF_YEAR * which)) %
          (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 0..174:
    return "widdershins";
  case 175..225:
    return "hubwards";
  case 226..574:
    return "turnwise";
  case 575..625:
    return "rimward";
  default:
    return "widdershins";
  }
}
void do_room_inform(object what, int old_temp, int old_cloud, int old_rain,
        int old_day, int notifications) {
  int new_cloud, new_rain, new_wind, new_temp;
  int *warray;
  int has_changed = 0;
  new_temp = temperature_index(what);
  new_cloud = cloud_index(what);
  new_wind = calc_actual(what, WINDSP);
  new_rain = rain_index(what);
  if(function_exists("room_weather", what) &&
     !catch(warray = (int *)what->room_weather(new_temp, new_cloud,
                                       new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }
  if(_day != old_day && (notifications & NOTIFY_DAY))
    has_changed += NOTIFY_DAY;
  if(old_temp != new_temp && (notifications & NOTIFY_TEMPERATURE))
    has_changed += NOTIFY_TEMPERATURE;
  if(old_cloud != new_cloud && (notifications & NOTIFY_CLOUD))
    has_changed += NOTIFY_CLOUD;
  if(old_rain != new_rain && (notifications & NOTIFY_RAIN))
    has_changed += NOTIFY_RAIN;
  if(has_changed) {
    call_out( "notify_room", 1, what, has_changed,
      _day, new_temp, new_cloud, new_rain );
  }
}
void notify_room( object what, int has_changed,
  int day, int temp, int cloud, int rain)
{
  if(what)
    what->event_weather( has_changed, day, temp, cloud, rain);
}
int query_sunrise(int doy) {
  int toy;
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (6 * AM_MINUTES_PER_HOUR) + (100 - toy);
}
int query_sunset(int doy) {
  int toy;
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (20 * AM_MINUTES_PER_HOUR) - (100 - toy);
}
void update_pattern() {
  int toy, temp, wind, cloud, tvar, wvar, cvar;
  string climate;
  call_out("update_pattern", CYCLE_SPEED);
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));
  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af":
      temp = 30 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am":
      temp = 30 + (toy / 20);
      cloud = -25 + sqrt(toy) * 10;
      wind = random(10);
      break;
    case "Aw":
      temp = 20 + (toy / 10);
      cloud = toy - 50;
      wind = random(10);
      break;
    case "Bw":
      temp = 30 + (toy / 20);
      cloud = (100 - toy/2) - 50;
      wind = random(10);
      break;
    case "Bs":
      temp = 25 + (toy / 20);
      cloud = ((200 - toy) / 2) - 12;
      wind = random(10);
      break;
    case "Cfa":
      temp = (toy / 8) + 15;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Cs":
      temp = (toy / 12) + 10;
      cloud = ((225 - toy) / 2) - 50;
      wind = 10 - (toy / 8);
      break;
    case "Cfb":
      temp = (toy / 6) - 5;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Dw":
      temp = (toy / 5) - 10;
      cloud = toy / 2;
      wind = 15 - (toy / 8);
      break;
    case "Ds":
      temp = (toy / 5) - 10;
      cloud = (200 - toy) / 2;
      wind = 15 - (toy / 8);
      break;
    case "Df":
      temp = (toy / 5) - 10;
      cloud = ((200 - toy) / 4) + 50;
      wind = 15 - (toy / 8);
      break;
    case "Et":
      temp = (toy / 20) - 10;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "Ef":
      temp = (toy / 10) - 30;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "H":
      temp = (toy / 10) - 10;
      cloud = ((225 - toy) / 2);
      wind = 35 - (toy / 8);
      break;
    }
    tvar = calc_variance(climate, TEMP, temp);
    cvar = calc_variance(climate, CLOUD, cloud);
    wvar = calc_variance(climate, WINDSP, wind);
    _pattern[climate] =  ({ temp + tvar, cloud + cvar, wind + wvar });
  }
  unguarded((: save_object, FILE_NAME :));
}
void update_weather() {
  int *warray, notifications;
  mapping list, roomlist, newrooms;
  object user, room;
  string climate;
  _lastupdate = time();
  call_out("update_weather", UPDATE_SPEED);
  list = ([ ]);
  roomlist = ([ ]);
  foreach(user in filter(users(),
                         (: $1 && environment($1) &&
                          environment($1)->query_property("location") ==
                          "outside" :))) {
    if(function_exists("room_weather", environment(user)) &&
       !catch(warray = (int *)environment(user)->room_weather(
                                 (int)temperature_index(environment(user)),
                                 (int)cloud_index(environment(user)),
                                 (int)calc_actual(environment(user), WINDSP),
                                 (int)rain_index(environment(user))))) {
      list[user] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      list[user] = ({ (int)temperature_index(environment(user)),
                        (int)cloud_index(environment(user)),
                        (int)rain_index(environment(user)),
                        _day});
    }
  }
  newrooms = ([ ]);
  foreach (room, notifications in _rooms)  {
    if (room)
      newrooms[room] = notifications;
  }
  _rooms = copy(newrooms);
  foreach(room, notifications in _rooms) {
    if(function_exists("room_weather", room) &&
       !catch(warray = (int *)room->room_weather((int)temperature_index(room),
                                                 (int)cloud_index(room),
                                               (int)calc_actual(room, WINDSP),
                                                 (int)rain_index(room) ))) {
      roomlist[room] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      roomlist[room] = ({ (int)temperature_index(room),
                            (int)cloud_index(room),
                            (int)rain_index(room),
                            _day });
    }
  }
  if((moonupdate + (AM_SECONDS_PER_DAY * 2)) < time()) {
    mooncycle++;
    mooncycle %= 14;
    moonupdate = time();
  }
  foreach(climate in CLIMATES) {
    migrate(climate, TEMP);
    migrate(climate, CLOUD);
    migrate(climate, WINDSP);
  }
  set_day();
  unguarded((: save_object, FILE_NAME :));
  foreach(user, warray in list) {
    do_inform(user, warray[0], warray[1], warray[2], warray[3]);
  }
  foreach(room, notifications in _rooms) {
      do_room_inform(room, roomlist[room][0], roomlist[room][1],
                     roomlist[room][2], roomlist[room][3], notifications);
      map_delete(_rooms, room);
  }
}
void print_stats(object here) {
  string climate, *weather;
  if(here)
    climate = here->query_climate();
  weather = ({ temperature_index(here), cloud_index(here),
                 calc_actual(here, WINDSP) });
  printf("Climate: %s toy: %d tod: %s [%d]\n"
         "here: %O\ncurrent: %O\npattern: %O\nvariance: %O\n",
         climate, _toy, query_tod(), 10 - query_day(here), weather,
         _current[climate], _pattern[climate], _variance);
  printf("Sunrise at: %d:%02d, sunset at: %d:%02d\n",
         _sunrise/60, _sunrise%60, _sunset/60, _sunset%60);
}
int *query_mooncycle() {
  return ({ mooncycle, 0});
}
void set_variance(int temp, int cloud, int wind) {
  _variance = ({temp, cloud, wind});
  unguarded((: save_object, FILE_NAME :));
}
void reset_weather() {
  int toy, temp, wind, cloud;
  string climate;
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));
  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af":
      temp = 25 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am":
      temp = 20 + (toy / 20);
      cloud = -25 + sqrt(toy) * 10;
      wind = random(10);
      break;
    case "Aw":
      temp = 20 + (toy / 20);
      cloud = toy - 50;
      wind = random(10);
      break;
    case "Bw":
      temp = 30 + (toy / 20);
      cloud = (100 - toy/2) - 50;
      wind = random(10);
      break;
    case "Bs":
      temp = 25 + (toy / 20);
      cloud = ((200 - toy) / 2) - 12;
      wind = random(10);
      break;
    case "Cfa":
      temp = (toy / 8) + 15;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Cs":
      temp = (toy / 12) + 10;
      cloud = ((225 - toy) / 2) - 50;
      wind = 10 - (toy / 8);
      break;
    case "Cfb":
      temp = (toy / 6) - 5;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Dw":
      temp = (toy / 5) - 10;
      cloud = toy / 2;
      wind = 15 - (toy / 8);
      break;
    case "Ds":
      temp = (toy / 5) - 10;
      cloud = (200 - toy) / 2;
      wind = 15 - (toy / 8);
      break;
    case "Df":
      temp = (toy / 5) - 10;
      cloud = ((200 - toy) / 4) + 50;
      wind = 15 - (toy / 8);
      break;
    case "Et":
      temp = (toy / 20) - 10;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "Ef":
      temp = (toy / 10) - 30;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "H":
      temp = (toy / 10) - 10;
      cloud = ((225 - toy) / 2);
      wind = 35 - (toy / 8);
      break;
    }
    _pattern[climate] =  ({ temp, cloud, wind });
    _current[climate] = ({ temp, cloud, wind });
  }
  unguarded((: save_object, FILE_NAME :));
}
mapping query_dynamic_auto_load() {
   return ([ "rooms" : _rooms ]);
}
void init_dynamic_arg(mapping map, object) {
   _rooms = map["rooms"];
   if (!_rooms) {
      _rooms = ([ ]);
   }
}

==================================================
FILE: handlers/world_map.c
==================================================

#include <terrain_map.h>
class region {
   mixed* terrains;
   string* features;
   int last_touched;
}
#define SAVE_DIR "/save/world_map/"
#define BOUNDARY TERRAIN_MAP_WORLD_BOUNDARY
#define REGION_SIZE TERRAIN_MAP_WORLD_REGION_SIZE
#define REGION_BOUNDARY TERRAIN_MAP_WORLD_REGION_BOUNDARY
#define OFFSET TERRAIN_MAP_WORLD_OFFSET
#define REGION_WIDTH TERRAIN_MAP_WORLD_REGION_WIDTH
void load_me();
private void generate_main_templates();
private void generate_blocking_templates();
private nosave mixed* _regions;
private nosave mixed* _templates;
private nosave mixed* _blocking_templates;
void create() {
   _regions = allocate(REGION_WIDTH, (: allocate(REGION_WIDTH) :));
   seteuid(getuid());
   generate_main_templates();
   generate_blocking_templates();
}
private void generate_main_templates() {
   int size;
   mixed* last;
   int x;
   int y;
   int u;
   int v;
   int e;
   int i;
   _templates = allocate(12);
   last = ({ ({ 1 }) });
   for (size = 0; size < sizeof(_templates); size++) {
      for (i = 0; i < sizeof(last); i++) {
         last[i] = ({ 0 }) + last[i] + ({ 0 });
      }
      _templates[size] = ({ allocate((size + 1) * 2 + 1) }) + last +
                         ({ allocate((size + 1) * 2 + 1) });
      x = 0;
      y = size + 1;
      u = 1;
      v = 2 * (size + 1) - 1;
      e = 0;
      while (x <= y) {
         _templates[size][size + 1 + x][size + 1 + y] = 1;
         _templates[size][size + 1 + x][size + 1 - y] = 1;
         _templates[size][size + 1 - x][size + 1 + y] = 1;
         _templates[size][size + 1 - x][size + 1 - y] = 1;
         _templates[size][size + 1 + y][size + 1 + x] = 1;
         _templates[size][size + 1 + y][size + 1 - x] = 1;
         _templates[size][size + 1 - y][size + 1 + x] = 1;
         _templates[size][size + 1 - y][size + 1 - x] = 1;
         if (size > 0) {
            _templates[size][size + 1 + x - 1][size + 1 + y] = 1;
            _templates[size][size + 1 + x - 1][size + 1 - y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 + y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 - y] = 1;
            _templates[size][size + 1 + y - 1][size + 1 + x] = 1;
            _templates[size][size + 1 + y - 1][size + 1 - x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 + x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 - x] = 1;
         }
         x++;
         e += u;
         u += 2;
         if (v < 2 * e) {
            y--;
            e -= v;
            v -= 2;
         }
         if (x > y) {
            break;
         }
      }
      last = copy(_templates[size]);
   }
}
mixed* generate_blocking(int x, int y, string* start,
                          string* straight, string* diagonal) {
   int i;
   int dx;
   int ex;
   int dy;
   int balance;
   int sx;
   int sy;
   int blocked;
   int blocked_straight;
   int blocked_diagonal;
   int first_block;
   first_block = -1;
   for (i = 0; i <= sizeof(start); i++) {
      sx = 0;
      sy = 0;
      ex = sizeof(start);
      dx = sizeof(start);
      dy = i;
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      blocked_straight = blocked_diagonal = blocked = 0;
      while (sx != ex) {
         if (blocked) {
            if (first_block == -1) {
               first_block = i;
            }
            start[sy] = start[sy][0..sx-1] + "*" + start[sy][sx+1..];
         } else {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
         }
         if (blocked_straight) {
            straight[sy] = straight[sy][0..sx-1] + "*" + straight[sy][sx+1..];
         } else {
            straight[sy] = straight[sy][0..sx-1] + " " + straight[sy][sx+1..];
         }
         if (blocked_diagonal) {
            diagonal[sy] = diagonal[sy][0..sx-1] + "*" + diagonal[sy][sx+1..];
         } else {
            diagonal[sy] = diagonal[sy][0..sx-1] + " " + diagonal[sy][sx+1..];
         }
         if (sx == x && sy == y) {
            blocked_diagonal = blocked_straight = blocked = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "@" + diagonal[sy][sx+1..];
            start[sy] = start[sy][0..sx-1] + "@" + start[sy][sx+1..];
            straight[sy] = straight[sy][0..sx-1] + "@" + straight[sy][sx+1..];
         }
         if (sx == x && sy == y + 1) {
            blocked_straight = 1;
            straight[sy] = straight[sy][0..sx-1] + "|" + straight[sy][sx+1..];
         }
         if (sx == x + 1 && sy == y + 1) {
            blocked_diagonal = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "\\" + diagonal[sy][sx+1..];
         }
         if (balance >= 0) {
            sy++;
            balance -= dx;
         }
         balance += dy;
         sx++;
      }
   }
   if (first_block >= (sizeof(start) / 2)) {
      for (i = sizeof(start); i >= 6; i--) {
         sx = 0;
         sy = 0;
         ex = sizeof(start);
         dx = sizeof(start);
         dy = i;
         dy <<= 1;
         balance = dy - dx;
         dx <<= 1;
         blocked = 0;
         while (sx != ex) {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
            if (sx == x && sy == y) {
               break;
            }
            if (balance >= 0) {
               sy++;
               balance -= dx;
            }
            balance += dy;
            sx++;
         }
      }
   }
   return ({ start, straight, diagonal });
}
private void generate_blocking_templates() {
   int x;
   int y;
   int size;
   mixed* basic;
   string* start;
   string line;
   basic = _templates[<1];
   size = sizeof(_templates);
   line = "";
   for (x = 0; x < size + 1; x++) {
      line += " ";
   }
   start = allocate(size + 1, line);
   _blocking_templates = allocate(size + 1, ({ }));
   for (x = 0; x < size + 1; x++) {
      _blocking_templates[x] = allocate(size + 1);
   }
   for (x = 0; x < size + 1; x++) {
      for (y = x; y < size + 1; y++) {
         if (basic[x + size][y + size] && (x != 0 || y != 0)) {
            _blocking_templates[x][y] = generate_blocking(y, x, copy(start), copy(start), copy(start));
         }
      }
   }
}
string *query_blocking_template(int x, int y, int type) {
   if (arrayp(_blocking_templates[x][y])) {
      return copy(_blocking_templates[x][y][type]);
   }
   return 0;
}
mixed* query_map_template(int size) {
   return copy(_templates[size - 1]);
}
void load_region(int x, int y) {
   class region region;
   string fname;
   if (_regions[x][y]) {
      _regions[x][y]->last_touched = time();
      return ;
   }
   fname = SAVE_DIR + "region_" + x + "_" + y;
   if (unguarded((: file_size($(fname)) :)) > 0) {
      region = unguarded( (: restore_variable(read_file($(fname), 1)) :));
   } else {
      region = new(class region,
                   terrains : allocate(REGION_SIZE, (: allocate(REGION_SIZE) :)),
                   features : ({ }));
   }
   _regions[x][y] = region;
   _regions[x][y]->last_touched = time();
}
void save_region(int x, int y) {
   string fname;
   class region region;
   if (_regions[x][y]) {
      region = _regions[x][y];
      fname = SAVE_DIR + "region_" + x + "_" + y;
      unguarded( (: write_file($(fname), save_variable($(region)), 1) :));
   }
}
int add_terrain(string path, int x1, int y1, int x2, int y2) {
   int tmp;
   int region_x;
   int region_y;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   if (x2 - x1 != BOUNDARY ||
       y2 - y1 != BOUNDARY) {
      debug_printf("Incorrect terrain size (%d x %d): %s\n",
                  x2 - x1, y2 - y1, path);
      return 0;
   }
   if (x1 % BOUNDARY ||
       y1 % BOUNDARY) {
      debug_printf("Incorrect boundary (%d - %d): %s\n",
                  x1 % BOUNDARY, y1 % BOUNDARY, path);
      return 0;
   }
   x1 = ((x1 + OFFSET) / BOUNDARY);
   y1 = ((y1 + OFFSET) / BOUNDARY);
   region_x = x1 / REGION_SIZE;
   region_y = y1 / REGION_SIZE;
   load_region(region_x, region_y);
   x2 = x1 % REGION_SIZE;
   y2 = y1 % REGION_SIZE;
   _regions[region_x][region_y]->terrains[x2][y2] = path;
   save_region(region_x, region_y);
   debug_printf("Added terrain (%d {%d}, %d {%d}) [%d,  %d]: %s\n",
                 x1, x2, y1, y2, region_x, region_y, path);
   return 1;
}
string find_terrain_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_SIZE;
   region_y = y / REGION_SIZE;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->terrains[x % REGION_SIZE][y % REGION_SIZE];
}
string find_room_at(int x, int y) {
   string path;
   path = find_terrain_at(x, y);
   if (path) {
      return path->find_room_at_real_coord(x, y);
   }
   return 0;
}
void add_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         if (feature->is_inside_region(
                                (x * REGION_WIDTH) * BOUNDARY - OFFSET,
                                (y * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((x + 1) * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((y + 1) * REGION_WIDTH) * BOUNDARY - OFFSET)) {
            load_region(x, y);
            _regions[x][y]->features |= ({ feature });
            save_region(x, y);
            debug_printf("Added feature to region %d, %d\n", x, y);
         }
      }
   }
}
void remove_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         load_region(x, y);
         if (member_array(feature, _regions[x][y]->features) != -1) {
            _regions[x][y]->features -= ({ feature });
            save_region(x, y);
         }
      }
   }
}
string* query_features_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_WIDTH;
   region_y = y / REGION_WIDTH;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->features;
}
string* query_features_in_region(int x1_orig, int y1_orig, int x2_orig, int y2_orig) {
   int region_x;
   int region_y;
   int x1;
   int y1;
   int x2;
   int y2;
   int tmp;
   string* features;
   string feat;
   x1 = ((x1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y1 = ((y1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   x2 = ((x2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y2 = ((y2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   features = ({ });
   if (x1 < 0) {
      x1 = 0;
   }
   if (y1 < 0) {
      y1 = 0;
   }
   if (x2 >= REGION_WIDTH) {
      x2 = REGION_WIDTH - 1;
   }
   if (y2 >= REGION_WIDTH) {
      y2 = REGION_WIDTH - 1;
   }
   for (region_x = x1; region_x <= x2; region_x++) {
      for (region_y = y1; region_y <= y2; region_y++) {
         load_region(region_x, region_y);
         foreach (feat in _regions[region_x][region_y]->features) {
            if (feat->is_inside_region(x1_orig, y1_orig, x2_orig, y2_orig)) {
               features |= ({ feat });
            }
         }
      }
   }
   return features;
}

==================================================
FILE: handlers/inherit/case_control.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
private mapping _open_cases;
private mapping _recently_closed_cases;
private mapping _closed_cases;
private int _next_case_id;
private int _next_note_id;
void save_me();
void send_council_inform(string area, int only_magistrates,
                         string mess);
void create() {
   _open_cases = ([ ]);
   _closed_cases = ([ ]);
   _recently_closed_cases = ([ ]);
   _next_case_id = 1;
   _next_note_id = 1;
}
void create_area(string area) {
   if (_open_cases[area]) {
      return ;
   }
   _open_cases[area] = ({ });
   _closed_cases[area] = ({ });
   _recently_closed_cases[area] = ({ });
}
int* query_open_cases(string area) {
   return _open_cases[area];
}
int* query_closed_cases(string area) {
   return _closed_cases[area];
}
int* query_recently_closed_cases(string area) {
   return _recently_closed_cases[area];
}
string query_case_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("cases/%02d/%d_case", id % 20, id);
}
int query_next_case_id() {
   int next;
   do {
      next = _next_case_id++;
   } while (sizeof(stat(query_case_file_name(next))));
   return next;
}
private void save_case(class nomic_case stuff) {
   string fname;
   string tmp;
   fname = query_case_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp), 1) :));
}
string query_note_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("notes/%02d/%d_note", id % 20, id);
}
int query_next_note_id() {
   int next;
   do {
      next = _next_note_id++;
   } while (sizeof(stat(query_note_file_name(next))));
   return next;
}
private void save_note(class nomic_case_note stuff) {
   string fname;
   string tmp;
   fname = query_note_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp) ) :));
}
private int create_case(string opener, string short, string* people) {
   class nomic_case new_case;
   new_case = new(class nomic_case);
   new_case->id = query_next_case_id();
   new_case->opener = opener;
   new_case->short = short;
   new_case->people = people;
   new_case->notes = ({ });
   new_case->events = ({ });
   new_case->time_opened = time();
   save_case(new_case);
   return new_case->id;
}
private int create_note(string person, string text) {
   class nomic_case_note new_note;
   new_note = new(class nomic_case_note);
   new_note->id = query_next_note_id();
   new_note->person = person;
   new_note->text = text;
   new_note->time_created = time();
   save_note(new_note);
   return new_note->id;
}
private class nomic_case_event create_event(int type, string person,
                                            string mess, mixed data) {
   class nomic_case_event event;
   event = new(class nomic_case_event);
   event->type = type;
   event->mess = mess;
   event->person = person;
   event->event_time = time();
   event->data = data;
   return event;
}
string query_event_name(int type) {
   switch (type) {
   case NOMIC_CASE_EVENT_CLOSE :
      return "closed case";
   case NOMIC_CASE_EVENT_APPEAL :
      return "appealed case";
   case NOMIC_CASE_EVENT_ADD_PERSON :
      return "add person";
   case NOMIC_CASE_EVENT_REMOVE_PERSON :
      return "remove person";
   default :
      return "unknown";
   }
}
class nomic_case query_open_case(string area, int id) {
   string fname;
   string tmp;
   if (!_open_cases[area]) {
      return 0;
   }
   if (member_array(id, _open_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_recently_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_recently_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _recently_closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case_note query_note(int note_num) {
   string fname;
   string tmp;
   fname = query_note_file_name(note_num);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
int add_new_case(string area, string opener, string short, string* people) {
   int case_id;
   if (!_open_cases[area]) {
      return 0;
   }
   case_id = create_case(opener, short, people);
   _open_cases[area] += ({ case_id });
   save_me();
   send_council_inform(area, 1, opener + " opened a case with " +
                      query_multiple_short(people));
   return case_id;
}
int close_case(string area, int id, string closer, string result,
               mixed data) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(result)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_CLOSE, closer, result, data);
   the_case->events += ({ event });
   save_case(the_case);
   _open_cases[area] -= ({ the_case->id });
   _recently_closed_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, closer + " closed a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int appeal_case(string area, int id, string appealer, string reason) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_recently_closed_case(area, id);
   if (!the_case || !stringp(reason)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_APPEAL, appealer, reason, 0);
   the_case->events += ({ event });
   save_case(the_case);
   _recently_closed_cases[area] -= ({ the_case->id });
   _open_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, appealer + " appeals a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int add_note_to_case(string area, int id, string person, string text) {
   class nomic_case the_case;
   int note_id;
   the_case = query_open_case(area, id);
   if (!the_case) {
      return 0;
   }
   note_id = create_note(person, text);
   the_case->notes += ({ note_id });
   save_case(the_case);
   save_me();
   return 1;
}
int add_person_to_case(string area, int id, string adder,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) != -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_ADD_PERSON, adder, text, 0);
   the_case->events += ({ event });
   the_case->people += ({ person });
   save_case(the_case);
   return 1;
}
int remove_person_from_case(string area, int id, string remover,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) == -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_REMOVE_PERSON, remover, text, 0);
   the_case->events += ({ event });
   the_case->people -= ({ person });
   save_case(the_case);
   return 1;
}
void update_recently_closed_cases() {
   string area;
   int* stuff;
   int id;
   class nomic_case the_case;
   class nomic_case_event event;
   int last_close;
   foreach (area, stuff in _recently_closed_cases) {
      foreach (id in stuff) {
         the_case = query_recently_closed_case(area, id);
         last_close = 0;
         foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
               last_close = event->event_time;
            }
         }
         if (last_close < time() - NOMIC_CASE_APPEAL_TIME) {
            _closed_cases[area] += ({ id });
            _recently_closed_cases[area] -= ({ id });
         }
      }
   }
}
