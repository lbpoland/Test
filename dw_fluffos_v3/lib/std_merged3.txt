
==================================================
FILE: shops/inherit/player_craft_shop_base.c
==================================================

inherit "/std/shops/inherit/craft_shop_category";
inherit "/std/shops/inherit/expression_util";
inherit "/std/shops/inherit/person_expressions";
inherit "/std/shops/inherit/object_expressions";
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <shops/craft_shop.h>
#include <player_handler.h>
#include <clubs.h>
#define EXPRESSION_NO_CLASSES
#include <expressions.h>
#include <mail.h>
#include <nroff.h>
#include <player_handler.h>
#define PLAYER_CRAFT_SHOP_CHECK_PROP "player craft shop check"
#define PLAYER_CRAFT_SHOP_SELL      1
#define PLAYER_CRAFT_SHOP_SELL_AUTO 2
#define PLAYER_CRAFT_SHOP_BUY       3
#define PLAYER_CRAFT_SHOP_APPROVE   4
#define PLAYER_CRAFT_SHOP_EXPR_DENY   1
#define PLAYER_CRAFT_SHOP_EXPR_ACCEPT 2
class approval_item  {
   mixed value;
   string list_name;
   int markup;
   int final_cost;
}
class expression_type {
   int type;
   class parse_node* condition;
   class parse_node* value;
   string list_name;
}
class approval {
   mixed hairy;
   class expression_type* expressions;
   int low_cost;
   int high_cost;
   mapping items;
   int num_allowed;
   int high_cost_deny;
}
class approval_obs {
   string seller;
   string category;
   int value;
   string name;
   int* saved;
   int enter_time;
   int* checkout;
   string* shorts;
}
#if USE_TRANSACTIONS
class shop_transaction {
   int time;
   string person;
   string objects;
   string name_cat;
   int type;
   int amount;
   mixed extra;
}
#endif
class shop_stats {
   int num_sold;
   int value_sold;
   string seller;
   string name;
}
class helper_stats {
   int num_approved;
   int total_cost;
   int num_rejected;
   mapping items_approved;
}
class item_stats {
   int num_sold;
   int total_cost;
   int total_made;
   int num_bought;
}
class weekly_stats {
   int num_sold;
   int total_cost;
   int total_made;
   int num_bought;
   mapping items;
   mapping helper;
}
class seller_information {
   int max_sellable;
   int value_limit;
   int deny_value_limit;
}
private class approval_obs* _waiting_for_approval;
private class approval_obs* _approved;
private class approval _automatic_approval;
private string* _list_names;
private int _automatic_percentage;
private int _current_save_num;
private int _total_outgoing;
private int _total_ingoing;
private int _time_of_mail;
private class parse_node *_tax_expression;
#if USE_TRANSACTIONS
private class shop_transaction* _transactions;
#endif
private mapping _sold_stats;
private int _stats_start;
private mapping _sellers;
private mapping _num_checked_so_far;
private string* _helpers;
private class weekly_stats _weekly_stats;
private nosave string _parcel_post;
private nosave int _something_checkedout;
private nosave int _maximum_inventory;
private nosave int _round_value;
private nosave int _max_list_names;
private nosave int _max_items_in_queue;
protected void confirm_approval(string answer, class approval_obs approve, int final_cost);
private object* variable_objects(string seller, int cost, object* ob);
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category);
private string variable_sale_name(string seller, int cost, object* ob, string name, string category);
private string variable_sale_category(string seller, int cost, object* ob, string name, string category);
private int function_inventory_number(string short, string seller, int cost, object* ob);
string query_owner();
int is_allowed(string person);
void event_save(object thing);
int is_open_for(string type, string name);
void create() {
   _round_value = 1;
   if (!_waiting_for_approval) {
      _waiting_for_approval = ({ });
   }
   if (!_approved) {
      _approved = ({ });
   }
   if (!_list_names) {
      _list_names = ({ });
   }
   if (!_automatic_approval) {
      _automatic_approval = new(class approval);
      _automatic_approval->expressions = ({ });
      _automatic_approval->items = ([ ]);
   }
   if (!_automatic_percentage) {
      _automatic_percentage = 10;
   }
#if USE_TRANSACTIONS
   if (!_transactions) {
      _transactions = ({ });
   }
#endif
   if (!_sold_stats) {
      _sold_stats = ([ ]);
   }
   if (!_helpers) {
      _helpers = ({ });
   }
   if (!_stats_start) {
      _stats_start = time();
   }
   if (!_sellers) {
      _sellers = ([ ]);
   }
   if (!_num_checked_so_far) {
      _num_checked_so_far = ([ ]);
   }
   if (!_tax_expression)  {
      _tax_expression = ({ });
   }
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   set_cut(100);
   _max_items_in_queue = 100;
   craft_shop_category::create();
   expression_util::create();
   set_always_ask_price(1);
   add_allowed_variable("objects", EXPRESSION_TYPE_OBJECT +
                                   EXPRESSION_TYPE_ARRAY_OFFSET,
                        (: variable_objects :) );
   add_allowed_variable("salecost", EXPRESSION_TYPE_MONEY,
                        (: variable_sale_cost :) );
   add_allowed_variable("salename", EXPRESSION_TYPE_STRING,
                        (: variable_sale_name :) );
   add_allowed_variable("salencategory", EXPRESSION_TYPE_STRING,
                        (: variable_sale_category :) );
   set_expression_type("shop");
   object_expressions::create();
   person_expressions::create();
   set_no_royalty_commands(1);
}
int is_helper(string person) {
   if (!_helpers) {
      _helpers = ({ });
   }
   return member_array(person, _helpers) != -1 ||
          is_allowed(person);
}
private string strip_quotes(string str)  {
   if (str)  {
      if (str[0] == '\"')  str = str[1 .. ];
      if (str[<1] == '\"')  str = str[0 .. <2];
   }
   return str;
}
void set_maximum_waiting_queue_size(int size) {
   _max_items_in_queue = size;
}
int query_maximum_waiting_queue_size() {
   return _max_items_in_queue;
}
void set_maximum_inventory_size(int size) {
   _maximum_inventory = size;
}
int query_maximum_inventory_size() {
   return _maximum_inventory;
}
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
}
string query_parcel_post() {
   return _parcel_post;
}
int query_royalty(string person) {
   return query_controller()->query_royalty(person);
}
int query_owners_money() {
   return query_royalty(query_owner());
}
void adjust_royalty(string person, int amount) {
   query_controller()->adjust_royalty(person, amount);
}
int adjust_owners_money(int amount) {
   return adjust_royalty(query_owner(), amount);
}
void set_round_price(int round) {
   _round_value = round;
}
int query_round_prices() {
   return _round_value;
}
class approval_obs* query_approval_list(int approved) {
   if (approved) {
      return _approved;
   } else {
      return _waiting_for_approval;
   }
}
int query_number_of_items_listed(string name) {
   int num;
   class approval_obs bing;
   name = lower_case(name);
   num = sizeof(query_controller()->query_owner_sellables(name));
   foreach (bing in _waiting_for_approval) {
      if (lower_case(bing->seller) == name) {
         num += sizeof(bing->saved);
      }
   }
   return num;
}
mixed is_item_approved(string seller, int value, string name, object* sellables,
                     string category, int ref final_cost) {
   string short;
   object ob;
   int item_approval;
   class expression_type bing;
   class parse_node frog;
   int cost;
   mixed item;
   final_cost = ((value * (100 + _automatic_percentage)) / 100);
   value = value - (cost % _round_value);
   if (is_allowed(seller) ||
       is_helper(seller)) {
      final_cost = value;
      return 1;
   }
   seller = lower_case(seller);
   if (_sellers[seller] &&
       _sellers[seller]->deny_value_limit) {
      if (_sellers[seller]->deny_value_limit < value) {
         return -1;
      }
   } else if (_automatic_approval->high_cost_deny &&
              _automatic_approval->high_cost_deny <= value) {
      return -1;
   }
   foreach (ob in sellables) {
      if (!ob) {
         return -1;
      }
      short = ob->query_short();
      if (_automatic_approval->items[short]) {
         if (classp(_automatic_approval->items[short])) {
            item = ((class approval_item)_automatic_approval->items[short])->value;
         } else {
            item = _automatic_approval->items[short];
         }
         if (pointerp(item)) {
            frog = evaluate_expression(item,
                                     seller,
                                     value,
                                     ({ ob }),
                                     name,
                                     category);
            cost = frog->value - (frog->value % _round_value);
            if (cost < value) {
               item_approval = 0;
               break;
            }
            item_approval++;
         } else if (item < value) {
            item_approval = 0;
            break;
         } else {
            item_approval++;
         }
      }
   }
   if (item_approval) {
      if (classp(_automatic_approval->items[short]))  {
         class approval_item womble;
         womble = _automatic_approval->items[short];
         if (sizeof(womble) == 3) {
            _automatic_approval->items[short] = new(class approval_item,
                   markup : womble->markup,
                   value : womble->value,
                   list_name : womble->list_name,
                   final_cost : 0);
            womble = _automatic_approval->items[short];
         }
         if (womble->markup) {
            final_cost = ((value * (100 + womble->markup)) / 100);
         } else if (womble->final_cost) {
            final_cost = womble->final_cost;
         }
         if (womble->list_name) {
            return womble->list_name;
         } else {
            return 1;
         }
      } else {
         return 1;
      }
   }
   if (!pointerp(_automatic_approval->expressions)) {
      _automatic_approval->expressions = ({ });
   }
   foreach (bing in _automatic_approval->expressions) {
      if (evaluate_expression(bing->condition,
                              seller,
                              value,
                              sellables,
                              name,
                              category)->value) {
         if (bing->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
            frog = evaluate_expression(bing->value,
                                 seller,
                                 value,
                                 sellables,
                                 name,
                                 category);
            cost = frog->value - (frog->value % _round_value);
            if (cost >= value) {
               if (bing->list_name) {
                  return bing->list_name;
               } else if (classp(_automatic_approval->items[short]))  {
                  return ((class approval_item)_automatic_approval->items[short])->list_name;
               } else {
                  return 1;
               }
            }
         } else {
            return -1;
         }
      }
   }
   if (_sellers[seller] &&
       _sellers[seller]->value_limit) {
      if (_sellers[seller]->value_limit < value) {
         return 0;
      } else if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   } else if (_automatic_approval->high_cost &&
              _automatic_approval->high_cost < value) {
      return 0;
   }
   if (_automatic_approval->low_cost &&
       _automatic_approval->low_cost >= value) {
      if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   }
   return 0;
}
int is_allowed_to_use_shop(string person) {
   return (is_allowed(person) || is_helper(person) ||
           is_open_for("use", person));
}
int check_open(object player, string type) {
   if (!::check_open(player)) {
      return 0;
   }
   if (type == "sell") {
      if (sizeof(query_approval_list(0)) + sizeof(query_approval_list(1)) >= _max_items_in_queue) {
         add_failed_mess("Unable to sell things, the shop is full.\n");
         return 0;
      }
   }
   if (!is_allowed_to_use_shop(player->query_name())) {
      add_failed_mess("The shop is currently closed.\n");
      return 0;
   }
   return 1;
}
void set_controller(string name) {
   ::set_controller(name);
   query_controller()->set_dont_use_name(1);
}
int is_allowed_to_sell(object *obs, string name, string *sellable_names) {
   int num;
   int max;
   if (_automatic_approval->num_allowed ||
       _sellers[name]) {
      num = query_number_of_items_listed(name) + sizeof(obs);
      if (_sellers[name] && _sellers[name]->max_sellable) {
         max = _sellers[name]->max_sellable;
      } else {
         max = _automatic_approval->num_allowed;
      }
      if (num > max) {
         add_failed_mess("You cannot have more than " + max + " items "
                         "listed at " + the_short() + ", with this sale you "
                         "would have " +
                         num + ".\n");
         return 0;
      }
   }
   if (sizeof(filter(obs, (: $1->query_property("money") :))) > 0) {
      add_failed_mess("You cannot sell money.\n");
      return 0;
   }
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(obs) > query_maximum_inventory_size()) {
      add_failed_mess("The shop is full, it can only hold " +
                      query_maximum_inventory_size() + " items and it currently "
                      "holds " + num + " items.\n");
      return 0;
   }
   return 1;
}
int* query_maximum_sale_value_both(string person, object item) {
   int max_deny;
   int max_accept;
   string short;
   class expression_type stuff;
   mixed app_item;
   if (_sellers[person]) {
      if (_sellers[person]->value_limit) {
         max_accept = _sellers[person]->value_limit;
      }
      if (_sellers[person]->deny_value_limit) {
         max_deny = _sellers[person]->deny_value_limit;
      }
   }
   if (!max_accept) {
      max_accept = _automatic_approval->high_cost;
   }
   if (!max_deny) {
      max_deny = _automatic_approval->high_cost_deny;
   }
   if (!item) {
      return ({ 0, 0 });
   }
   short = item->query_short();
   if (_automatic_approval->items[short]) {
      if (classp(_automatic_approval->items[short]))  {
         app_item = ((class approval_item)_automatic_approval->items[short])->value;
      } else {
         app_item= _automatic_approval->items[short];
      }
      if (pointerp(app_item)) {
         max_accept = evaluate_expression(app_item,
                                        person, 0, ({ item }), 0, 0)->value;
      } else if (app_item < max_deny) {
         max_accept = app_item;
      }
   }
   foreach (stuff in _automatic_approval->expressions) {
      if (evaluate_expression(stuff->condition, person, 0, ({ }), 0, 0)->value) {
         if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_DENY) {
            max_deny = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         } else {
            max_accept = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         }
      }
   }
   max_accept -= max_accept % _round_value;
   max_deny -= max_deny % _round_value;
   return ({ max_accept, max_deny });
}
int query_maximum_sale_value(string person, object* obs) {
   int* stuff;
   object ob;
   int cur_deny;
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(person, ob);
      if (!cur_deny && stuff[1]) {
         cur_deny = stuff[1];
      } else if (cur_deny && cur_deny > stuff[1]) {
         cur_deny = stuff[1];
      }
   }
   return cur_deny;
}
string query_extra_price_information(string seller, object *obs) {
   int* max;
   int* max_tmp;
   string ret;
   string place;
   object ob;
   max = ({ 0, 0 });
   foreach (ob in obs) {
      max_tmp = query_maximum_sale_value_both(seller, ob);
      if (max_tmp[0] && max[0] > max_tmp[0]) {
         max[0] = max_tmp[0];
      }
      if (max_tmp[1] && max[1] > max_tmp[1]) {
         max[1] = max_tmp[1];
      }
   }
   ret = "";
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (max[0]) {
      ret += "the maximum price you can sell this straight into the "
             "inventory for is " +
             MONEY_HAND->money_value_string(max[0], place);
   }
   if (max[1]) {
      if (max[0]) {
         ret += " and ";
      }
      ret += "the maximum price you can sell the item for at all is " +
             MONEY_HAND->money_value_string(max[1], place);
   }
   return capitalize(ret) + ".\n";
}
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   string tmp;
   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   do_save_file(CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "app_" + fixed_num);
   return fixed_num;
}
protected object create_real_auto_load_object(int num, object player) {
   string auto_load;
   object *obs;
   auto_load = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
object create_checkout_object(class approval_obs approve,
                            int id,
                            object player) {
   object ob;
   int i;
   ob = create_real_auto_load_object(id, player);
   if (ob) {
      ob->add_effect("/std/effects/object/no_save");
      ob->add_property(PLAYER_CRAFT_SHOP_CHECK_PROP, ({ approve, id }));
      i = member_array(id, approve->saved);
      approve->checkout[i] = 1;
      event_save(this_object());
      _something_checkedout++;
   }
   return ob;
}
int destroy_checkout_object(object ob) {
   int id;
   int *ids;
   int i;
   class approval_obs approve;
   if (!ob) {
      return 0;
   }
   ob->add_property("destroy checkout object", 1, 2);
   if (ob->move("/room/rubbish") != MOVE_OK) {
      return 0;
   }
   debug_printf("Destroying the checkout object %O\n", ob);
   ids = ob->effects_matching("/std/effects/object/no_save"->query_classification());
   foreach (id in ids) {
      ob->delete_effect(id);
   }
   id = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[1];
   approve = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[0];
   i = member_array(id, approve->saved);
   approve->checkout[i] = 0;
   ob->remove_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
   create_auto_load_file(ob, id);
   event_save(this_object());
   _something_checkedout--;
   if (_something_checkedout < 0) {
       _something_checkedout = 0;
   }
   return 1;
}
int is_checkout_object(object ob) {
   return ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
}
object* add_to_approval_list(string seller, object* sellables, int value,
                          string name, string category, int approved) {
   class approval_obs stuff;
   object ob;
   object* obs;
   obs = ({ });
   foreach (stuff in query_approval_list(approved)) {
      if (lower_case(stuff->name) == lower_case(name) &&
          stuff->seller == seller &&
          stuff->value == value) {
         stuff->category = category;
         foreach (ob in sellables) {
            if (ob->move("/room/rubbish") == MOVE_OK) {
               stuff->saved += ({ create_auto_load_file(ob, 0) });
               stuff->checkout += ({ 0 });
               stuff->shorts += ({ ob->query_short() });
               obs += ({ ob });
            }
         }
         if (sizeof(obs)) {
            event_save(this_object());
         }
         return obs;
      }
   }
   stuff = new(class approval_obs);
   stuff->seller = seller;
   stuff->value = value;
   stuff->name = name;
   stuff->category = category;
   stuff->saved = ({ });
   stuff->shorts = ({ });
   stuff->enter_time = time();
   foreach (ob in sellables) {
      if (ob->move("/room/rubbish") == MOVE_OK) {
         stuff->saved += ({ create_auto_load_file(ob, 0) });
         stuff->shorts += ({ ob->query_short() });
         obs += ({ ob });
      }
   }
   stuff->checkout = allocate(sizeof(stuff->saved));
   if (sizeof(obs)) {
      if (approved) {
         _approved += ({ stuff });
      } else {
         _waiting_for_approval += ({ stuff });
      }
      event_save(this_object());
   }
   return obs;
}
void remove_from_approval_list(class approval_obs approve) {
   int i;
   int pos;
   for (i = 0; i < sizeof(_approved); i++) {
      if (_approved[i] == approve) {
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _approved = _approved[0..i-1] + _approved[i+1..];
         event_save(this_object());
         return ;
      }
   }
   for (i = 0; i < sizeof(_waiting_for_approval); i++) {
      if (_waiting_for_approval[i] == approve) {
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _waiting_for_approval = _waiting_for_approval[0..i-1] + _waiting_for_approval[i+1..];
         event_save(this_object());
         return ;
      }
   }
}
void add_transaction(string person, object* objects, int type, int amount,
                     string name_cat, mixed extra) {
#if USE_TRANSACTIONS
   class shop_transaction bing;
   string str;
   str = query_multiple_short(objects, 0, 1);
   bing = new(class shop_transaction);
   bing->time = time();
   bing->person = person;
   bing->objects = str;
   bing->type = type;
   bing->amount = amount;
   bing->name_cat = name_cat;
   bing->extra = extra;
   _transactions += ({ bing });
   event_save(this_object());
#endif
}
#if USE_TRANSACTIONS
string query_transaction_string(class shop_transaction trans) {
   string ret;
   string amt;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->money_value_string(trans->amount, place);
   ret = ctime(trans->time)[4..<9] + ": " + trans->person;
   switch (trans->type) {
   case PLAYER_CRAFT_SHOP_SELL :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_SELL_AUTO :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") [accepted] for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_APPROVE :
      ret += " approves " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_BUY :
      ret += " buys " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   }
   return ret;
}
#endif
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   string place;
   object *bought;
   mixed approve;
   int final_cost;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   _num_checked_so_far = ([ ]);
   approve = is_item_approved(this_player()->query_name(),
                        value, name, sellable, category, ref final_cost);
   if (approve == -1) {
      write("This item is denied sale here, it is not something the "
            "owner wishes to buy.\n");
      say(this_player()->query_cap_name() + " finished attempting to sell " +
                query_multiple_short(sellable) + " to " + the_short() + ".\n");
      return ;
   }
   if (approve == 1 || stringp(approve)) {
      if (stringp(approve)) {
         name = approve;
      }
   }
   write("Waiting for approval from the shop owner for the items " +
         query_multiple_short(sellable) + " with the name '" +
         name + "' selling for " +
         MONEY_HAND->money_value_string(value, place) +
         " in category " + category + ".\nIf the item is accepted the "
         "money will be paid into your royalty pool.\n");
   bought = add_to_approval_list(this_player()->query_cap_name(), sellable,
                        value, name, category, approve != 0);
   if (sizeof(bought)) {
      add_transaction(this_player()->query_name(),
                   bought,
                   PLAYER_CRAFT_SHOP_SELL,
                   value * sizeof(sellable),
                   name + " in " + category,
                   0);
      if (sizeof(bought) != sizeof(sellable)) {
         write("Unable to sell " + query_multiple_short(sellable - bought) +
                  " to " + the_short() + ".\n");
      }
      say(this_player()->the_short() + " completes selling something "
       "to the shop.\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + " to " +
            the_short() + ".\n");
   }
}
string query_letter_value(int pos) {
   return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26));
}
int query_number_value(string letter) {
   if (!strlen(letter)) {
      return -1;
   }
   letter = lower_case(letter);
   if (strlen(letter) < 2) {
      if (letter[0] >= 'a' && letter[0] <= 'z') {
         return letter[0] - 'a';
      }
   }
   if (strlen(letter) > 2) {
      return -1;
   }
   if (letter[0] >= 'a' && letter[0] <= 'z') {
      if (letter[1] >= 'a' && letter[1] <= 'z') {
         return (letter[0] - 'a') * 26 + (letter[1] - 'a');
      }
   }
   return -1;
}
class approval_obs query_approval_class(string name) {
   int pos;
   if (name[0] == '-') {
      pos = query_number_value(name[1..]);
   } else {
      pos = query_number_value(name);
   }
   if (pos == -1) {
      add_failed_mess(name + " is not a valid number.\n");
      return 0;
   }
   if (name[0] == '-') {
      if (!sizeof(query_approval_list(0))) {
         add_failed_mess("There is nothing in the approval list currently.\n");
         return 0;
      }
      if (pos >= sizeof(query_approval_list(0))) {
         add_failed_mess("The " + name + " is out of range, must be "
                         "between -AA and -" +
                         query_letter_value(sizeof(query_approval_list(0)) - 1) +
                         ".\n");
         return 0;
      }
      return query_approval_list(0)[pos];
   }
   if (pos >= sizeof(query_approval_list(1))) {
      add_failed_mess("The " + name + " is out of range, must be between AA-" +
                      query_letter_value(sizeof(query_approval_list(1)) - 1) +
                      ".\n");
      return 0;
   }
   return query_approval_list(1)[pos];
}
int ownership_change(string old_owner, string new_owner) {
   class parse_node* expr;
   if (old_owner == new_owner) {
      return 0;
   }
   _automatic_approval = new(class approval);
   _automatic_approval->items = ([ ]);
   _automatic_approval->expressions = ({ });
   _automatic_percentage = 10;
#if USE_TRANSACTIONS
   _transactions = ({ });
#endif
   _sold_stats = ([ ]);
   _stats_start = time();
   _sellers = ([ ]);
   expr = parse_boolean_string("false");
}
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
   string name_cat;
   int i;
   class shop_stats stat;
   _total_ingoing += value;
   adjust_royalty(query_owner(), value);
   for (i = 0; i < sizeof(obs); i++) {
      name_cat = names[i] + " in " + cats[i];
      add_transaction(this_player()->query_name(),
                      obs[i..i],
                      PLAYER_CRAFT_SHOP_BUY,
                      values[i],
                      name_cat,
                      sellers[i]);
      if (!_sold_stats) {
         _sold_stats = ([ ]);
      }
      stat = _sold_stats[sellers[i] + " - " + name_cat];
      if (!stat) {
         stat = new(class shop_stats);
         stat->name = name_cat;
         stat->seller = sellers[i];
      }
      stat->num_sold++;
      stat->value_sold += values[i];
      _sold_stats[sellers[i] + " - " + name_cat] = stat;
   }
   _weekly_stats->total_made += value;
}
object* check_for_checkout(object ob) {
   object* obs = ({ });
   if (_something_checkedout && ob) {
      if (living(ob)) {
         obs = filter(deep_inventory(ob), (: is_checkout_object($1) :));
         if (sizeof(obs)) {
            foreach (ob in obs) {
               if (!destroy_checkout_object(ob)) {
                  obs -= ({ ob });
               }
            }
         }
      } else {
         if (is_checkout_object(ob)) {
            call_out("verify_destroy_checkout_object", 2, ob);
         }
      }
      return obs;
   }
   return ({ });
}
void verify_destroy_checkout_object(object ob) {
   if (destroy_checkout_object(ob)) {
      tell_room(environment(), ob->the_short() +
                " magically checks itself back in.\n");
   }
}
void event_exit(object ob, string message, object to) {
   object *obs;
   if (ob->query_property("destroy checkout object")) {
      return ;
   }
   obs = check_for_checkout(ob);
   if (sizeof(obs)) {
      tell_object(ob, "You suddenly find the uncheckout items " +
                      query_multiple_short(obs) + " check themselves "
                      "back in.\n");
      obs->move("/room/rubbish");
   }
}
void event_dest_me(object ob) {
   check_for_checkout(ob);
}
void return_all_checkedout_objects() {
   object ob;
   object* obs;
   if (_something_checkedout) {
      obs = filter(deep_inventory(this_object()), (: is_checkout_object($1) :));
      if (sizeof(obs)) {
         foreach (ob in obs) {
            destroy_checkout_object(ob);
         }
      }
      tell_room(this_object(), query_multiple_short(obs) +
                " mysteriously check themselves back in.\n");
   }
}
void dest_me() {
   ::dest_me();
}
int is_able_to_change(object ob) {
   return is_allowed(this_player()->query_name()) ||
          is_helper(this_player()->query_name());
}
int do_buy(object *obs, int force) {
   if (!is_open_for("buy", this_player()->query_name()) ||
       !is_open_for("use", this_player()->query_name())) {
      add_failed_mess("You cannot buy anything at this shop.\n");
      return 0;
   }
   return ::do_buy(obs, force);
}
int do_check_sell(object *obs) {
   int *stuff;
   object ob;
   string ret;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(this_player()->query_name(), ob);
      ret += "$I$5=$C$" + the_short() + ": ";
      if (stuff[0]) {
         ret += "will be queued for more than " +
                MONEY_HAND->money_value_string(stuff[0], place);
      }
      if (stuff[0] && stuff[1]) {
         ret += " and ";
      }
      if (stuff[1]) {
         ret += "will be denied for more than " +
                MONEY_HAND->money_value_string(stuff[1], place);
      }
      ret += ".\n";
   }
   write("$P$Check Sell$P$" + ret);
   add_succeeded_mess(({ "", "$N checks the sale of $I.\n" }), obs);
   return 1;
}
int do_list_approval(int approved) {
   class approval_obs approve;
   int pos;
   int shown;
   int allowed;
   int checkout;
   string place;
   string ret;
   object* obs;
   object *current;
   object* result;
   string *possible_names;
   string start;
   mapping result_type;
   int i;
   int fluff;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   allowed = is_allowed(this_player()->query_name()) ||
             is_helper(this_player()->query_name());
   if (!allowed) {
      approved = 1;
   }
   if (!approved) {
      start = "-";
   } else {
      start = "";
   }
   result_type = ([ ]);
   ret = "";
   while (allowed || approved) {
      if (approved == 2) {
         approved = 0;
         start = "-";
      }
      foreach (approve in query_approval_list(approved)) {
         if (lower_case(approve->seller) == this_player()->query_name() ||
             allowed) {
            checkout = sizeof(filter(approve->checkout, (: $1 :)));
            obs = ({ });
            for (i = 0; i < sizeof(approve->saved); i++) {
               fluff = approve->saved[i];
               obs += ({ create_real_auto_load_object(fluff, this_player()) });
            }
            obs -= ({ 0 });
            possible_names = obs->query_short();
            obs->move("/room/rubbish");
            if (!result_type[lower_case(approve->name)]) {
               if (!current) {
                  current = map(query_controller()->query_sell_list_obs(),
                                (: query_controller()->query_short_of_shop_object($1) :));
               }
               result = current & possible_names;
               result_type[lower_case(approve->name)] = sizeof(result);
            }
            ret += start + query_letter_value(pos) + ") " +
                  approve->seller + "'s " + approve->name + " for " +
                  MONEY_HAND->money_value_string(approve->value, place) +
                  " in " + approve->category + ", " +
                  sizeof(approve->saved) + " objects (" +
                  query_multiple_short(obs) + ") " +
                  result_type[lower_case(approve->name)] + " in stock";
            if (checkout) {
               ret += " and " + checkout + " checked out.\n";
            } else {
               ret += ".\n";
            }
            shown++;
         }
         pos++;
      }
      if (!allowed && approved) {
         approved = 2;
         pos = 0;
      } else {
         break;
      }
   }
   if (sizeof(current)) {
      current->dest_me();
   }
   if (!shown) {
      add_failed_mess("No items to approve at the moment.\n");
      return 0;
   }
   write("$P$Approval list$P$The current approval items are:\n" + ret);
   return 1;
}
int do_return(string name) {
   object *obs;
   object *ok;
   object *here;
   object *fail;
   object *checkout;
   object money;
   class approval_obs approve;
   object ob;
   int pos;
   int i;
   int value;
   string place;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) != this_player()->query_name()) {
      add_failed_mess("You must be the one that sold the item to return "
                      "it.\n");
      return 0;
   }
   obs = ({ });
   checkout = ({ });
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      return_all_checkedout_objects();
   }
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (sizeof(checkout)) {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      write("The items " + query_multiple_short(checkout) +
            " are currently checked out.  You are reimbused the amount "
            "they would have cost to sell.\n");
      value = approve->value * sizeof(checkout);
      money = MONEY_HAND->make_new_amount( value, place);
      money->move(this_player());
      _total_outgoing += approve->value * sizeof(checkout);
   }
   ok = ({ });
   here = ({ });
   fail = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) == MOVE_OK) {
         ok += ({ ob });
      } else if (ob->move(environment(this_player()))) {
         here += ({ ob });
      } else {
         fail += ({ ob });
      }
   }
   remove_from_approval_list(approve);
   if (sizeof(ok)) {
      add_succeeded_mess("$N return$s $I.\n", map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(here)) {
      add_succeeded_mess("$N $V their $I and they get put on the floor.\n",
                         map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(fail)) {
      add_succeeded_mess( ({ "You find that $I do not want to be moved.\n",
                             "" }), fail);
   }
   return 1;
}
int do_approve_item(string name, string money_str) {
   int cost;
   object *obs;
   class approval_obs approve;
   string place;
   int final_cost;
   int num;
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(approve->saved) > query_maximum_inventory_size()) {
      add_failed_mess("You cannot approve anything, the shop is already "
                      "at the maximum number allowed.\n");
      return 0;
   }
   cost = approve->value * sizeof(obs);
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to put this into the shop.\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess("The amount " + money_str + " is not a valid "
                         "money cost.\n");
         return 0;
      }
   }
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      write("One of these objects is still checkedout, do you wish to "
            "continue this without these items? ");
      input_to("confirm_approval", 0, approve, final_cost);
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      return 1;
   }
   confirm_approval("y", approve, final_cost);
   return 1;
}
void reset_weekly_status() {
   _weekly_stats = new(class weekly_stats);
   _weekly_stats->num_sold = 0;
   _weekly_stats->total_cost = 0;
   _weekly_stats->total_made = 0;
   _weekly_stats->num_bought = 0;
   _weekly_stats->helper = ([ ]);
}
string query_weekly_status_string() {
   string ret;
   string place;
   string player;
   class helper_stats helpers;
   class item_stats items;
   string* item_bits;
   string item;
   int num;
   place = query_property("place");
   ret = "$I$0=Total Outgoing  : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_cost, place) + "\n";
   ret += "$I$0=Total Incoming : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_made, place) + "\n";
   if (_weekly_stats->total_made > _weekly_stats->total_cost) {
      ret += "$I$0=Profit of      : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_made - _weekly_stats->total_cost, place) + "\n";
   } else {
      ret += "$I$0=Loss of        : " +
          MONEY_HAND->money_value_string(-(_weekly_stats->total_made - _weekly_stats->total_cost), place) + "\n";
   }
   ret += "$I$0=Items             : " +
          _weekly_stats->num_sold + " sold and " +
          _weekly_stats->num_bought + " bought.\n";
   ret += "\n$I$0=Player summaries:\n";
   foreach (player, helpers in _weekly_stats->helper) {
      item_bits = ({ });
      if (sizeof(helpers->items_approved)) {
         foreach (item, num in helpers->items_approved) {
            item_bits += ({ num + " " + item });
         }
      } else {
         item_bits = ({ "nothing" });
      }
      ret += "$I$6=   " + player + ": " + helpers->num_approved +
             " approved, " + helpers->num_rejected + " rejected, " +
             MONEY_HAND->money_value_string(helpers->total_cost, place) +
             " approved " + query_multiple_short(item_bits) + "\n";
   }
   return ret;
}
protected void inform_of_approved_item(string name,
                            int cost,
                            class approval_obs approve) {
   string str;
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   _weekly_stats->total_cost += cost;
   str = approve->name;
   name = this_player()->query_name();
   if (!_weekly_stats->helper[name]) {
      _weekly_stats->helper[name] = new(class helper_stats);
      _weekly_stats->helper[name]->items_approved = ([ ]);
   }
   _weekly_stats->helper[name]->num_approved++;
   _weekly_stats->helper[name]->total_cost += cost;
   if (!mapp(_weekly_stats->helper[name]->items_approved)) {
      _weekly_stats->helper[name]->items_approved = ([ ]);
   }
   _weekly_stats->helper[name]->items_approved[str]++;
}
protected void inform_of_rejected_item(string name,
                            class approval_obs approve) {
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   name = this_player()->query_name();
   if (!_weekly_stats->helper[name]) {
      _weekly_stats->helper[name] = new(class helper_stats);
   }
   _weekly_stats->helper[name]->num_rejected++;
}
protected void confirm_approval(string answer,
                                class approval_obs approve,
                                int final_cost) {
   int pos;
   int i;
   int bing;
   int cost;
   object *obs;
   object *bought;
   object *checkout;
   string place;
   if (strlen(answer) < 1 || lower_case(answer)[0] != 'y') {
      write("Ok, canceled the approval of the item.\n");
      return ;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and therefore lost.\n");
   }
   if (!final_cost) {
      final_cost = ((approve->value * (100 + _automatic_percentage)) / 100);
   }
   final_cost -= final_cost % _round_value;
   obs->remove_property("dropped");
   bought = query_controller()->buy_objects(obs, approve->name,
                                   final_cost,
                                   approve->seller, approve->category, 1);
   if (sizeof(bought)) {
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      _total_outgoing += cost;
      remove_from_approval_list(approve);
      adjust_royalty(lower_case(approve->seller), cost);
      if (query_owners_money() > 0) {
         if (query_owners_money() > cost) {
            adjust_owners_money(-cost);
            cost = 0;
         } else {
            cost -= query_owners_money();
            adjust_owners_money(-query_owners_money());
         }
      }
      if (cost > 0) {
         if (this_player()->query_value_in(place) > 0) {
            bing = this_player()->query_value_in(place);
            if (bing > cost) {
               bing = cost;
               cost = 0;
            } else {
               cost -= bing;
            }
            if (bing) {
               this_player()->pay_money(MONEY_HAND->create_money_array(bing, place), place);
            }
         }
         if (cost > 0) {
            adjust_owners_money(-cost);
         }
      }
      write("You approve " + query_multiple_short(obs) + " to be sold as " +
            approve->name + " in " + approve->category + " for " +
            MONEY_HAND->money_value_string(approve->value, place) + ".\n");
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      inform_of_approved_item(this_player()->query_name(),
                              cost, approve);
      add_transaction(this_player()->query_name(),
                      obs,
                      PLAYER_CRAFT_SHOP_APPROVE,
                      approve->value * (sizeof(obs) + sizeof(checkout)),
                      approve->name + " in " + approve->category,
                      approve->seller);
   } else {
      write("Unable to move the items into the shops inventory, you "
            "will need to reject this item.\n");
   }
   return ;
}
int do_approve_reject(string name, string mess, int reject_pos) {
   object *obs;
   object *ok;
   object *here;
   object *checkout;
   object ob;
   object play;
   class approval_obs approve;
   int pos;
   int i;
   int ret;
   string ob_mess;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You're not allowed to reject items.\n");
      return 0;
   }
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      return_all_checkedout_objects();
   }
   if (reject_pos != -1 &&
       (reject_pos <= 0 ||
       reject_pos > sizeof(approve->saved))) {
      add_failed_mess("You cannot reject the item of position " + reject_pos +
                      " since there are only " + sizeof(approve->saved) +
                      " items.\n");
      return 0;
   }
   if (reject_pos != -1) {
      reject_pos--;
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      if (reject_pos == -1 ||
          reject_pos == i) {
         pos = approve->saved[i];
         if (!approve->checkout[i]) {
            obs += ({ create_real_auto_load_object(pos, this_player()) });
         } else {
            checkout += ({ create_real_auto_load_object(pos, this_player()) });
         }
      }
   }
   obs = filter(obs, (: $1 && objectp($1) :));
   checkout = filter(checkout, (: $1 && objectp($1) :));
   if (member_array(0, obs) != -1) {
      add_failed_mess("There seems to be a problem with this rejection set, "
                      "one of the items is 0.\n");
      return 0;
   }
   if (reject_pos != -1 && sizeof(checkout)) {
      add_failed_mess("The item $I has been checked out, you cannot reject "
                      "it.\n", checkout);
      return 0;
   }
   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and lost.\n");
      adjust_royalty(lower_case(approve->seller),
                     approve->value * sizeof(checkout));
      AUTO_MAILER->auto_mail(lower_case(approve->seller),
                            this_player()->query_name(),
                            "Rejected items", "",
                            sprintf("%-=75s",
                                   this_player()->query_name() + " lost your " +
                                   query_multiple_short(checkout, "the", 1) +
                                   ",so you have been paid but the items "
                                   "were not returned.\n"));
   }
   inform_of_rejected_item(this_player()->query_name(), approve);
   if (!sizeof(obs)) {
      write("Nothing to give back or send off.\n");
   } else {
      play = find_player(lower_case(approve->seller));
      if (play  &&  environment(play) == this_object()) {
         ok = ({ });
         here = ({ });
         foreach (ob in obs) {
            if (ob) {
               if (ob->move(play) == MOVE_OK) {
                  ok += ({ ob });
               } else if (ob->move(environment(play)) == MOVE_OK) {
                  here += ({ ob });
               }
            }
         }
         if (sizeof(ok)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed in your inventory.\n");
         }
         if (sizeof(here)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed on the floor here.\n");
         }
         write("You reject the item.\n");
      } else {
         if (!query_parcel_post()) {
            add_failed_mess("Eeek!  No parcel post defined on this room.\n");
            return 0;
         } else if(!load_object(query_parcel_post())) {
           add_failed_mess("Eeek!  Parcel post cannot be loaded.\n");
           return 0;
         }
         ob_mess = "The shop " + this_player()->convert_message(the_short()) +
                   " rejected " + query_multiple_short(obs, "the", 1) +
                   " because:\n";
         if (!mess) {
            mess = "They didn't want to add a reject message.";
         }
         ret = query_parcel_post()->deposit_parcel(obs, lower_case(approve->seller), 1);
         if (ret != 1) {
            if (ret == -5) {
               write("The player " + approve->seller + " has been denied use "
                     "of the parcel post system, tossing objects away.\n");
               obs->move("/room/rubbish");
               if (mess) {
                  write("Still sending the message to the person.\n");
                  mess += "\nYou were denied use of the parcel post system "
                          "so your objects were thrown away.\n";
               }
            } else if (ret == -4) {
               write("You have been denied use of the postal system, perhaps "
                     "you could try clearing this up with the creators?\n");
               obs->move("/room/rubbish");
               return 1;
            } else if (ret == -2) {
               write("The player " + approve->seller + " no longer exists, "
                     "tossing objects away.\n");
               obs->move("/room/rubbish");
            } else {
               add_failed_mess("Unable to send the parcel for some reason (" +
                            ret + ").\n");
                  obs->move("/room/rubbish");
               return 0;
            }
         }
         if (ret != -2) {
            if (mess) {
               AUTO_MAILER->auto_mail(approve->seller, this_player()->query_name(),
                               "Rejected items", "",
                               ob_mess + mess);
            } else {
               write("You reject the item and it is parcel posted back to the "
                  "person who "
                  "sent it.\nWould you like to send them a note about it as well? ");
               obs -= ({ 0 });
               input_to("check_reject_note", 0, ob_mess,
                        approve->seller);
            }
         }
      }
   }
   if (reject_pos != -1) {
      approve->saved = approve->saved[0..reject_pos-1] + approve->saved[reject_pos+1..];
      event_save(this_object());
      if (!sizeof(approve->saved)) {
         reject_pos = -1;
      }
   }
   if (reject_pos == -1) {
      remove_from_approval_list(approve);
   }
   add_succeeded_mess(({ "", "$N reject$s a sellable object.\n" }));
   return 1;
}
void check_reject_note(string str, string ob_str, string name) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' &&
        str[0] != 'n')) {
      write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?");
      input_to("check_reject_note", 0, ob_str, name);
      return ;
   }
   if (str[0] == 'n') {
      write("ok, bye then!\n");
      return ;
   }
   this_player()->do_edit("Your items " + ob_str + " were rejected "
                         "from " + the_short() + ".\n\n",
                         "send_reject_note", this_object(), 0, name);
}
void send_reject_note(string mess, string name) {
   if (!mess) {
      write("Aborted.\n");
      return ;
   }
   AUTO_MAILER->auto_mail(name, this_player()->query_name(),
                            "Rejected items", "", mess);
}
int do_approve_browse(string name) {
   object *obs;
   object ob;
   string read;
   string ret;
   string bits;
   class approval_obs approve;
   int pos;
   string place;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = ({ });
   foreach (pos in approve->saved) {
      obs += ({ create_real_auto_load_object(pos, this_player()) });
   }
   obs -= ({ 0 });
   ret = "";
   foreach (ob in obs) {
      ret += ob->the_short() + ": (Base cost " +
             MONEY_HAND->money_value_string(ob->query_base_value(), place) +
             "; scaled cost " +
             MONEY_HAND->money_value_string(ob->query_value(), place) +
             ")\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         bits = ob->query_read_short(this_player());
         if (!bits) {
            bits = "$name$";
         }
         ret += "You read " +
                 replace_string(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }
   obs->move("/room/rubbish");
   write("$P$Browse list$P$" + ret);
   add_succeeded_mess("$N browse$s an item waiting for approval.\n");
   return 1;
}
int do_approve_checkout(string name) {
   object *obs;
   object *bad;
   object *checkout;
   object ob;
   class approval_obs approve;
   int pos;
   int i;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name() &&
       lower_case(approve->seller) != "pinkfish") {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         ob = create_checkout_object(approve, pos, this_player());
         if (!ob) {
            write("Unable to create " + pos + approve->name + ", weird...\n");
         } else {
            obs += ({ ob });
         }
      } else {
         checkout += ({ create_checkout_object(approve, pos, this_player()) });
      }
   }
   checkout->move("/room/rubbish");
   if (!sizeof(obs) &&
       sizeof(checkout)) {
      if (sizeof(checkout) > 0) {
         add_failed_mess("$I are already checked out.\n", checkout);
      } else {
         add_failed_mess("$I is already checked out.\n", checkout);
      }
      return 0;
   }
   bad = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) != MOVE_OK) {
         bad += ({ ob });
         destroy_checkout_object(ob);
      }
   }
   if (sizeof(bad)) {
      write("Unable to move " + query_multiple_short(bad) + " into your "
            "inventory for you to check.\n");
   }
   obs -= bad;
   if (sizeof(obs)) {
      write("Moved " + query_multiple_short(obs) + " into your inventory "
            "for you to check.\n");
      add_succeeded_mess("$N check$s out $I.\n", obs);
   }
   return 1;
}
int do_approve_checkin(object* obs) {
   object ob;
   object* ok;
   ok = ({ });
   foreach (ob in obs) {
      if (is_checkout_object(ob)) {
         destroy_checkout_object(ob);
         ok += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      add_failed_mess("None of $I have been checked out.\n", obs);
      return 0;
   }
   add_succeeded_mess("$N check$s $I back in.\n", ok);
   return 1;
}
int do_approve_name_change(string name, string new_name) {
   class approval_obs approve;
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve)  return 0;
   write("You change the name of the item waiting to be approved from " +
         approve->name + " to " + new_name + ".\n");
   approve->name = new_name;
   add_succeeded_mess( ({ "", "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
}
int do_approve_category_change(string name, string new_category) {
   class approval_obs approve;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }
   approve->category = new_category;
   add_succeeded_mess(({
      "You change the category of the approval item " + name + ".\n",
      "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
}
int do_approve_auto_low(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   _automatic_approval->low_cost = value;
   event_save(this_object());
   if (!value) {
      add_succeeded_mess(({ "You disable the automatic acception of items of "
                            "low value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "costing less than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_high(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost = value;
      add_succeeded_mess(({ "You disable the automatic placing items into the "
                            "approve list of items of high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   _automatic_approval->high_cost = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically put any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) +
                         " into the approve list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_high_deny(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost_deny = 0;
      add_succeeded_mess(({ "You disable the automatic denying of items of "
                            "high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   _automatic_approval->high_cost_deny = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add(string item, string money, string list_name,
                             int markup, string money_str) {
   int value;
   string place;
   int final_cost;
   mixed app_item;
   class approval_item new_app_item;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }
   if (markup < 0) {
      markup = 0;
   }
   item = strip_quotes(item);
   list_name = strip_quotes(list_name);
   if (classp(_automatic_approval->items[item])) {
      app_item = ((class approval_item)_automatic_approval->items[item])->value;
   } else {
      app_item = _automatic_approval->items[item];
   }
   if (app_item == value) {
      add_failed_mess("The item " + item + " already has a cut off "
                      "value of " +
                      MONEY_HAND->money_value_string(value, place) + ".\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;
   place = query_property("place");
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add_object(object *obs, string money,
                                    string list_name, int markup,
                                    string money_str) {
   int value;
   string place;
   object ob;
   string name;
   object *ok;
   object *bad;
   mixed item;
   class approval_item new_item;
   int final_cost;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   bad = ({ });
   ok = ({ });
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      if (classp(_automatic_approval->items[name])) {
         item = ((class approval_item)_automatic_approval->items[name])->value;
      } else {
         item = _automatic_approval->items[name];
      }
      if (item == value) {
         bad += ({ name });
      } else {
         new_item = new(class approval_item);
         new_item->value = value;
         new_item->list_name = list_name;
         new_item->markup = markup;
         new_item->final_cost = final_cost;
         _automatic_approval->items[name] = new_item;
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You set the shop to automatically accept any of "
                         "$I up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   } else {
      add_failed_mess("You cannot set $I to a value limit of " +
                      MONEY_HAND->money_value_string(value, place) +
                      " since it already has this limit.\n");
      return 0;
   }
}
int do_approve_auto_item_add_expr(string item, string expr,
                                  string list_name, int markup,
                                  string money_str) {
   class approval_item new_app_item;
   class parse_node* value;
   string place;
   int final_cost;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   item = strip_quotes(item);
   list_name = strip_quotes(list_name);
   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " with an expression "
                         "of " + query_expression_string(value, 1) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add_object_expr(object *obs, string expr,
                          string list_name, int markup, string money_str) {
   class parse_node* value;
   object ob;
   string name;
   class approval_item new_item;
   int final_cost;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (money_str) {
      place = query_property("place");
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      new_item = new(class approval_item);
      new_item->value = value;
      new_item->list_name = list_name;
      new_item->markup = markup;
      new_item->final_cost = final_cost;
      _automatic_approval->items[name] = new_item;
   }
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any of "
                      "$I with an expression "
                      "of " + query_expression_string(value, 1) +
                      (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                       "$N fiddle$s with something in the shop.\n" }), obs );
   return 1;
}
int do_approve_auto_item_test(object* obs) {
   object ob;
   string place;
   mixed cost;
   int found;
   int allowed;
   class expression_type stuff;
   class parse_node frog;
   allowed = is_allowed(this_player()->query_name()) ||
             is_helper(this_player()->query_name());
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   foreach (ob in obs) {
      found = 0;
      cost = _automatic_approval->items[ob->query_short()];
      if (classp(cost)) {
         cost = ((class approval_item)cost)->value;
      }
      if (cost) {
         if (pointerp(cost)) {
            frog = evaluate_expression(cost, this_player()->query_name(),
                                        0, ({ ob }), 0, 0);
            if (allowed) {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  query_expression_string(cost, 1) +
                  ";\n" + ob->query_short() + " - " +
                  MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            } else {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  " " + MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            }
         } else {
            write("$I$5=The item " + ob->the_short() + " can be sold if it "
              "costs less than " +
               MONEY_HAND->money_value_string(cost, place) +
               " (" + ob->query_short() + ").\n");
         }
         found |= 1;
      }
      foreach (stuff in _automatic_approval->expressions) {
         frog = evaluate_expression(stuff->condition,
                                    this_player()->query_name(),
                                    0, ({ ob }), 0, 0);
         if (frog->value) {
            if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
               frog = evaluate_expression(stuff->value,
                                      this_player()->query_name(),
                                      0, ({ ob }), 0, 0);
               if (allowed) {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        query_expression_string(stuff->value, 1) +
                        ";\n" + ob->query_short() + " - " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               } else {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               }
               found |= 2;
            } else {
               found |= 4;
            }
         }
      }
      if (found & 4)  {
         write("$I$5=The item " + ob->the_short() + " will be denied sale.\n");
      }
      else if (!found) {
         write("$I$5=The item " + ob->the_short() + " will not be "
               "automatically accepted.\n");
      }
   }
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_remove(string item) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   item = strip_quotes(item);
   if (!_automatic_approval->items[item]) {
      add_failed_mess("The item " + item + " is not in the list.\n");
      return 0;
   }
   map_delete(_automatic_approval->items, item);
   event_save(this_object());
   add_succeeded_mess(({ "You remove the item " + item +
                         " from the list of automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_remove_object(object *obs) {
   object ob;
   object *bad;
   object *ok;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   ok = ({ });
   bad = ({ });
   foreach (ob in obs) {
      name = ob->query_short();
      if (!_automatic_approval->items[name]) {
         bad += ({ ob });
      } else {
         ok += ({ ob });
         map_delete(_automatic_approval->items, name);
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You remove $I from the list of "
                            "automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   }
   add_failed_mess("None of $I are in the shops allow item list for you "
                   "to remove.\n", bad);
   return 0;
}
int do_approve_auto_expression_add(string expression, string value_str,
                                   int type, string list_name) {
   class parse_node* expr;
   class parse_node* value;
   class expression_type bing;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      value = parse_money_string(value_str);
      if (!sizeof(value)) {
         add_failed_mess(query_last_expression_error() + ".\n");
         return 0;
      }
   }
   list_name = strip_quotes(list_name);
   bing = new(class expression_type);
   bing->type = type;
   bing->condition = expr;
   bing->value = value;
   bing->list_name = list_name;
   _automatic_approval->expressions += ({ bing });
   event_save(this_object());
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + " with a cost "
                         "of " + query_expression_string(value, 0) +
                         " as '" + list_name + "'.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_auto_expression_remove(string idstr) {
   class expression_type expr;
   int id;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   id = query_number_value(idstr);
   if (id == -1 || id >= sizeof(_automatic_approval->expressions)) {
      add_failed_mess("The id " + idstr + " is invalid.\n");
      return 0;
   }
   expr = _automatic_approval->expressions[id];
   _automatic_approval->expressions = _automatic_approval->expressions[0..id - 1] +
                                      _automatic_approval->expressions[id + 1..];
   event_save(this_object());
   add_succeeded_mess(({ "You remove the expression " +
                         query_expression_string(expr->condition, 1) +
                         " cost: " +
                         query_expression_string(expr->value, 1) +
                         " from the list of allowed expressions.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_percentage(mixed num) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   if (num <= 0) {
      add_failed_mess("The percentage to add must be greator than 0.\n");
      return 0;
   }
   _automatic_percentage = num;
   add_succeeded_mess(({ "You set the percentage to add to the sale price "
                         "to " + _automatic_percentage + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_limit(string limit) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   if (limit == "disable")  {
      _automatic_approval->num_allowed = 0;
      add_succeeded_mess(({ "You disable the default number of sold items "
                         "per person.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   else if (to_int(limit) > 0)  {
      _automatic_approval->num_allowed = to_int(limit);
      add_succeeded_mess(({ "You set the default number of sold items per "
                            "person to " + _automatic_approval->num_allowed + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   return 0;
}
int do_approve_limit_person_items(string name, string value) {
   int amt;
   class seller_information info;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return 0;
   }
   amt = to_int(value);
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->max_sellable = amt;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (amt)
      add_succeeded_mess(({ "You set the maximum number of items sellable by " +
                            name + " to " + info->max_sellable + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
   else
      add_succeeded_mess(({ "You remove the limit for the maximum number of "
         "items sellable by " + name + ".\n",
         "$N fiddle$s with something in the shop.\n" }));
   return 1;
}
int do_approve_limit_person_value(string name, string money) {
   class seller_information info;
   int value;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }
   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->value_limit = value;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items automatically "
                            "approved by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items "
                         "automatically approved by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_limit_person_value_deny(string name, string money) {
   class seller_information info;
   int value;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }
   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->deny_value_limit = value;
   if (info->deny_value_limit || info->max_sellable || info->value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items accepted by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->deny_value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items to be sold by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_limit_person_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove limits "
                      "off someone.\n");
      return 0;
   }
   name = lower_case(name);
   if (!_sellers[name]) {
      add_failed_mess("The person " + name + " does not have any limits placed "
                      "on them.\n");
      return 0;
   }
   map_delete(_sellers, name);
   event_save(this_object());
   add_succeeded_mess(({ "You remove any limits set on " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
string query_main_status(int hint) {
   string ret;
   string place;
   string name;
   class seller_information stuff;
   string *bits;
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "$I$0=" + the_short() + "\n";
   ret += "$I$6=   The current percentage to automatically add to the buy price is: " +
          _automatic_percentage + "%\n";
   if (hint) {
      ret += "$I$0=       Hint: markup <percent>\n";
   }
   ret += "$I$6=   Limits on what can be sold.\n";
   ret += "$I$6=   Maximum number of items allowed in the shop : ";
   if (query_maximum_inventory_size()) {
      ret += query_maximum_inventory_size() + " currently " +
             sizeof(query_controller()->query_sell_list_obs()) + " (fixed).\n";
   } else {
      ret += "disabled (fixed).\n";
   }
   ret += "$I$6=   Maximum number of items allowed per player  : ";
   if (_automatic_approval->num_allowed) {
      ret += _automatic_approval->num_allowed + ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set max number <number|disable>\n";
   }
   ret += "$I$6=   Automatically queue sales more than         : ";
   if (_automatic_approval->high_cost) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set high queue cost <cost|disable>\n";
   }
   ret += "$I$6=   Automatically deny sales more than          : ";
   if (_automatic_approval->high_cost_deny) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost_deny, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set high deny cost <cost|disable>\n";
   }
   ret += "$I$6=   Helpers     : ";
   if (sizeof(_helpers)) {
      ret += query_multiple_short(_helpers) + "\n";
   } else {
      ret += "None at all.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: helper add <name>\n";
      ret += "$I$0=       Hint: helper remove <name>\n";
      ret += "$I$0=       Hint: helper list\n";
   }
   if (sizeof(_sellers)) {
      ret += "$I$6=   Limits set per player.\n";
      ret += sprintf("   %-15s %-15s %-20s %s\n", "Name", "Max Sellable",
                     "Approve Limit", "Deny limit (per item)");
      bits = sort_array(keys(_sellers), 0);
      foreach (name in bits) {
         stuff = _sellers[name];
         ret += sprintf("   %-15s %-15s %-20s %s\n", name,
                    (stuff->max_sellable?stuff->max_sellable+"":"disabled"),
                    (stuff->value_limit?MONEY_HAND->money_value_string(stuff->value_limit, place):"disabled"),
                    (stuff->deny_value_limit?MONEY_HAND->money_value_string(stuff->deny_value_limit, place):"disabled"));
      }
   } else {
      ret += "$I$6=   No limits set per player.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set max number <max sellable|disable> for <player>\n";
      ret += "$I$0=       Hint: set high queue cost <cost|disable> for <player>\n";
      ret += "$I$0=       Hint: set high deny cost <cost|disable> for <player> to <cost|disable>\n";
   }
   ret += "\n$I$6=   Automatically approve sales less than       : ";
   if (_automatic_approval->low_cost) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->low_cost, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set low approve cost <cost|disable>\n";
   }
   ret += "$I$0=Use 'expressions' to see the expressions.\n";
   ret += "$I$0=Use 'functions shop' to see the user defined "
          "functions.\n";
   return ret;
}
string query_expression_status(int hint) {
   string ret;
   string place;
   mixed expr;
   string str;
   int pos;
   class expression_type bing;
   class expression_type binger;
   class approval_item approval;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   if (sizeof(_automatic_approval->items)) {
      ret += "$I$0=%^BOLD%^Automatically accept sales of items%^RESET%^\n";
      foreach (str, expr in _automatic_approval->items) {
         if (classp(expr)) {
            approval = (class approval_item)expr;
            expr = ((class approval_item)expr)->value;
         } else {
            approval = new(class approval_item);
         }
         if (pointerp(expr) && intp(expr[0])) {
            map_delete(_automatic_approval->items, str);
         } else {
            ret += sprintf("$I$10=   %-20s", "* " + str);
            if (sizeof(approval) == 3) {
               approval = new(class approval_item,
                      markup : approval->markup,
                      value : approval->value,
                      list_name : approval->list_name,
                      final_cost : 0);
            }
            if (approval->list_name) {
               ret += " listed as '" + approval->list_name + "'";
            }
            if (approval->markup) {
               ret += " markup of " + approval->markup;
            }
            if (approval->final_cost) {
               ret += " final cost of " +
               MONEY_HAND->money_value_string(approval->final_cost, place);
            }
            ret += " max value:";
            if (pointerp(expr)) {
               str = query_expression_string(expr, 0);
               if (strsrch(str, "\n") != -1) {
                  ret += "\n" + str;
               } else {
                  ret += str;
               }
            } else {
               ret += MONEY_HAND->money_value_string(expr, place);
            }
            ret += "\n";
         }
      }
   } else {
      ret += "Automatically accept sales of               : (none setup)\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: auto add name <name> up to <value>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> and markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> and value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto remove name <name>\n";
      ret += "$I$0=       Hint: auto remove object <object>\n";
   }
   ret += "\n$I$0=%^BOLD%^Automatic approval expressions.%^RESET%^\n";
   if (sizeof(_automatic_approval->expressions)) {
      pos = 0;
      foreach (bing in _automatic_approval->expressions) {
         if (sizeof(bing) == 3) {
            binger = new(class expression_type);
            binger->type = bing->type;
            binger->condition = bing->condition;
            binger->value = bing->value;
            bing = binger;
            event_save(this_object());
         }
         if (bing->type != PLAYER_CRAFT_SHOP_EXPR_DENY) {
            str = query_expression_string(bing->value, 0);
            if (strsrch(str, "\n") != -1) {
               str = "\n" + str;
            }
            str = " accept value: " + str;
            if (bing->list_name) {
               str += " as " + bing->list_name;
            }
         } else {
            str = " -- deny item";
         }
         ret += "$I$5=" + query_letter_value(pos) + ") " +
                query_expression_string(bing->condition, 0) + str + ".\n";
         pos++;
      }
   } else {
      ret += "$I$0=No automatic approval expressions setup.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: auto add approve expression <condition> cost <value> as <list name>\n";
      ret += "$I$0=       Hint: auto deny expression <expression>\n";
      ret += "$I$0=       Hint: auto remove expression <id>\n";
   }
   ret += "\n$I$0=";
   ret += "$I$0=Use 'functions shop' to see the user defined "
          "functions.\n";
   return ret;
}
int do_main_status(int hint) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Cannot do that!\n");
      return 0;
   }
   write("$P$Status$P$" + query_main_status(hint));
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_expression_status(int hint) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Cannot do that!\n");
      return 0;
   }
   write("$P$Status$P$" + query_expression_status(hint));
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_pay_deficit() {
   int cost;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to pay off the deficit for " +
                      the_short() + ".\n");
      return 0;
   }
   if (query_owners_money() >= 0) {
      add_failed_mess("There is no deficit here to pay off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = -query_owners_money();
   if (this_player()->query_value_in(place) >= cost) {
      adjust_royalty(query_owner(), cost);
      this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
      add_succeeded_mess("$N pay$s off the deficit in " + the_short() + ".\n");
      return 1;
   }
   add_failed_mess("You do not have enough money to pay off the deficit "
                   "of " + MONEY_HAND->money_value_string(cost, place) +
                   ".\n");
   return 0;
}
int do_category_description(string category, string desc) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (!query_controller()->is_valid_category(category)) {
      add_failed_mess("The category doesn't exists.\n");
      return 0;
   }
   set_category_description(category, desc);
   add_succeeded_mess("$N set$s the description of " + category + ".\n");
   return 1;
}
int do_category_information(string category, string desc) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (!query_controller()->is_valid_category(category)) {
      add_failed_mess("The category doesn't exists.\n");
      return 0;
   }
   set_category_information(category, desc);
   add_succeeded_mess("$N set$s the description of " + category + ".\n");
   return 1;
}
int do_add_new_category(string category) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (query_controller()->is_valid_category(category)) {
      add_failed_mess("The category already exists.\n");
      return 0;
   }
   add_shop_category(category);
   add_succeeded_mess("$N add$s a new category.\n");
   return 1;
}
int do_remove_category(string category) {
   object* obs;
   string old_cat;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove categories.\n");
      return 0;
   }
   old_cat = category;
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + old_cat + " does not exist.\n");
      return 0;
   }
   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );
   if (sizeof(obs)) {
      add_failed_mess("The category '" + category + "' is not empty "
                     "and cannot be removed.\n");
      return 0;
   }
   write("Do you wish to remove the category " + category + " from " +
         the_short() + " (y/n)?");
   input_to("check_remove_category", 0, category);
   add_succeeded_mess(({ "", "$N removes a category from the shop.\n" }));
   return 1;
}
int do_rename_category(string category, string new_category) {
   object* obs;
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to rename categories.\n");
      return 0;
   }
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }
   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }
   add_shop_category(new_category);
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );
   if (sizeof(obs)) {
      foreach (ob in obs) {
         query_controller()->change_category_of_shop_object(ob, new_category);
      }
   }
   remove_shop_category(category);
   add_succeeded_mess("$N rename$s category " + category + " to " +
                      new_category + ".\n");
   return 1;
}
protected void check_remove_category(string answer, string category) {
   class approval_obs approve;
   if (!strlen(answer) ||
       lower_case(answer)[0] != 'y') {
      write("Aborting deleting the category " + category + ".\n");
      return ;
   }
   remove_shop_category(category);
   write("Removed the shop category " + category + ".\n");
   foreach (approve in query_approval_list(0)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   foreach (approve in query_approval_list(1)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   event_save(this_object());
   return ;
}
int do_set_default_category(string default_cat) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set the default category.\n");
      return 0;
   }
   default_cat = query_real_category_name(default_cat);
   if (!default_cat ||
       !query_controller()->is_valid_category(default_cat)) {
      add_failed_mess("The category " + default_cat + " does not exist.\n");
      return 0;
   }
   set_default_category(default_cat);
   add_succeeded_mess("$N set$s the default category for " + the_short() +
                      ".\n");
   event_save(this_object());
   return 1;
}
int do_list_categories() {
   string cat;
   string ret;
   ret = "";
   foreach (cat in query_controller()->query_categories()) {
      if (cat == query_default_category()) {
         ret += cat + " (default)\n";
      } else {
         ret += cat + "\n";
      }
   }
   write("$P$Category list$P$The current categories are:\n" + ret);
   add_succeeded_mess(({ "", "$N browses the categories.\n" }));
   return 1;
}
int do_stats_items(int type) {
   class shop_stats stat;
   string ret;
   string *bits;
   string place;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   if (!sizeof(_sold_stats)) {
      add_failed_mess("Nothing has been sold in this transaction section "
                      "yet.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   switch (type) {
   case 1:
      bits = sort_array(keys(_sold_stats), (: _sold_stats[$1]->num_sold - _sold_stats[$2]->num_sold :));
      break;
   case 2:
      bits = sort_array(keys(_sold_stats), (: _sold_stats[$1]->value_sold - _sold_stats[$2]->value_sold :));
      break;
   case 3 :
      bits = sort_array(keys(_sold_stats), (: strcmp(((class shop_stats)_sold_stats[$1])->seller, ((class shop_stats)_sold_stats[$1])->seller) :));
      break;
   case 4 :
      bits = sort_array(keys(_sold_stats), (: strcmp(((class shop_stats)_sold_stats[$1])->name, ((class shop_stats)_sold_stats[$1])->name) :));
      break;
   default :
      bits = sort_array(keys(_sold_stats), 0);
      break;
   }
   ret = "Statistics for items sold since " + ctime(_stats_start) + ".\n";
   foreach (name in bits) {
      stat = _sold_stats[name];
      ret += name + ": " + stat->num_sold + " for " +
             MONEY_HAND->money_value_string(stat->value_sold, place) + ".\n";
   }
   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
#if USE_TRANSACTIONS
int do_stats_transactions() {
   class shop_transaction bing;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   ret = "Statistics for transactions since " + ctime(_stats_start) + ".\n";
   foreach (bing in _transactions) {
      ret += "$I$5=" + query_transaction_string(bing) + "\n";
   }
   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
#endif
int do_stats_money() {
   string ret;
   int stock_value;
   string place;
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   ret += "\nCurrent money spent " +
          MONEY_HAND->money_value_string(_total_outgoing, place) +
          " and money made " +
          MONEY_HAND->money_value_string(_total_ingoing, place) + ".\n";
   foreach (ob in query_controller()->query_sell_list_obs()) {
      stock_value += ob->query_value();
   }
   ret += "The current stock value is " +
             MONEY_HAND->money_value_string(stock_value, place) +
          ".\n";
   ret += "\n";
   if (query_owners_money() > 0) {
      ret += "The owner current has a cash float (royalties) of " +
             MONEY_HAND->money_value_string(query_owners_money(), place) +
             ".\n";
   } else if (query_owners_money() < 0) {
      ret += "The owner current has a cash deficit of " +
             MONEY_HAND->money_value_string(-query_owners_money(), place) +
             ".\n";
   }
   write(ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
int do_helper_list() {
   write("$I$3=The current helpers are: " +
         query_multiple_short(_helpers) + ".\n");
   return 1;
}
int do_helper_add(string helper) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to mess with the helpers.\n");
      return 0;
   }
   helper = lower_case(helper);
   if (is_helper(helper)) {
      add_failed_mess(capitalize(helper) + " is already a helper.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(helper)) {
      add_failed_mess(capitalize(helper) + " is not a player.\n");
      return 0;
   }
   _helpers += ({ helper });
   add_succeeded_mess("$N add$s " + capitalize(helper) +
                      " as a helper.\n");
   return 1;
}
int do_helper_remove(string helper) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to mess with the helpers.\n");
      return 0;
   }
   helper = lower_case(helper);
   if (!is_helper(helper)) {
      add_failed_mess(capitalize(helper) + " is not a helper to remove.\n");
      return 0;
   }
   _helpers -= ({ helper });
   add_succeeded_mess("$N remove$s " + capitalize(helper) +
                      " as a helper.\n");
   return 1;
}
private object* variable_objects(string seller, int cost, object* obs) {
   return obs;
}
private string variable_sale_name(string seller, int cost, object* ob, string name, string category) {
   if (name) {
      return lower_case(name);
   }
   return "";
}
private string variable_sale_category(string seller, int cost, object* ob, string name, string category) {
   if (category) {
      return lower_case(category);
   }
   return "";
}
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category) {
   return cost;
}
void init() {
   expression_util::init();
   craft_shop_category::init();
   add_command("waiting", "", (: do_list_approval(1) :));
   add_command("waiting", "unapproved", (: do_list_approval(0) :));
   add_command("reject", "<string'id'>",
               (: do_approve_reject($4[0], 0, -1) :));
   add_command("retrieve", "<string'id'>", (: do_return($4[0]) :) );
   add_command("return", "<string'id'>", (: do_return($4[0]) :) );
   add_command("value", "<indirect:object>",
               (: do_approve_auto_item_test($1) :));
   if (!is_helper(this_player()->query_name())) {
      return ;
   }
   add_command("approve", "<string'id'>", (: do_approve_item($4[0], 0) :));
   add_command("approve", "<string'id'> for <string'value'>",
               (: do_approve_item($4[0], $4[1]) :));
   add_command("reject", "<string'id'> position <number>",
               (: do_approve_reject($4[0], 0, $4[1]) :));
   add_command("reject", "<string'id'> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[1], -1) :));
   add_command("reject", "<string'id'> position <number> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[2], $4[1]) :));
   add_command("browse", "waiting <string'id'>",
               (: do_approve_browse($4[0]) :));
   add_command("checkout", "<string'id'>",
               (: do_approve_checkout($4[0]) :));
   add_command("checkin", "<indirect:object:me-here>",
               (: do_approve_checkin($1) :));
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }
   add_command("set", "low approve cost <string'cost|disable'>",
               (: do_approve_auto_low($4[0]) :));
   add_command("auto", "add approve expression <string'condition'> cost <string'value'> as <string'list name'>",
               (: do_approve_auto_expression_add($4[0], $4[1],
                            PLAYER_CRAFT_SHOP_EXPR_ACCEPT, $4[2]) :));
   add_command("auto", "add deny expression <string'condition'>",
               (: do_approve_auto_expression_add($4[0], 0,
                            PLAYER_CRAFT_SHOP_EXPR_DENY, 0) :));
   add_command("auto", "remove expression <string'id'>",
               (: do_approve_auto_expression_remove($4[0]) :));
   add_command("markup", "<number'percentage'>",
               (: do_approve_percentage($4[0]) :));
   add_command("auto", "add name <string'name'> up to <string'value'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "remove name <string'name'>",
               (: do_approve_auto_item_remove($4[0]) :));
   add_command("auto", "remove object <indirect:object>",
               (: do_approve_auto_item_remove_object($1) :));
   add_command("set", "high queue cost <string'cost|disable'>",
               (: do_approve_auto_high($4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'>",
               (: do_approve_auto_high_deny($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'>",
               (: do_approve_limit($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'> for <string'player'>",
               (: do_approve_limit_person_items($4[1], $4[0]) :));
   add_command("set", "high queue cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value($4[1], $4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value_deny($4[1], $4[0]) :));
   add_command("approve", "limit remove <string'player'>",
               (: do_approve_limit_person_remove($4[0]) :));
   add_command("expressions", "",
               (: do_expression_status(0) :));
   add_command("expressions", "hints",
               (: do_expression_status(1) :));
   add_command("pay", "deficit",
               (: do_approve_pay_deficit() :));
   add_command("stats", "items by name", (: do_stats_items(4) :));
   add_command("stats", "items by seller", (: do_stats_items(3) :));
   add_command("stats", "items by number", (: do_stats_items(1) :));
   add_command("stats", "items by value", (: do_stats_items(2) :));
#if USE_TRANSACTIONS
   add_command("stats", "transactions", (: do_stats_transactions() :));
#endif
   add_command("stats", "money", (: do_stats_money() :));
   add_command("status", "<direct:object>", (: do_main_status(0) :));
   add_command("status", "<direct:object> hints", (: do_main_status(1) :));
   add_command("check", "sell <indirect:object>",
                (: do_check_sell($1) :));
   add_command("category", "list", (: do_list_categories() :));
   add_command("category", "default <string'category'>",
               (: do_set_default_category($4[0]) :));
   add_command("category", "add <string'category'>",
               (: do_add_new_category($4[0]) :));
   add_command("category", "description <string'category'> <string:quoted'description'>",
               (: do_category_description($4[0], $4[1]) :));
   add_command("category", "description <string'category'> remove",
               (: do_category_description($4[0], 0) :));
   add_command("category", "information <string'category'> <string:quoted'information'>",
               (: do_category_information($4[0], $4[1]) :));
   add_command("category", "information <string'category'> remove",
               (: do_category_information($4[0], 0) :));
   add_command("category", "remove <string'category'>",
               (: do_remove_category($4[0]) :));
   add_command("category", "rename <string'category'> to <string'category'>",
               (: do_rename_category($4[0], $4[1]) :));
   add_command("helper", "list",
               (: do_helper_list() :));
   add_command("helper", "add <string'helper'>",
               (: do_helper_add($4[0]) :));
   add_command("helper", "remove <string'helper'>",
               (: do_helper_remove($4[0]) :));
   add_command("buy", "force <indirect:object:" +
                      file_name(query_controller()->query_sell_list()) + ">",
                (: do_buy($1, 1) :));
}

==================================================
FILE: shops/inherit/pub.c
==================================================

#include <shops/pub_shop.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <map.h>
inherit "/std/shops/inherit/open_shop";
inherit "/std/shops/inherit/shop_event";
void add_hidden_object(object ob);
private mapping _menu_items;
private mapping _menu_aliases;
private string _menu_header;
private string _language;
private int _display_header;
private string *_menu_subheadings;
private int _display_subheadings;
private int no_standard_alias;
private object _menu_object;
private object _counter;
void add_menu_alias( mixed alias, string actual );
string *calc_standard_aliases( string *aliases );
int do_buy( object *obs, string dir, string indir, mixed *args );
float query_discount( object ob );
object make_counter();
void create() {
   shop_event::create();
   _menu_items = ([ ]);
   _menu_aliases = ([ ]);
   _menu_header = "The menu reads:";
   _display_header = 1;
   _menu_subheadings = ({ "Appetisers", "Main Courses", "Desserts",
                         "Alcoholic Beverages", "Soft Drinks",
                         "Hot Drinks" });
   _display_subheadings = 1;
   if( base_name( this_object() ) + ".c" != __FILE__ ) {
      _menu_object = clone_object( PUB_MENU_FILE );
      _menu_object->set_pub( this_object() );
      add_hidden_object( _menu_object );
      _counter = make_counter();
   }
}
void init() {
   this_player()->add_command( "buy", this_object(), "<string>" );
   this_player()->add_command( "buy", this_object(),
                     "<string> for <indirect:living:here>" );
   this_player()->add_command( "order", this_object(), "<string>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
   this_player()->add_command( "order", this_object(),
                     "<string> for <indirect:living:here>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
}
varargs void add_menu_item(
   string name,
   int type,
   int cost,
   string item,
   string container,
   int volume,
   int intox
) {
   class menu_item new_item;
   string noun, alias;
   string *adjectives, *aliases;
   if( intox < 0 )
      intox = 0;
   if( intox > 10 )
      intox = 10;
   new_item = new( class menu_item );
   new_item->type = type;
   new_item->cost = cost;
   new_item->item = item;
   new_item->container = container;
   new_item->volume = volume;
   new_item->intox = intox;
   _menu_items[name] = new_item;
   if( no_standard_alias ) {
      if( lower_case( name ) != name )
         add_menu_alias( lower_case( name ), name );
      return;
   }
   adjectives = explode( lower_case( name ), " " );
   noun = adjectives[sizeof(adjectives) - 1];
   adjectives = adjectives[0..sizeof(adjectives) - 2];
   aliases = calc_standard_aliases( adjectives );
   foreach( alias in aliases ) {
      add_menu_alias( implode( ({ alias, noun }), " " ), name );
   }
}
string *calc_standard_aliases( string *array ) {
   int i, num_aliases;
   string *new_alias, *aliases;
   if( !sizeof( array ) )
      return ({ 0 });
   if( sizeof( array ) == 1 )
      return ({ array[0], 0 });
   aliases = calc_standard_aliases( array[0..sizeof( array ) - 2] );
   num_aliases = sizeof( aliases );
   for( i = 0; i < num_aliases; i++ ) {
      new_alias = ({ aliases[i], array[ sizeof( array ) - 1] });
      aliases += ({ implode( new_alias, " " ) });
   }
   return aliases;
}
mapping query_menu_items() {
   return _menu_items;
}
int query_pub() {
   return 1;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
int remove_menu_item( string name ) {
   if( !_menu_items[name] ) {
      return 0;
   }
   map_delete( _menu_items, name );
   return 1;
}
string string_menu( string *items ) {
   int loop;
   string str, place;
   str = "";
   place = this_object()->query_property( "place" );
   if( !place || ( place == "" ) ) {
      place = "default";
   }
   for( loop = 0; loop < sizeof(items); loop++ ) {
      str += sprintf( "    %-30s %s\n", items[loop],
             MONEY_HAND->money_value_string(
             _menu_items[items[loop]]->cost, place ) );
   }
   return str;
}
string *query_items_of_type( int type ) {
   int i;
   string *selected;
   string *items;
   selected = ({ });
   items = keys( _menu_items );
   for( i = 0; i < sizeof(items); i++ ) {
      if( _menu_items[items[i]]->type == type ) {
         selected += ({ items[i] });
      }
   }
   selected = sort_array( selected, (: _menu_items[$1]->cost -
                                       _menu_items[$2]->cost :) );
   return selected;
}
string string_menu_of_type( int type ) {
   string str;
   string *items;
   items = query_items_of_type( type );
   if( !sizeof(items) ) {
      return "";
   }
   if( _display_subheadings ) {
      str = _menu_subheadings[ type ] + "\n";
   }
   str += string_menu( items );
   return sprintf( "%-=*s\n", (int)this_player()->query_cols(), str );
}
string read() {
   string ret;
   ret = "\n";
   if( _display_header ) {
      ret += _menu_header + "\n";
   }
   ret += string_menu_of_type( PUB_APPETISER );
   ret += string_menu_of_type( PUB_MAINCOURSE );
   ret += string_menu_of_type( PUB_DESSERT );
   ret += string_menu_of_type( PUB_ALCOHOL );
   ret += string_menu_of_type( PUB_SOFTDRINK );
   ret += string_menu_of_type( PUB_HOTDRINK );
   return ret;
}
void set_display_header( int value ) {
   _display_header = value;
}
int query_display_header() {
   return _display_header;
}
void set_menu_header( string header ) {
   _menu_header = header;
}
string query_menu_header() {
   return _menu_header;
}
void set_display_subheadings( int value ) {
   _display_subheadings = value;
}
int query_display_subheadings() {
   return _display_subheadings;
}
void set_menu_subheadings( int subheading, string text ) {
   _menu_subheadings[ subheading ] = text;
}
string *query_menu_subheadings() {
   return _menu_subheadings;
}
void add_menu_alias( mixed alias, string actual ) {
   string bing;
   if (arrayp(alias)) {
      foreach (bing in alias) {
         add_menu_alias(bing, actual);
      }
   }
   _menu_aliases[alias] = actual;
}
void add_menu_aliases( string *aliases, string actual ) {
   string alias;
   foreach( alias in aliases ) {
      add_menu_alias( alias, actual );
   }
}
mapping query_menu_aliases() {
   return _menu_aliases;
}
int remove_menu_alias( string alias ) {
   if( !_menu_aliases[alias] ) {
      return 0;
   }
   map_delete( _menu_aliases, alias );
   return 1;
}
void set_no_standard_alias( int flag ) {
   no_standard_alias = flag;
}
int query_no_standard_alias() {
   return no_standard_alias;
}
object create_real_object( string name ) {
   object item, container;
   if( _menu_items[name]->container ) {
      container = this_object()->create_container(
                                    _menu_items[name]->container );
      if( !container ) {
         container = clone_object( _menu_items[name]->container );
      }
      if( !container ) {
         container = ARMOURY->request_item(
                                 _menu_items[name]->container, 100 );
      }
   }
   if( _menu_items[name]->item ) {
      item = this_object()->create_item( _menu_items[name]->item );
      if( !item ) {
         item = clone_object( _menu_items[name]->item );
      }
      if( !item ) {
         item = ARMOURY->request_item( _menu_items[name]->item, 100 );
      }
   }
   if( item && _menu_items[name]->volume ) {
      item->set_amount( _menu_items[name]->volume );
   } else if ( item && !_menu_items[name]->volume &&
              ( _menu_items[name]->type == PUB_ALCOHOL ||
                _menu_items[name]->type == PUB_HOTDRINK ||
                _menu_items[name]->type == PUB_SOFTDRINK ) ) {
      item->set_amount( container->query_max_volume() -
                        container->query_volume() );
   }
   if( item && container ) {
      if( (int)item->move( container ) != MOVE_OK ) {
         write( "The " + container->short() + " is too small to hold " +
            item->the_short() + ".  Please file a bug report.\n" );
         item->move( "/room/rubbish" );
      }
   }
   if( container ) {
      return container;
   }
   if( item ) {
      return item;
   }
   return 0;
}
int do_buy( object *obs, string dir, string indir, mixed *args ) {
   int value, cost;
   string str, place;
   object person, thing;
   object *succeededpeople, *deadpeople, *failedpeople, *poorpeople;
   succeededpeople = ({ });
   deadpeople = ({ });
   failedpeople = ({ });
   poorpeople = ({ });
   str = args[0];
   if( this_player()->query_property( "dead" ) ) {
      add_failed_mess( "How can you expect to buy " + str + " when you're "
         "dead?\n" );
      return 0;
   }
   if( _menu_aliases[str] ) {
      str = _menu_aliases[str];
   }
   if( !_menu_items[str] ) {
      if (!broadcast_shop_event(PUB_EVENT_NOT_AVAILABLE, this_player(), str)) {
         add_failed_mess( "Sorry, " + str + " is not on the menu.\n" );
      }
      return 0;
   }
   if ( !is_open( this_player(), _menu_items[str]->type ) ) {
      broadcast_shop_event(PUB_EVENT_NOT_OPEN, this_player());
      return 0;
   }
   if( !sizeof( obs ) ) {
      obs = ({ this_player() });
   }
   foreach( person in obs ) {
      if( person->query_property( "dead" ) ) {
         deadpeople += ({ person });
         continue;
      }
      if( !living( person ) ||
          !interactive( person ) && !person->query_property( "npc" ) ) {
         failedpeople += ({ person });
         continue;
      }
      cost = ( _menu_items[str]->cost ) * query_discount( this_player() );
      place = this_object()->query_property( "place" );
      if( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
      if( place != "default" ) {
         value += (int)this_player()->query_value_in( "default" );
      }
      if( cost > value ) {
         poorpeople += ({ person });
         continue;
      }
      thing = create_real_object( str );
      if( !thing ) {
         add_failed_mess( "Something is buggered.  Please file a bug report.  "
            "Thank you.\n" );
         return 0;
      }
      this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                        cost, place ), place );
      succeededpeople += ({ person });
      if( (int)thing->move( person ) != MOVE_OK ) {
         if( (int)thing->move( _counter ) != MOVE_OK ) {
            thing->move( this_object() );
            write("You cannot pick " + thing->a_short() +
               " up.  It's left on the floor for you.\n" );
         } else {
           write("You cannot pick " + thing->a_short() +
              " up.  It's left on the counter for you.\n" );
         }
      }
   }
   if( sizeof( succeededpeople ) ) {
      if (!broadcast_shop_event(PUB_EVENT_BOUGHT_STUFF, this_player(),
                           succeededpeople, str)) {
         if( !MAP_HANDLER->compare_arrays( succeededpeople,
                                           ({ this_player() }) ) ) {
            this_player()->add_succeeded_mess( this_object(),
               "$N $V $I.\n", ({ add_a(str) }) );
         } else {
            add_succeeded_mess("$N $V "
               + query_multiple_short( ({ thing }), "a" ) + " for $I.\n",
               succeededpeople);
         }
      }
   } else {
      if( sizeof( deadpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_DEAD_PEOPLE, this_player(),
                              deadpeople, str)) {
            add_failed_mess("What use " +
               ( sizeof( deadpeople ) > 1?"have ":"has " ) +
               query_multiple_short( deadpeople, "one" ) + " got for " + str +
               "?\n" );
         }
      }
      if( sizeof( failedpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_FAILED_PEOPLE, this_player(),
                              failedpeople, str)) {
            add_failed_mess("You can't buy anything for " +
               query_multiple_short( failedpeople, "one" ) + ".\n" );
         }
      }
      if( sizeof( poorpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_POOR_PERSON, this_player(),
                              poorpeople, str)) {
            add_failed_mess("You cannot afford to order " + str +
               " for " + query_multiple_short( poorpeople, "one" ) + ".\n" );
         }
      }
      return 0;
   }
   return 1;
}
void dest_me() {
   if( _menu_object ) {
      _menu_object->dest_me();
   }
}
float query_discount( object ob ) {
   return 1.0;
}
object make_counter() {
   object ob;
   ob = clone_object( PUB_COUNTER_FILE );
   add_hidden_object( ob );
   return ob;
}
object query_counter() {
   return _counter;
}
object query_menu() {
   return _menu_object;
}

==================================================
FILE: shops/inherit/shop_event.c
==================================================

private nosave object* _events;
void create() {
   _events = ({ });
}
void add_shop_observer(object observer) {
   if (!_events) {
      _events = ({ });
   }
   if (member_array(observer, _events) == -1) {
      _events += ({ observer });
   }
}
void remove_shop_observer(object observer) {
   _events -= ({ observer });
}
int broadcast_shop_event(string type, object player, mixed args ...) {
   debug_printf("Calling %O on %O\n", "event_shop_" + type, _events);
   if (sizeof(filter(call_other(_events, "event_shop_" + type, this_object(),
                                player, args ...),
                    (: $1 :)))) {
      return 1;
   }
   return 0;
}

==================================================
FILE: shops/inherit/store_close.c
==================================================

#include <weather.h>
#include <climate.h>
#include <am_time.h>
void open_up();
void close_up();
private string _keeper;
private string *_outside_rooms;
private string *_exits;
private string _burglar;
private string _file;
private int _flag;
private int _open;
private int _closed;
private nosave object _keeper_ob;
void event_weather(int whats_changed){
   if(whats_changed >= 8){
      if (_flag) {
         call_out("night_time_check", 1);
      } else {
         call_out("day_time_check", 1);
      }
   }
}
protected void night_time_check(){
   int bing;
   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 12 && bing < 23 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 0 && bing < 12 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
}
protected void day_time_check(){
   int bing;
   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 0 && bing < 12 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 12 && bing < 23 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
}
void set_night_close(int night, string shopkeeper, string *outside,
    string burglar_func){
   int i;
   _flag = night;
   WEATHER->weather_notify( this_object(), NOTIFY_DAY );
   _keeper = _file = shopkeeper;
   if (sizeof(outside) && !(sizeof(outside)%2)) {
      _exits = allocate(sizeof(outside)/2);
      _outside_rooms = allocate(sizeof(outside)/2);
      for(i=0; i<sizeof(outside); i++) {
         if(!i%2)
            _outside_rooms[i] = outside[i];
         else
            _exits[i-1] = outside[i];
      }
   }
   _burglar = burglar_func;
}
void close_up(){
   object *obs;
   object *people;
   object bing;
   object *keeper_ob;
   int i;
   if (_keeper == "none") {
     event (this_object(), "person_say", "The shopkeeper says: ",
       "I'm sorry, it's time to close!", "common");
     tell_room (this_object(), "The shopkeeper ushers you out of "
          "the store.\n");
   }
   else {
      keeper_ob = children(_keeper);
      if (!sizeof(keeper_ob)) {
         return;
      }
      if (keeper_ob[0]->query_fighting()) {
         call_out("close_up", 60);
         return;
      }
      keeper_ob[0]->do_command("'I'm sorry, it's time to close!");
      keeper_ob[0]->do_command(":ushers you out of the store.");
      keeper_ob[0]->move("/room/rubbish");
   }
   obs = all_inventory( this_object() );
   people = filter(obs, (: $1->query_property("player") :));
   foreach(bing in people){
      bing->move_with_look(_outside_rooms[0]);
   }
   for(i=0; i<sizeof(_outside_rooms); i++){
      _outside_rooms[i]->modify_exit(_exits[i], ({"open", 0, "locked", 1,
          "difficulty", 4}));
   }
}
void open_up(){
   int i;
   for(i=0; i<sizeof(_outside_rooms); i++){
     _outside_rooms[i]->modify_exit(_exits[i], ({"open", 1, "locked", 0,
        "difficulty", 4}));
   }
   if (_keeper == "none") {
      return;
   }
   _keeper_ob = clone_object(_file);
   _keeper_ob->move(this_object());
}
void event_enter(object ob, string message, object from){
   if (!_burglar) {
      return;
   }
   if (!_closed) {
      return;
   }
   if (ob->query_creator()) {
      return;
   }
   if (!ob->query_property("player")) {
      return;
   }
   call_out(_burglar, 1, ob);
}
mapping query_dynamic_auto_load() {
   return ([ "keeper ob" : _keeper_ob ]);
}
void init_dynamic_arg(mapping map) {
   _keeper_ob = map["keeper ob"];
}

==================================================
FILE: shops/inherit/vault_entry.c
==================================================

#include <money.h>
#include <vault.h>
#define PTS proprietor->the_short()
#define TIME_LIMIT 500
#define SPAM_GUARD (60 * 3)
void add_exit(string name, string dest, string type);
void modify_exit(string name, mixed* stuff);
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);
string location, vault_name, vault_room;
int visit_cost, open_cost;
object proprietor;
void set_location(string str) { location = str; }
void set_open_cost(int i) { open_cost = i; }
void set_visit_cost(int i) { visit_cost = i; }
void set_proprietor(object ob) { proprietor = ob; }
void set_vault_name(string str) { vault_name = str; }
void set_vault_exit(string direc, mixed dest, string type) {
  vault_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int apply_for_account() {
  string owner;
  object container;
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  this_player()->add_succeeded_mess( this_object(), "", ({ }) );
  write("You ask for an account.\n");
  say((string)this_player()->one_short() +" asks for an account.\n");
  owner = (string)this_player()->query_name();
  if ( master()->file_exists( VAULT_SAVE +vault_name+ "/"+ owner +".o" ) ||
       query_property( owner ) )
  {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you already have an "
         "account." );
      return notify_fail("");
    }
    proprietor->do_command( "say You already have an account!" );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }
  if ( this_player()->query_value_in( location) < open_cost ) {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you don't have enough money!" );
      return notify_fail("");
    }
    proprietor->do_command("say You do not have the "+
                           (string)MONEY_HAND->money_value_string(open_cost,
                                                                  location) +
                           " that it costs to open an account." );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }
  proprietor->do_command("say Very well, that'll be "+
                         (string)MONEY_HAND->money_value_string( open_cost,
                                                                 location) +
                         ", please." );
  this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( open_cost,
                                                                     location),
                            location);
  write( "You pay "+PTS+".\n" );
  say( (string)this_player()->the_short() +" pays "+proprietor->the_short()+
       ".\n" );
  proprietor->do_command("say As a new account holder, "
                         "your first use of the facility will be free.  "
                         "Thereafter, it will cost "+
                         (string)MONEY_HAND->money_value_string( visit_cost,
                                                                 location) +
                         " each time.");
  add_property( owner, 1 );
  container = vault_room->init_container(this_player());
  container->dest_me();
  return 1;
}
void init() {
  add_command( "apply", "for [an] account", (: apply_for_account :) );
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !master()->file_exists( VAULT_SAVE +vault_name+ "/" + owner +".o" ) &&
       !query_property( owner ) )
  {
    tell_object( thing, PTS+
                 " intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have an account "
         "so I won't let you in!" );
      return notify_fail("");
    }
    proprietor->do_command("say You do not have an account!");
    if( interactive(thing) )
      proprietor->do_command("say For "+
                             (string)MONEY_HAND->money_value_string(open_cost,
                                                                    location)+
                             ", you could apply for an account.\n" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  if ( !( vroom = find_object( vault_room ) ) ) {
    vault_room->load_me();
    vroom = find_object( vault_room );
  }
  if( sizeof( filter_array( all_inventory( vroom ), (: userp( $1 ) :) ) ) ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short()
       +".\n", thing );
    if( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just told you, someone is using the "
         "facility at the moment!" );
      return notify_fail("");
    }
    proprietor->do_command("say Someone is using the facility at the moment!");
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  if( query_property( owner ) ) {
    remove_property(owner);
    tell_object(thing, PTS+" waves you through.\n" );
    tell_room( this_object(), PTS+" waves "+(string)thing->the_short() +
      " through.\n", thing );
    call_out( "check_idler", TIME_LIMIT, thing );
    return 1;
  }
  if ( (int)thing->query_value_in( location ) < visit_cost ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short()
      +".\n", thing );
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have enough "
         "money to use the facility!" );
      return notify_fail("");
    }
    proprietor->do_command("say It costs "+
                           (string)MONEY_HAND->money_value_string( visit_cost,
                                                                   location ) +
                           " to use the facility!" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay "+PTS+" who waves you through.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays "+PTS+" who waves "+ (string)thing->query_objective() +
             " through.\n", thing );
  remove_call_out("check_idler");
  call_out("check_idler", TIME_LIMIT, thing);
  return 1;
}
void check_idler(object who) {
  if(who && base_name(environment(who)) == vault_room) {
    tell_object(who, "You've been in here too long so " + PTS + " comes and "
              "drags you out.\n");
    who->move_with_look(this_object(),
                      "$N is dragged out of the vault by the hair.",
                      "$N is dragged out of the vault by the hair.");
  }
}
void player_quitting(object who, object env) {
}

==================================================
FILE: shops/objs/counter.c
==================================================

#include <position.h>
inherit "/std/surface";
void create() {
   ::create();
   set_name( "counter" );
   set_short( "counter" );
   set_long( "The counter seems to be where you should leave glasses and "
      "plates to be cleared away.\n" );
   reset_get();
   add_property(CAN_POSITION_PROPERTY, 1);
}
void clear_item( object item ) {
   if( environment( item ) == this_object()
       && !sizeof( all_inventory( item ) ) )
      item->move( "/room/rubbish" );
}
void event_enter( object ob, string mess, object from ) {
   if( ob->query_property( "pub item" )
       && !sizeof( all_inventory( ob ) ) )
      call_out( "clear_item", 3, ob );
}

==================================================
FILE: shops/player_shop/counter.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <money.h>
private nosave mixed *_money;
private nosave object _register = 0;
private nosave string _save_file = "",
                      _place = UNSET_STR,
                      _office = "",
                      _storeroom = "",
                      _mgr_office = "",
                      _shop_front = "",
                      _store_dir = "",
                      _office_dir = "",
                      _shop_dir = "";
private nosave int _call_save = 0;
int action(string);
void add_money_ob(object);
int adjust_register(string, int);
string directions_to(string);
private int do_calc(int,string,int);
private int do_correction(mixed);
private int do_log(mixed *);
int query_register();
private void save_me(string);
void save_register(int);
protected void set_office(string);
protected void set_directions(string, string, string);
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   add_property("no burial", 1);
   add_property("determinate", "");
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   add_item("calculator", "A standard shop's calculator used to total "
     "up all those difficult prices.  To use, see \"syntax calc\".");
   add_help_file("player_shop_counter");
}
void init()
{
   ::init();
   if (!_office || _office == "") return;
   this_player()->command_override((: action :));
   add_command("calc", "<number> {+|-|*|/} <number>",
     (: do_calc($4[0],$4[1],$4[2]) :));
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
   {
      add_command("log",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_log($4) :));
      add_command("correction",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_correction($4) :));
   }
}
int action(string str)
{
   string st1;
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
     return 0;
   sscanf(str,"%s %s",str,st1);
   if(str == "get" || str == "take")
      if (strsrch(st1, "register") != -1)
      {
         tell_object(this_player(), "You are not an active employee here!\n");
         return 1;
      }
   return 0;
}
void add_money_ob(object money)
{
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "add_money_ob()");
      return;
   }
   if (!money) return;
   money->move( _register );
   save_register(TRUE);
}
int adjust_register(string player, int amount)
{
   int value;
   object cash, change;
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "adjust_register(" + player+","+amount+")");
      return 0;
   }
   if (amount < 0) return 0;
   cash = present(MONEY_ALIAS, _register);
   if ( !cash ) return 0;
   _money = cash->query_money_array() + ({});
   value = MONEY_HAND->query_total_value(_money, _place);
   if (value < amount) amount = value;
   change = MONEY_HAND->pay_amount_from( amount, cash, _place );
   if (change) change->move( _register );
   _office->shop_log(ACCOUNTS, player, "adjusted the register by "+
     MONEY_HAND->money_value_string(amount, _place), UNPAID);
   save_register(TRUE);
   return amount;
}
string directions_to(string place)
{
   if (place == _storeroom) return _store_dir;
   if (place == _office) return _office_dir;
   if (place == _shop_front) return _shop_dir;
   return "here";
}
private int do_calc(int a, string sign, int b)
{
   int c = 0;
   string result = a+ " "+ sign+ " "+ b+ " = ",
          temp;
   switch (sign)
   {
     case "+" :
        result += sprintf("%d\n", a+b);
        break;
     case "-" :
        result += sprintf("%d\n", a-b);
        break;
     case "*" :
        result += sprintf("%d\n", a*b);
        break;
     case "/" :
        if (!b)
        {
           tell_object( this_player(),
             "Trying to divide by zero?  Whatever next?\n");
           return 1;
        }
        if (a % b) c = ((a%b) * 100)/b;
        temp = sprintf("%02d",c);
        result += sprintf("%d.%s\n", a/b, temp[0..1]);
        break;
   }
   tell_object(this_player(), result);
   add_succeeded_mess("$N use$s the calculator.\n");
   return 1;
}
private int do_correction(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     "ERROR IN LOG - correct entry follows:", UNPAID);
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], UNPAID);
   add_succeeded_mess("$N make$s a correction in the transaction log book.\n");
   return 1;
}
private int do_log(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], PAID);
   add_succeeded_mess("$N make$s an entry in the transaction log book.\n");
   return 1;
}
void event_death(object k, object *o, object k2, string r, string k3)
{
   _office->event_death(k, o, k2, r, k3);
}
void event_enter(object ob, string message, object from)
{
   _office->event_enter(ob, message, from);
}
int query_register()
{
   object cash = present(MONEY_ALIAS, _register);
   if (!cash) return 0;
   _money = cash->query_money_array() + ({});
   return MONEY_HAND->query_total_value(_money, _place);
}
private void save_me(string name)
{
   int difference;
   object cash;
   mixed *old = _money + ({});
   if (!_register) return;
   cash = present(MONEY_ALIAS, _register);
   if (!cash) _money = ({});
   else _money = (mixed *)cash->query_money_array() + ({});
#ifdef DEBUG
   tell_creator(CREATOR, "Register contains: %O.\n", _money);
#endif
   _office->save_register(_money);
   difference = MONEY_HAND->query_total_value(_money, _place) -
     MONEY_HAND->query_total_value(old, _place);
   if (!difference) return;
   _office->adjust_takings(difference);
   if (!name || name == "") return;
   if (difference < 0)
      _office->shop_log(PURCHASE, name, "removed "+
        MONEY_HAND->money_value_string(-difference, _place)+
        " from register", UNPAID);
   else
      _office->shop_log(SALE, name, "added "+
        MONEY_HAND->money_value_string(difference, _place)+
        " to register", UNPAID);
}
void save_register(int no_player)
{
   remove_call_out(_call_save);
   _call_save = call_out((: save_me($((!no_player)?
      this_player()->query_name():"shop")) :), 1);
}
protected void set_directions(string office, string storeroom, string shop)
{
   _office_dir = office;
   _store_dir = storeroom;
   _shop_dir = shop;
}
protected void set_long(string long_desc)
{
   long_desc += "Employees of the shop can \"log\" transactions or "
     "\"correction\"s here.  The shop's cash register is under the "
     "counter and there is a calculator next to that.\n";
   ::set_long(long_desc);
}
protected void set_office(string path)
{
   object cash;
   _office = path;
   _storeroom = _office->query_storeroom();
   _mgr_office = _office->query_mgr_office();
   _shop_front = _office->query_shop_front();
   _place = _office->query_place();
   if (_register) return;
   _register = clone_object("/obj/misc/cash_register");
   _register->set_name("register");
   _register->set_short("cash register");
   _register->add_adjective("cash");
   _register->set_long("The cash register is really just an iron drawer "
     "mounted underneath the counter.  In a certain light, it almost "
     "seems tongue-shaped.\n");
   _register->set_shop(this_object());
   add_hidden_object(_register);
   _register->reset_get();
   _money = _office->restore_register();
   if (!_money || !sizeof(_money)) return;
   cash = clone_object(MONEY_OBJECT);
   cash->set_money_array(_money);
   cash->move(_register);
}

==================================================
FILE: shops/player_shop/mgr_office.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
#include <move_failures.h>
#include <money.h>
#include "patterns.h"
private nosave string _office = "",
_place = "",
_shop_front = "",
_counter = "",
_storeroom = "";
private nosave object _notice = 0;
private string cap_name(string);
private int do_accounts();
private int do_ban(mixed *);
private int do_check();
private int do_claim();
private int do_commend(string);
private int do_demote(string);
private int do_fire(mixed *);
private int do_leave(mixed *);
private int do_list(mixed *);
private int do_logs(mixed *, string);
private int do_mail(string);
private int do_memo();
private int do_office();
private int do_policies();
private int do_policy(mixed *,string);
private int do_project(string);
private int do_query(string);
private int do_remove();
private int do_rent();
private int do_retire();
private int do_set(mixed *, string);
private int do_suspend(mixed *);
private int do_transfer(mixed *);
private int do_unban(string);
private int do_view(string,string);
private int do_vote(mixed *, string);
private int do_warn(mixed *);
private void end_memo(string,string);
private void end_policy_suggest(string,string,int);
private void send_memo(string, string, string);
protected void set_office(string);
private void write_memo(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_mgr_office");
}
void init()
{
    ::init();
    if (!_office || _office == "") return;
    if ( !_office->query_manager(this_player()->query_name()) &&
      !_office->query_retired(this_player()->query_name()) &&
      !this_player()->query_creator()) return;
    add_command("list", ({LIST_BLANK, LIST_CHOICE}),
      (: do_list($4) :));
    add_command("memo", "", (: do_memo() :));
    add_command("office", "", (: do_office() :));
    add_command("claim", "", (: do_claim() :));
    add_command("accounts", "", (: do_accounts() :));
    add_command("logs", ({LOG_BLANK, LOG_NUMBER, LOG_MGR}),
      (: do_logs($4,$5) :));
    add_command("mail", ({"", "<string>"}), (: do_mail($4) :));
    add_command("query", "{pay|employees}", (: do_query($4[0]) :));
    add_command("view", ({VIEW_EMP, VIEW_APP}), (: do_view($4[0],$5) :));
    add_command("project", "{pay|bonus}", (: do_project($4[0]) :));
    add_command("vote", VOTE_POLICY, (: do_vote($4,$5) :));
    add_command("policy", ({POLICY_SUGGEST, POLICY_REMOVE}),
      (: do_policy($4,$5) :));
    add_command("policies", "", (: do_policies() :));
    if (_office->query_retired(this_player()->query_name())) return;
    add_command("rent", "cabinet", (: do_rent() :));
    add_command("remove", "cabinet", (: do_remove() :));
    add_command("retire", "", (: do_retire() :));
    add_command("vote", VOTE_APPLICANT, (: do_vote($4,$5) :));
    add_command("check", "votes", (: do_check() :));
    add_command("commend", "<word'employee'>", (: do_commend($4[0]) :));
    add_command("fire", "<word'employee'> [for] <string'reason'>",
      (: do_fire($4) :));
    add_command("warn", "<word'employee'> [for] <string'reason'>",
      (: do_warn($4) :));
    add_command("demote", "<word'employee'>", (: do_demote($4[0]) :));
    add_command("suspend", "<word'employee'> [for] <number> [months]",
      (: do_suspend($4) :));
    add_command("leave", "<word'employee'> [for] <number> [days]",
      (: do_leave($4) :));
    add_command("ban", "<word'person'> [for] <string'reason'>",
      (: do_ban($4) :));
    add_command("unban", "<word'person'>", (: do_unban($4[0]) :));
    add_command("set", ({SET_EMPS, SET_PAY}), (: do_set($4,$5) :));
    add_command("transfer", "<number'amount'> <string'type'> [from] "
      "{register|bonus|profit} [to] {register|bonus|profit}",
      (: do_transfer($4) :));
}
private string cap_name(string name)
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}
void dest_me()
{
    if (_notice) _notice->dest_me();
    ::dest_me();
}
private int do_accounts()
{
    tell_object(this_player(), "The shop's accounts are as follows:\n"+
      sprintf("   Cash   : %s\n   Bonus  : %s\n   Profit : %s\n",
        MONEY_HAND->money_value_string(_counter->query_register(), _place),
        MONEY_HAND->money_value_string(_office->query_bonus(), _place),
        MONEY_HAND->money_value_string(_office->query_profit(), _place)));
    return 1;
}
private int do_ban(mixed *args) { return _office->do_ban(args); }
private int do_check()
{
    string results,
    name = this_player()->query_name();
    mapping applicants;
    add_succeeded_mess("");
    applicants = _office->get_applicants();
    applicants = filter(applicants, (: $(applicants)[$1][APP_TYPE] == 1 :));
    if (this_player()->query_creator())
    {
        results = "The following votes have been cast:\n\n";
        foreach (string word in sort_array(keys(applicants), 1))
        {
            results += cap_name(word)+ " - applied " +
            ctime(applicants[word][APP_TIME] )+ "\n   Votes for:     ";
            foreach (string vote in applicants[word][APP_FOR])
            results += cap_name(vote) + "  ";
            results += "\n   Votes against: ";
            foreach (string vote in applicants[word][APP_AGAINST])
            results += cap_name(vote) + "  ";
            results += "\n   Abstentions:   ";
            foreach (string vote in applicants[word][APP_ABSTAIN])
            results += cap_name(vote) + "  ";
            results += "\n\n";
        }
        tell_object(this_player(), "$P$Votes cast$P$"+ results);
        return 1;
    }
    results = "You have cast the following votes:\n\nFor: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_FOR]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAgainst: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_AGAINST]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAbstentions: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_ABSTAIN]) != -1)
        results += cap_name(vote)+ "  ";
    tell_object(this_player(), results + "\n");
    return 1;
}
private int do_claim()
{
    object thing;
    if (!_office || _office == "") return 0;
    thing = clone_object(MGR_BOOK);
    thing->set_read_mess("\n   "+ _office->query_shop_name()+ "\n\n"
      "   Manager's Handbook\n\n   This handbook belongs to: "+
      this_player()->query_short()+ "\n\n", "common", 100);
    thing->set_office(_office);
    if (thing->move(this_player()) != MOVE_OK)
    {
        thing->move(this_object());
        tell_object(this_player(),
          "You drop your handbook as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V a new handbook.\n");
    return 1;
}
private int do_commend(string emp) { return _office->do_commend(emp); }
private int do_demote(string emp) { return _office->do_demote(emp); }
private int do_fire(mixed *args) { return _office->do_fire(args); }
private int do_leave(mixed *args) { return _office->do_leave(args); }
private int do_list(mixed *args)
{
    string results, word;
    mapping baddies, applicants;
    string *applied, *hired, *awaiting;
    if (!sizeof(args)) args = ({"employees"});
    add_succeeded_mess("");
    switch (args[0])
    {
    case "applicants" :
        results = "      Applications for employment as at " +
        ctime(time()) + "\n\n";
        applicants = _office->get_applicants();
        if (!applicants || applicants == ([]))
        {
            tell_object(this_player(), results+
              "No applications outstanding.\n");
            return 1;
        }
        applied = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == APPLIED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        hired = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == HIRED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        awaiting = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == AWAITING :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        if ( sizeof(awaiting))
        {
            results += "Applicants awaiting vacancies:\n";
            foreach (word in awaiting)
            results += "     "+ cap_name(word)+
            " - confirmed employment " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(hired))
        {
            results += "Applicants yet to confirm their employment:\n";
            foreach (word in hired)
            results += "     "+ cap_name(word)+ " - voted in " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(applied))
        {
            results += "Applicants yet to be hired or rejected.  Vote now!\n";
            foreach (word in applied)
            {
                results += "     "+ cap_name(word)+ " - applied " +
                ctime(applicants[word][1])+ "\n";
                results += sprintf("     %-12s%-5d%-16s%-5d%-13s%-5d\n",
                  "Votes for:", sizeof(applicants[word][APP_FOR]),
                  "Votes against:", sizeof(applicants[word][APP_AGAINST]),
                  "Abstentions:", sizeof(applicants[word][APP_ABSTAIN]));
            }
        }
        tell_object(this_player(), "$P$Applications list$P$"+ results);
        break;
    case "baddies" :
        if (!m_sizeof(baddies = _office->get_baddies()))
        {
            tell_object(this_player(),
              "There are no people on the list at the moment.\n");
            return 1;
        }
        results = "This is a list of people banned from the shop:\n\n";
        foreach (word in sort_array(keys(baddies), 1))
        {
            results += cap_name(word)+ " banned by "+
            baddies[word][BAD_BANNER]+ " on "+
            ctime(baddies[word][BAD_TIME] )+ ".\n   Banned for "+
            baddies[word][BAD_REASON]+ ".\n\n";
        }
        tell_object(this_player(), "$P$Baddies$P$\n"+ results);
        break;
    default :
        return _office->do_list();
    }
    return 1;
}
private int do_logs(mixed *args, string pattern)
{
    return _office->do_logs(args, pattern);
}
private int do_mail(string words) { return MAIL_TRACK->mail(words); }
private int do_memo()
{
    tell_object(this_player(), "Subject: (hit enter for general memo)\n");
    input_to((: write_memo($1) :), 0);
    add_succeeded_mess("");
    return 1;
}
private int do_office()
{
    int retired = _office->query_retired(this_player()->query_name());
    string result = (retired)?
    "As a retired manager, you can use the following commands:\n":
    "As a manager, you can use the following commands:\n";
    result +=
    "   accounts  - view register, bonus & profit accounts\n"
    "   claim     - claim a manager's handbook\n"
    "   list      - list employees, applicants or banned people\n"
    "   logs      - review the shop's logs\n"
    "   mail      - read / send mail\n"
    "   memo      - send a message to the other managers\n"
    "   policy    - suggest a new (or remove an old) policy for the shop\n"
    "   policies  - check on the proposed policies\n"
    "   project   - view anticipated paypacket & bonus values\n"
    "   query     - query pay amount or number of employees\n"
    "   view      - view a person's history with this shop\n"
    "               or an applicant's application form\n"
    "   vote      - vote for a policy to be implemented into the shop\n";
    if (!retired)
        result +=
        "               or for an applicant to work for the shop\n"
        "   (un)ban   - (un)ban a person from the shop for "+
        BAN_LENGTH+ " days\n"
        "   rent      - rent storeroom cabinets\n"
        "   remove    - remove storeroom cabinets\n"
        "   check     - check votes you have made on applications\n"
        "   commend   - reward an outstanding employee\n"
        "   demote    - demote an employee\n"
        "   fire      - end someone's employment\n"
        "   leave     - place an employee on leave for up to "+
        MAX_LEAVE+ " days\n"
        "   retire    - end your active employment at the shop\n"
        "   set       - set number of employees, and pay amount\n"
        "   suspend   - suspend an employee's bonus entitlement\n"
        "   transfer  - transfer money between register, bonus & profit\n"
        "   warn      - issue a formal warning to an employee\n";
    tell_object(this_player(), result+ "\n");
    add_succeeded_mess("");
    return 1;
}
private int do_policies()
{
    mapping policies = _office->get_new_policies();
    if (!m_sizeof(policies))
        tell_object(this_player(), "There are no policies awaiting sanction.\n");
    else
    {
        int i = 1;
        tell_object(this_player(), "The following policies have been suggested."
          "  Policies in existence are proposed to be overturned.\n");
        foreach(string policy in m_indices(policies))
        tell_object(this_player(), sprintf("%d. %s - %s [%s]. %s\n", i++,
            (policies[policy][POLICY_TYPE])?"MGR":"EMP", policy,
            policies[policy][POLICY_MGR], policies[policy][POLICY_TEXT]));
    }
    return 1;
}
private int do_policy(mixed *args, string pattern)
{
    string *managers, mgr;
    if (pattern == POLICY_SUGGEST)
    {
        if (_office->query_policy(args[1]))
        {
            tell_object(this_player(), "This name is already in use.\n");
            return 1;
        }
        this_player()->do_edit(0, (: end_policy_suggest($1,
              $(lower_case(args[1])),$((args[0] == "manager")?1:0)) :));
        add_succeeded_mess("");
        return 1;
    }
    if (_office->query_policy(args[0]) < 2)
    {
        tell_object(this_player(), "This policy does not exist.\n");
        return 1;
    }
    args[0] = lower_case(args[0]);
    tell_object(this_player(), "You suggest that the "+ args[0]+
      " policy should be removed.\n");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({mgr});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, "TFQC policy suggestion",
      "", "Please note that I would like you to vote on removing the "+
      args[0]+ " policy.\n", 0, 0);
    _office->add_policy_suggest(args[0], "", mgr);
    return 1;
}
private int do_project(string projection)
{
    add_succeeded_mess("");
    switch (projection)
    {
    case "bonus" :
        _office->calc_bonus();
        break;
    case "pay" :
        tell_object(this_player(),
          "For the month to date, the staff wages total "+
          MONEY_HAND->money_value_string( _office->calc_pay(),
            _place)+ ".\n");
        break;
    }
    return 1;
}
private int do_query(string query)
{
    add_succeeded_mess("");
    switch(query)
    {
    case "pay" :
        tell_object(this_player(), "The pay is currently set at "+
          MONEY_HAND->money_value_string(_office->query_pay(),
            _place)+ ".\n");
        break;
    case "employees" :
        tell_object(this_player(),
          "The maximum number of employees is currently "+
          _office->query_maxemp()+ ".\n");
        break;
    default :
    }
    return 1;
}
private int do_remove() { return _office->do_remove(); }
private int do_rent() { return _office->do_rent(); }
private int do_retire() { return _office->do_retire(); }
private int do_set(mixed *args, string pattern)
{
    return _office->do_set(args, pattern);
}
private int do_suspend(mixed *args) { return _office->do_suspend(args); }
private int do_transfer(mixed *args) { return _office->do_transfer(args); }
private int do_unban( string person ) { return _office->do_unban(person); }
private int do_view(string person, string pattern)
{
    _office->view_record(person, pattern);
    return 1;
}
private int do_vote(mixed *args, string pattern)
{
    return _office->do_vote(args, pattern);
}
private int do_warn(mixed *args) { return _office->do_warn(args); }
private void end_memo(string text, string subject)
{
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    tell_object(this_player(),
      "Do you want to keep a copy of the memo? ");
    input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
private void end_policy_suggest(string text, string name, int type)
{
    string mgr, *managers;
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    text = replace_string(text, "\n", " ");
    text = replace_string(text, "  ", " ");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({lower_case(mgr)});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, _office->shop_very_short()+ " policy suggestion",
      "", "Please note that there is a new policy, "+ name+
      ", on which I would like you to vote.\n", 0, 0);
    _office->add_policy_suggest(name, text, mgr, type);
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k, o, k2, r, k3);
}
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
private void send_memo(string ans, string subject, string text)
{
    string *managers;
    ans = lower_case(ans);
    if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
    {
        tell_object(this_player(),
          "Do you want to keep a copy of the memo? (Yes or No)? ");
        input_to((: send_memo($1,$(subject),$(text)) :), 0);
        return;
    }
    managers = _office->get_managers();
    managers += _office->get_retired();
    if ( this_player()->query_creator() &&
      this_player()->query_name() != _office->query_creator())
        managers += ({lower_case(this_player()->query_name())});
    managers += ({_office->query_creator()});
    if ( ans[0] == 'n' )
        managers -= ({lower_case(this_player()->query_name())});
    if (!sizeof(managers))
    {
        tell_object(this_player(), "\nNo recipients!\n");
        return;
    }
    tell_object(this_player(), "\nSending your memo.\n");
    subject = (subject && subject != "")?" - "+ subject:"";
    AUTO_MAILER->auto_mail(implode(managers, ","),
      this_player()->query_name(), _office->shop_very_short()+
      " manager memo" + subject, "", text, 0, 0);
}
protected void set_long(string long_desc)
{
    long_desc += "Managers can use their own \"office\" commands "
    "from in here.  There is a management policy notice on the wall.\n";
    ::set_long( long_desc );
}
protected void set_office(string path)
{
    _office = path;
    _place = _office->query_place();
    _shop_front = _office->query_shop_front();
    _counter = _office->query_counter();
    _storeroom = _office->query_storeroom();
    _notice = clone_object(SHOP_NOTICE);
    _notice->set_office(_office);
    _notice->set_type(1);
    add_hidden_object(_notice);
}
private void write_memo(string text)
{
    this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}

==================================================
FILE: shops/player_shop/office.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
#include <board.h>
#include <money.h>
#include <move_failures.h>
#include <refresh.h>
#include "office.h"
private nosave string _proprietor = UNSET_STR,
                      _shop_name = UNSET_STR,
                      _very_short = UNSET_STR,
                      _place = UNSET_STR,
                      _channel = UNSET_STR,
                      _storeroom = "",
                      _shop_front = "",
                      _counter = "",
                      _mgr_office = "",
                      _store_dir = "",
                      _counter_dir = "",
                      _shop_dir = "",
                      _shopkeeper = "",
                      _stock_policy = "",
                      _cab_name = "",
                      _review_month = "",
                      _savedir = "",
                      _creator = CREATOR;
private nosave object _chart = 0,
                      _board = 0,
                      _notice = 0;
private nosave mapping _history = 0,
                       _applicants = 0,
                       _policies = 0,
                       _new_policies = 0,
                       _list = ([]),
                       _times = ([]),
                       _employees = ([]);
private nosave int _call_save = 0,
                   _call_hist = 0,
                   _call_hist_clear = 0,
                   _call_times = 0,
                   _call_hire_list = 0,
                   _call_mail_hirees = 0,
                   _call_summon = 0,
                   _call_emps = 0,
                   _call_review = 0,
                   _call_apps = 0,
                   _call_apps_clear = 0,
                   _call_pols = 0,
                   _call_pols_clear = 0,
                   _call_newpols = 0,
                   _call_newpols_clear = 0;
private string *_retired = ({}),
               *_got_bonus = ({}),
               _last_month = "last month",
               _eom = CREATOR;
private mapping _baddies = ([]),
                _declined = ([]),
                _accounts = (["profit":0,"bonus":0]);
private int _max_emp = MAX_EMP,
            _bonus_val = 0,
            _bonus = 0,
            _pay_val = 4,
            _num_cabinets = MIN_CABINETS,
            _net_takings = 0;
private mixed *_register = ({});
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   seteuid("Room");
   add_property("determinate", "");
   add_help_file("player_shop_office");
}
#include "office_code/admin.c"
#include "office_code/applications.c"
#include "office_code/baddies.c"
#include "office_code/cabinets.c"
#include "office_code/emp_cmd.c"
#include "office_code/lists.c"
#include "office_code/logging.c"
#include "office_code/masked.c"
#include "office_code/memo.c"
#include "office_code/personnel.c"
#include "office_code/policies.c"
#include "office_code/review.c"
#include "office_code/save.c"
#include "office_code/stock.c"
protected void add_manager_exit(string dir, string path)
{
   add_exit(dir, path, "door");
   modify_exit(dir, ({"function", ({this_object(),
     "check_manager"}), "door short", "office door", "door long",
     "There is a sign on the door which reads: \""+ _proprietor+
     "- Private\".\n"}));
   _mgr_office = path;
}
mapping get_applicants()
{
   load_applicants();
   clear_applicants();
   return copy(_applicants + ([]));
}
mapping get_baddies() { return copy(_baddies + ([])); }
string *get_employees()
{
   string *employees = m_indices(_employees);
   foreach (string word in employees)
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         employees -= ({word});
   return copy(sort_array(employees, 1));
}
string *get_managers()
{
   return copy(sort_array(keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & MANAGER :))), 1));
}
mapping get_new_policies()
{
   load_new_policies();
   clear_new_policies();
   return copy(_new_policies);
}
mapping get_policies(int type)
{
   load_policies();
   clear_policies();
   if (type)
      return copy(filter(_policies, (: _policies[$1][1] :)));
   else
      return copy(filter(_policies, (: !_policies[$1][1] :)));
}
string *get_retired() { return copy(sort_array(_retired, 1)); }
string *get_supervisors()
{
   string *supervisors = keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & SUPERVISOR :)));
   foreach (string word in supervisors)
      if (_employees[word][EMP_POINTS] & MANAGER)
         supervisors -= ({word});
   return copy(sort_array(supervisors, 1));
}
int num_employees_in()
{
   int any = 0;
   foreach (string word in m_indices(_employees))
      if (_employees[word][EMP_POINTS] & CLOCKED_IN)
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         if (!find_player(word) || !interactive(find_player(word)))
         {
            reset_employee(word, CLOCKED_IN);
            shop_log(GENERAL, word, "was clocked out", UNPAID);
         }
         else any++;
      }
   return any;
}
int query_applicant(string player)
{
   load_applicants();
   clear_applicants();
   if (!sizeof(_applicants)) return FALSE;
   if (_applicants[player]) return copy(_applicants[player][APP_TYPE]);
   return FALSE;
}
int query_baddie(string player)
{
   if (!m_sizeof(_baddies)) return FALSE;
   if (_baddies[player]) return copy(_baddies[player][BAD_TIME]);
   return FALSE;
}
int query_bonus() { return copy(_accounts["bonus"]); }
string query_channel() { return copy(_channel); }
string query_counter() { return copy(_counter); }
void query_creator(string creator) { return copy(_creator); }
int query_declined(string player)
{
   if (!sizeof(_declined)) return FALSE;
   if (_declined[player]) return copy(_declined[player]);
   return FALSE;
}
int query_employee(string player)
{
   if (_employees[player]) return copy(_employees[player][EMP_POINTS]);
   return FALSE;
}
mapping query_employees() { return copy(_employees + ([])); }
string *query_list_array() { return copy(m_indices(_list) + ({})); }
mapping query_list_mapping() { return copy(_list) + ([]); }
string query_list_string()
{
   if (!m_sizeof(_list)) return "absolutely nothing at the moment";
   return query_multiple_short(m_indices(_list));
}
int query_manager(string player)
{
   if (_employees[player]) return (_employees[player][EMP_POINTS] & MANAGER);
   return FALSE;
}
int query_maxemp() { return copy(_max_emp); }
string query_mgr_office() { return copy(_mgr_office); }
int query_num_cabinets() { return copy(_num_cabinets); }
int query_pay() { return copy(_pay_val); }
string query_place() { return copy(_place); }
int query_policy(string policy)
{
   load_policies();
   clear_policies();
   if (m_sizeof(_policies) && _policies[policy]) return 2;
   load_new_policies();
   clear_new_policies();
   if (m_sizeof(_new_policies) && _new_policies[policy]) return 1;
   return 0;
}
int query_profit() { return copy(_accounts["profit"]); }
string query_proprietor() { return copy(_proprietor); }
int query_retired(string player)
{
   return (member_array(player, _retired) == -1)?FALSE:TRUE;
}
string query_savedir() { return copy(_savedir); }
string query_shop_front() { return copy(_shop_front); }
string query_shop_name() { return copy(_shop_name); }
string query_shopkeeper() { return copy(_shopkeeper); }
int query_stock(string items) { return _storeroom->query_num_items(items, 0); }
string query_storeroom() { return copy(_storeroom); }
int query_supervisor(string player)
{
   if (_employees[player])
      return (_employees[player][EMP_POINTS] & SUPERVISOR);
   return FALSE;
}
protected void save_emps()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_emps);
   _call_emps = call_out((: do_save_emps() :), SAVE_DELAY);
}
protected void save_me()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_save);
   _call_save = call_out((: do_save() :), SAVE_DELAY);
}
protected void set_channel(string name, int board)
{
   _channel = lower_case(name);
   if (board)
   {
      _board = clone_object("/obj/misc/board");
      _board->set_datafile(name);
      _board->move(this_object());
   }
}
protected void set_counter(string path) { _counter = path; }
protected void set_creator(string creator) { _creator = creator; }
protected void set_directions(string store, string counter, string shop)
{
   _store_dir = store;
   _counter_dir = counter;
   _shop_dir = shop;
}
protected void set_place(string place) { _place = place; }
protected void set_proprietor(string name) { _proprietor = name; }
protected void set_shop_front(string path) { _shop_front = path; }
protected void set_shop_name(string name) { _shop_name = name; }
protected void set_shopkeeper(string path)
{
   _shopkeeper = path;
   path=_shopkeeper->query_name();
   if (!_employees || !_employees[path])
   {
      _employees += ([path:EMP_MAP]);
      _employees[path][EMP_POINTS] = EMPLOYEE + NPC;
   }
}
protected void set_storeroom(string path) { _storeroom = path; }
protected void set_stock_policy(string desc) { _stock_policy = desc; }
protected void set_very_short(string name)
{
   if (PLAYER_SHOP->query_shop(name) != file_name(this_object()))
      return;
   _very_short = name;
   _savedir = sprintf("/save/player_housing/%s/player_shops/%s/",
      lower_case(geteuid(this_object())), name);
   if (file_size(_savedir+ "shop_data.o") > 0)
      unguarded((: restore_object, _savedir+ "shop_data" :));
   if (file_size(_savedir+ "employees") > 0)
      _employees = restore_variable(unguarded((: read_file,
        _savedir+ "employees" :)));
   if (file_size(_savedir+ "times") > 0)
      _times = restore_variable(unguarded((: read_file,
      _savedir+ "times" :)));
   if (file_size(_savedir+ "list") > 0)
      _list = restore_variable(unguarded((: read_file, _savedir+ "list" :)));
}
string shop_very_short() { return copy(_very_short); }

==================================================
FILE: shops/player_shop/office.h
==================================================

#define clear_applicants() _call_apps_clear = \
                         call_out((: _applicants = 0 :), CLEAR_DELAY)
#define clear_history() _call_hist_clear = \
                         call_out((: _history = 0 :), CLEAR_DELAY)
#define clear_new_policies() _call_newpols_clear = \
                             call_out((: _new_policies = 0 :), CLEAR_DELAY)
#define clear_policies() _call_pols_clear = \
                         call_out((: _policies = 0 :), CLEAR_DELAY)
#define save_applicants() _call_apps = \
                          call_out((: do_save_applicants() :), SAVE_DELAY);
#define save_hist() _call_hist = \
                          call_out((: do_save_hist() :), SAVE_DELAY);
#define save_new_policies() _call_newpols = \
                          call_out((: do_save_new_policies() :), SAVE_DELAY);
#define save_policies() _call_pols = \
                          call_out((: do_save_policies() :), SAVE_DELAY);
void     add_applicant(string,string);
private void add_baddie( string, string, string);
private void add_board_message(string, string);
private void add_chart_cabinet(string, int);
private void add_declined(string);
private void add_employee(string);
protected void add_manager_exit(string, string);
private void add_policy(string);
void     add_policy_suggest(string, string, string, int);
private void add_vote(string, int);
private void adjust_bonus(string, int);
void     adjust_bought(string, int);
private void adjust_profit(string, int);
void     adjust_sold(string, int);
void     adjust_takings(int);
string   badge_list();
void     calc_bonus();
int      calc_pay();
private string cap_name(string);
void check_hire_list();
int      check_manager(string);
void     confirm_cabinet(string, int);
private void demote(string, string);
string   directions_to(string);
private int do_ban(mixed *);
private int do_bank(mixed);
int do_cancel();
private int do_chart(mixed *, string);
private int do_check();
private int do_claim(string);
private int do_clock(string);
int      do_commend(string);
private int do_confirm();
int      do_demote(string);
int      do_fire(mixed *);
int      do_leave(mixed *);
int      do_list();
int      do_logs(mixed *, string);
private int do_memo();
private int do_office();
private int do_policy_vote(string, string, string);
private int do_promote(string);
int      do_remove();
int      do_rent();
private int do_resign();
int      do_retire();
private void do_save();
private void do_save_applicants();
private void do_save_emps();
private void do_save_hist();
private void do_save_new_policies();
private void do_save_policies();
int      do_set(mixed *, string);
int      do_suspend(mixed *);
int      do_transfer(mixed *);
int      do_unban(string);
int      do_vote(mixed *, string);
int      do_warn(mixed *);
private void employee_log(string, string);
string   employees_clocked_in();
private void end_memo(string,string);
private void fire_them(string, string, string);
mapping  get_applicants();
mapping  get_baddies();
string  *get_employees();
string  *get_managers();
mapping  get_new_policies();
mapping  get_policies(int);
string  *get_retired();
string   get_stock_policy();
string  *get_supervisors();
private void hire(string);
private string list_stuff(string);
private void load_applicants();
private void load_history();
private void load_new_policies();
private void load_policies();
private void mail_hirees();
private void monthly_review();
int      num_employees_in();
private void put_on_list(string);
int      query_applicant(string);
int      query_ave(string);
int      query_baddie(string);
int      query_bonus();
int      query_buy(string);
int     *query_cabinet(string);
int      query_cabinet_used(int);
string   query_channel();
string   query_counter();
void     query_creator(string);
int      query_declined(string);
int      query_employee(string );
mapping  query_employees();
string  *query_list_array();
string   query_list_string();
int      query_manager(string);
int      query_max(string);
int      query_maxemp();
string   query_mgr_office();
int      query_num_cabinets();
int      query_on_list(string);
int      query_pay();
string   query_place();
int      query_policy(string);
int      query_profit();
string   query_proprietor();
int      query_retired(string);
int      query_sell(string);
string   query_shop_front();
string   query_shop_name();
string   query_shopkeeper();
int      query_stock(string);
string   query_storeroom();
int      query_supervisor(string);
private string query_worked(string);
private void remove_applicant(string);
private void remove_baddie(string);
private void remove_chart_cabinet(string, int);
private void remove_declined(string);
private void remove_employee(string);
private void remove_policy(string);
private void remove_retired(string);
private void reset_employee(string, int);
mixed   *restore_register();
private void review_employees();
private void rm_cab();
protected void save_emps();
private void save_list();
protected void save_me();
void     save_register(mixed *);
private void save_times();
private void send_memo(string, string, string);
private void set_buy(string, int);
protected void set_channel(string, int);
protected void set_counter(string);
protected void set_creator(string);
protected void set_directions(string, string, string);
private void set_emp_time(string);
private void set_employee(string, int);
private void set_max(string, int);
protected void set_place(string);
protected void set_proprietor(string);
private void set_sell(string, int);
protected void set_shop_front(string);
protected void set_shop_name(string);
protected void set_shopkeeper(string);
protected void set_stock_policy(string);
protected void set_storeroom(string);
protected void set_very_short(string);
void     shop_log(int, string, string, int);
string   shop_very_short();
void     summon_shopkeeper();
private void take_off_list(string);
private void update_averages();
void     view_record(string,string);
private void write_memo(string);
#define CHART_ADDITEM       "add <string'item'>"
#define CHART_REMITEM       "remove <string'item'>"
#define CHART_MAXITEM       "max <string'item'> <number>"
#define CHART_BUYITEM       "buy <string'item'> <number>"
#define CHART_SELLITEM      "sell <string'item'> <number>"
#define CHART_ASSIGN_ITEM   "assign <string'item'> <number'cabinet number'>"
#define CHART_UNASSIGN_ITEM "unassign <string'item'> <number'cabinet number'>"
#define LOG_BLANK  ""
#define LOG_NUMBER "<number>"
#define LOG_MGR    "{personnel|accounts|chart}"
#define LOG_CHART  "chart"
#define LIST_BLANK  ""
#define LIST_CHOICE "{employees|applicants|baddies}"
#define SET_EMPS "maximum <number> [employees]"
#define SET_PAY  "pay <number'amount'> <string'type'>"
#define VOTE_APPLICANT "<word'applicant'> {y|n|a}"
#define VOTE_POLICY    "policy <word'name'> {y|n}"
#define VIEW_EMP "<string'employee'>"
#define VIEW_APP "application [by] <string'applicant'>"
#define POLICY_SUGGEST "suggest {manager|shop} <word'policy'>"
#define POLICY_REMOVE  "remove <word'policy'>"
#define LIST_CABINET      "cabinet <number'cabinet'>"
#define LIST_ITEM         "<string'item'>"
#define LIST_ITEM_CABINET "<string'item'> in cabinet <number'cabinet'>"

==================================================
FILE: shops/player_shop/patterns.h
==================================================

#define CHART_ADDITEM       "add <string'item'>"
#define CHART_REMITEM       "remove <string'item'>"
#define CHART_MAXITEM       "max <string'item'> <number>"
#define CHART_BUYITEM       "buy <string'item'> <number>"
#define CHART_SELLITEM      "sell <string'item'> <number>"
#define CHART_ASSIGN_ITEM   "assign <string'item'> <number'cabinet number'>"
#define CHART_UNASSIGN_ITEM "unassign <string'item'> <number'cabinet number'>"
#define LOG_BLANK  ""
#define LOG_NUMBER "<number>"
#define LOG_MGR    "{personnel|accounts|chart}"
#define LOG_CHART  "chart"
#define LIST_BLANK  ""
#define LIST_CHOICE "{employees|applicants|baddies}"
#define SET_EMPS "maximum <number> [employees]"
#define SET_PAY  "pay <number'amount'> <string'type'>"
#define VOTE_APPLICANT "<word'applicant'> {y|n|a}"
#define VOTE_POLICY    "policy <word'name'> {y|n}"
#define VIEW_EMP "<string'employee'>"
#define VIEW_APP "application [by] <string'applicant'>"
#define POLICY_SUGGEST "suggest {manager|shop} <word'policy'>"
#define POLICY_REMOVE  "remove <word'policy'>"
#define LIST_CABINET      "cabinet <number'cabinet'>"
#define LIST_ITEM         "<string'item'>"
#define LIST_ITEM_CABINET "<string'item'> in cabinet <number'cabinet'>"

==================================================
FILE: shops/player_shop/shop_front.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
private nosave class applying_player
{
    int step;
    string *answers;
}
private nosave string _inside = "",
_outside = "",
_office = "",
_counter = "",
_storeroom = "",
_mgr_office = "",
_channel;
private void abort_app(class applying_player);
private void apply(class applying_player);
private string cap_name(string);
int check_employee(string, object, string);
private void confirm_abort(string, class applying_player);
private void confirm_apply(string, string, class applying_player);
private void continue_loop(class applying_player);
string directions_to(string);
private int do_apply();
private int do_cancel();
private int do_complain();
private int do_confirm();
private int do_push();
private int do_suggestion();
private void end_app(class applying_player);
private void end_complaint(string);
private void end_suggestion(string);
private void finish_edit(string, class applying_player);
string query_office();
string query_outside();
protected void set_exit_counter(string);
protected void set_exit_out(string, string);
protected void set_office(string);
string sign_text();
int tinkle_bell(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("no burial", 1);
    add_property("los", "closed");
    add_property("determinate", "");
    add_item("counter", "The counter divides this room of the shop in two.  "
      "You get the feeling that only employees can pass it.  There's a "
      "%^BOLD%^card%^RESET%^ on the counter that catches your attention, "
      "next to which is a small %^BOLD%^bell%^RESET%^.");
    add_item("card", "The card seems to be a simple form.  One section "
      "seems to allow you to \"apply\" for a job here, whilst the "
      "bottom section could be filled out to make a \"suggestion\".\n"
      "If you wish to \"complain\" about an employee, you may do so here.  "
      "If you have been accepted for employment, you can also \"confirm\" "
      "you accept, or you can \"cancel\" your application at any time.");
    add_item("doorbell", "The bell above the door is positioned so that as the "
      "door passes underneath it, it will ring.");
    add_item(({"bell", "push-bell"}),
      ({"long", "This is a small push-bell for summoning the employees.",
        "push", (: do_push() :)}));
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_shopfront");
}
void init()
{
    string tp;
    ::init();
    if (!_office || _office == "") return;
    tp = this_player()->query_name();
    _office->summon_shopkeeper();
    add_command("complain", "", (: do_complain() :));
    add_command("suggestion", "", (: do_suggestion() :));
    if (!check_employee("void", this_player(), "void"))
        add_command("apply", "", (: do_apply() :));
    if ( _office->query_applicant(tp) == HIRED)
        add_command("confirm", "employment", (: do_confirm() :));
    if (_office->query_applicant(tp))
        add_command( "cancel", "application", (: do_cancel() :) );
}
private void abort_app(class applying_player player_info)
{
    tell_object(this_player(),
      "Are you sure you want to ABORT the application? ");
    input_to((: confirm_abort($1,$(player_info)) :), 0);
}
private void apply(class applying_player player_info)
{
    object tp = this_player();
    tell_object(tp, "\n\n");
    tell_object(tp, "%^BOLD%^Application for employment with "+
      _office->query_shop_name()+ "%^RESET%^\n\n"
      "Please note that a blank entry will abort your application.\n");
    tell_object(tp, "There are " + query_num(sizeof(APP_QUESTIONS))+
      " questions on this application form.  Please answer them all.  "
      "You will get an opportunity at the end to let us know anything "
      "else about you that seems relevant.\n\n" );
    continue_loop(player_info);
}
private string cap_name(string name)
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}
int check_employee(string verb, object thing, string special)
{
    if (thing->query_creator() ||
      _office->query_retired(thing->query_name())) return 1;
    return _office->query_employee(thing->query_name());
}
private void confirm_abort(string confirm, class applying_player player_info)
{
    confirm = lower_case(confirm);
    if (strlen(confirm) < 1 || (confirm[0] != 'y' && confirm[0] != 'n'))
    {
        tell_object(this_player(), "Please enter 'yes' or 'no'.\n"
          "Are you sure you want to ABORT the application? ");
        input_to((: confirm_abort($1,$(player_info)) :), 0);
        return ;
    }
    if (confirm[0..0] != "y")
    {
        continue_loop(player_info);
        return ;
    }
    tell_object(this_player(), "Application aborted.\n");
    return;
}
private void confirm_apply(string str, string message,
  class applying_player player_info)
{
    string from, *managers;
    str = lower_case( str );
    if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'n'))
    {
        tell_object(this_player(), "Are you sure you want to send "
          "the application (Yes or No)? ");
        input_to((: confirm_apply($1,$(message),$(player_info)) :), 0);
        return;
    }
    if(str[0] == 'n')
    {
        confirm_abort("y", player_info);
        return;
    }
    from = (string)this_player()->query_name();
    managers = _office->get_managers();
    if (!sizeof(managers)) managers = ({ _office->query_creator() });
    AUTO_MAILER->auto_mail(implode(managers, ","),
      _office->query_proprietor(), "Application for employment with "+
      _office->shop_very_short(), "", "There is a new application to be "
      "viewed.\nPlease vote on "+ cap_name( from )+ "'s application as "
      "soon as possible.\n", 0, 0);
    _office->add_applicant(from, message);
    tell_object(this_player(), "\nYour application has now been sent "
      "to the managers.  You will hear from us as soon as they have "
      "made a decision.  Thank you for your application, and good luck.\n");
}
private void continue_loop(class applying_player player_info)
{
    string q_str = "Question #"+(player_info->step+1)+": ";
    tell_object(this_player(), "\n%^CYAN%^" + sprintf("%s%-=*s\n",
        q_str, this_player()->query_cols() - strlen(q_str),
        APP_QUESTIONS[player_info->step]) + "%^RESET%^");
    this_player()->do_edit("", (: finish_edit($1,$(player_info)) :), 0);
}
string directions_to(string place)
{
    if (place == _counter || place == _office || place == _storeroom)
        return copy(_inside);
    return "here";
}
private int do_apply()
{
    int awaiting_vacancies = 0;
    mapping applicants;
    string tp = this_player()->query_name();
    class applying_player player_info;
    if (_office->query_applicant(tp))
    {
        tell_object(this_player(), "You've already applied here!\n");
        return 1;
    }
    if (_office->query_declined(tp))
    {
        tell_object(this_player(), "I'm sorry, but you cannot make another "
          "application just yet.\n");
        return 1;
    }
    applicants = _office->get_applicants();
    foreach (string applicant in m_indices(applicants))
    if (applicants[applicant][APP_TYPE] == AWAITING)
        awaiting_vacancies++;
    if ((awaiting_vacancies > (_office->query_maxemp() / 10)))
    {
        tell_object(this_player(), "I'm sorry, but we do not have any "
          "vacancies at the moment.  Please try again at a later date.\n");
        return 1;
    }
    player_info = new(class applying_player);
    player_info->step = 0;
    player_info->answers = ({});
    call_out((: apply($(player_info)) :), 0);
    add_succeeded_mess("");
    return 1;
}
private int do_cancel() { return _office->do_cancel(); }
private int do_complain()
{
    tell_object(this_player(), COMPLAINT_TEXT +
      "  This complaint will then be sent to the managers of the shop.  "
      "If you would rather remain anonymous to the managers, please "
      "contact a liaison, or send a mail with all the above details to "+
      cap_name(_office->query_creator())+ ".\n");
    this_player()->do_edit("%^CYAN%^"+ COMPLAINT_TEXT + "%^RESET%^\n\n",
      (: end_complaint($1) :));
    add_succeeded_mess("");
    return 1;
}
private int do_confirm() { return _office->do_confirm(); }
private int do_push()
{
    if (this_player()->query_property("shop bell pressed"))
        return notify_fail( "Calm down!  You've only just pushed it.  Try "
          "in a minute or so if there's still no reply.\n" );
    if (check_employee("void", this_player(), "void"))
        return notify_fail("There's already an employee here: You!\n");
    if (!_channel || _channel == "")
        return notify_fail( "You push the bell, but no-one can hear you.\n" );
    this_player()->add_property("shop bell pressed", 1, BELL_TIMEOUT);
    HISTORY_HANDLER->add_chat_history(_channel, "Shop: ", this_player()->
      query_short() + " called for assistance.");
    children(BADGE)->receive(_channel, "Shop", this_player()->query_short()+
      " is calling for assistance.");
    add_succeeded_mess("$N $V the bell.\n");
    return 1;
}
private int do_suggestion()
{
    tell_object(this_player(), SUGGEST_TEXT+ "\n");
    this_player()->do_edit("%^CYAN%^"+ SUGGEST_TEXT+ "%^RESET%^\n",
      (: end_suggestion($1) :));
    add_succeeded_mess("");
    return 1;
}
private void end_app(class applying_player player_info)
{
    string message = "";
    for (int i = 0; i < sizeof(APP_QUESTIONS); i++)
    {
        message += "%^CYAN%^" + sprintf("%2d) %-=*s\n", (i+1), 70,
          APP_QUESTIONS[i]) + "%^RESET%^" +
        sprintf("      %-=*s\n\n", 72, player_info->answers[i]);
    }
    tell_object(this_player(), "We have your application as:\n" + message+
      "\nDo you wish to send it? ");
    input_to((: confirm_apply($1,$(message),$(player_info)) :), 0);
}
private void end_complaint(string text)
{
    string *managers;
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    if (!sizeof(managers = _office->get_managers()))
        managers = ({_office->query_creator()});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      this_player()->query_name(), _office->shop_very_short()+ " complaint",
      "", text, 0, 0);
    tell_object(this_player(), "Your complaint has now been sent to the "
      "managers, and will be dealt with as soon as possible.\n");
}
private void end_suggestion(string text)
{
    string *managers;
    if (!text)
    {
        tell_object( this_player(), "Aborted.\n" );
        return;
    }
    if (!sizeof(managers = _office->get_managers()))
        managers = ({_office->query_creator()});
    AUTO_MAILER->auto_mail( implode( managers, "," ),
      this_player()->query_name(), _office->shop_very_short()+ " suggestion",
      "", text, 0, 0 );
    tell_object(this_player(), "Your suggestion has been sent to the "
      "managers, and will be dealt with as soon as possible.\n");
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k,o,k2,r,k3);
}
void event_enter(object ob, string message, object from)
{
    mapping baddies;
    int days;
    string name = ob->query_name();
    if (_office->query_baddie(name))
    {
        baddies = _office->get_baddies();
        days = (((BAN_LENGTH*60*60*24) -
            (time() - baddies[name][2])) / (60*60*24)) + 1;
        tell_room(this_object(), ob->query_short()+
          " drifts out of the door, seemingly against "+
          ob->query_possessive()+ " will.\n", ({ob}));
        tell_object(ob, "You feel yourself pushed out of the shop by "
          "a mysterious force.\nYou have been banned from this shop for "+
          baddies[name][0]+ " and will not be re-admitted for a maximum of "+
          query_num(days)+ " days.\n");
        ob->move(_outside);
    }
}
string long(string word, int dark)
{
    int emps_in = 0;
    if (find_object(_office->query_shopkeeper()) &&
      _office->query_employee(_office->query_shopkeeper()->
        query_name()) & CLOCKED_IN)
    {
        emps_in = 1;
    }
    emps_in += _office->num_employees_in();
    return sprintf("%s%s %s currently clocked in.\n",
      ::long(word,dark), _office->employees_clocked_in(),
      (emps_in == 1)? "is" : "are");
}
private void finish_edit(string message, class applying_player player_info)
{
    if (!message || message == "")
    {
        abort_app(player_info);
        return;
    }
    player_info->answers += ({message});
    player_info->step++;
    if (player_info->step == sizeof(APP_QUESTIONS)) end_app(player_info);
    else continue_loop(player_info);
}
string query_office() { return copy(_office); }
string query_outside() { return copy(_outside); }
protected void set_exit_counter(string direction)
{
    _inside = direction;
    add_exit(direction, _counter, "hidden");
    modify_exit(direction, ({"function", "check_employee"}));
}
protected void set_exit_out(string direction, string path)
{
    _outside = path;
    add_exit(direction, path, "door");
    modify_exit(direction, ({"open/close func", ({this_object(),
          "tinkle_bell"})}));
}
protected void set_office(string path)
{
    _office = path;
    _counter = path->query_counter();
    _mgr_office = path->query_mgr_office();
    _storeroom = path->query_storeroom();
    _channel = path->query_channel();
    set_short( path->query_shop_name() );
    add_sign("A small golden plaque with engraved text.\n",
      (: sign_text :), "small plaque", "plaque",
      "common")->add_property("there", "on one wall");
}
string sign_text()
{
    string *eom = _office->query_eom();
    return sprintf("\n%%^YELLOW%%^  Employee Of The Month for %s : %s%%^RESET%%^\n\n",
       eom[0], cap_name(eom[1]));
}
int tinkle_bell(string action)
{
    tell_room(this_object(), "The bell tinkles as the door "+
      action+ "s.\n");
    tell_room(find_object(_counter), "The bell over the shop door "
      "tinkles.\n");
    tell_room(find_object(_office), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    tell_room(find_object(_storeroom), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    tell_room(find_object(_mgr_office), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    return 1;
}

==================================================
FILE: shops/player_shop/shopkeeper.c
==================================================

inherit "/obj/monster";
#include <player_shop.h>
#include <money.h>
#include <living.h>
#include <move_failures.h>
#define set_busy(O) (_busy = O)
#define reset_busy() (_busy = 0)
#define NOT_EIGHT (({ "between seven and nine", \
                     "just over seven", \
                     "just under nine", \
                     "seven plus one", \
                     "nine minus one", \
                     "two times four", \
                  })[random(5)])
#define num_str(i) ((i == 8)?NOT_EIGHT:query_num(i))
#define DEARIE (", "+ _dearie[random(sizeof(_dearie)-1)])
private nosave object _busy = 0;
private nosave mixed _info = 0;
private nosave string _office = "",
_storeroom = "",
_shop_front = "",
_counter = "",
_place = "",
_smallest_in,
_smallest_plural_in,
*_dearie = ({""});
private nosave int * _work_hrs = ({9,0,17,30,}),
_smallest_value_in,
_failed = 0;
private nosave mapping _values_sing = ([]),
_values_plural = ([]);
private void announce_number();
private void announce_price();
private void buy_something(object *);
private void check_money(mixed);
private void deposit_money();
int do_buy(string);
int do_browse(string);
int do_list(mixed  *);
int do_sell(object *);
private void end_shift();
private void get_from_store();
private void get_money();
private void get_more_stuff();
private void give_stuff();
private void how_many(string);
private void how_much(string);
private void look_chart();
private void look_how_much();
private void no_coins();
private int outside_hours(int);
private void put_in_store();
private int query_busy();
string query_office();
private void say_to_room(object, string, string);
private void sell_something(string);
protected object * item_test(object *);
protected void set_dearie(string *);
void set_failed(int);
protected void set_office(string);
protected void set_work_hours(int *);
void shuffle_to(string,function);
private int sort_keys(string, string, int);
void start_shift();
private void taken_over();
private void what_items();
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    add_property("unique", 1);
    add_property("run away", -1);
    add_alias("shopkeeper");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
}
private void announce_number()
{
    if (stringp(_info))
    {
        int number = _storeroom->query_num_items(_info);
        if (!number) do_command("'I'm afraid we don't have any "+ _info +
              " in stock"+ DEARIE+ ".");
        else do_command("'You're in luck"+ DEARIE+ ".  We have "+
              num_str(number) + " in stock.");
    }
    reset_busy();
    _info = 0;
}
private void announce_price()
{
    if (stringp(_info))
        do_command("'We sell "+ _info + " for "+
          num_str(_office->query_sell(_info))+ " "+ _smallest_plural_in+
          " each, and buy them for "+ num_str(_office->query_buy(_info))+
          " "+ _smallest_plural_in + " each.");
    reset_busy();
    _info = 0;
}
void attack_by(object baddie)
{
    if (_office == "") return;
    this_object()->stop_fight(baddie);
    baddie->stop_fight(this_object());
    do_command("'Why are you attacking me, "+ baddie->query_cap_name()+ "?");
    do_command("'I'm not staying here for this!");
    do_command(_office->query_channel()+ "@ is being attacked by "+
      baddie->query_cap_name()+ ".");
    call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
    _office->event_death(this_object(), 0, baddie, 0, 0);
#ifdef DEBUG
    tell_creator(CREATOR,  "Attacked by %s.\n", baddie->query_short());
#endif
}
private void buy_something(object *obs)
{
    int spare, number, amount = 0;
    object *give_back, cont = clone_object("/std/container");
    obs->move(cont);
    _info = ({});
    foreach(string item in _office->query_list_array())
    _info += ((class obj_match)match_objects_in_environments(item, cont))->objects;
    give_back = obs - _info;
    if (sizeof(give_back))
    {
        give_back->move(_busy);
        do_command("'I'm afraid I can't buy "+
          query_multiple_short(give_back)+ " from you"+ DEARIE+ ".");
    }
    if (number = sizeof(_info))
    {
        if (_info[0]->query_collective())
            number = _info[0]->query_amount();
    }
    if (number > (MAX_INVEN + query_dex()))
    {
        _info->move(_busy);
        do_command("'I'm sorry"+ DEARIE+ ", but I can only carry "+
          num_str(MAX_INVEN+ query_dex())+ " items.");
        cont->dest_me();
        reset_busy();
        return;
    }
    give_back = ({});
    give_back = filter(_info, (: ($1)->query_continuous() :));
    if (sizeof(give_back))
    {
        _info -= give_back;
        do_command("'I have nothing to carry "+
          query_multiple_short(give_back)+ " in.");
        give_back->move(_busy);
    }
    give_back = item_test(_info);
    if (sizeof(give_back))
    {
        give_back->move(_busy);
        _info -= give_back;
    }
    if (!(number = sizeof(_info)))
    {
        do_command("'You don't have anything to sell"+ DEARIE+ ".");
        cont->dest_me();
        reset_busy();
        return;
    }
    if (_info[0]->query_collective())
        number = _info[0]->query_amount();
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking stock.\n");
#endif
    spare = _office->query_max(pluralize(_info[0]->query_name())) -
    _office->query_stock(pluralize(_info[0]->query_name()));
    if (spare < 1)
        foreach(string alias in _info[0]->query_alias())
    {
        int check_spare;
        if((check_spare = _office->query_max(pluralize(alias)) -
            _office->query_stock(pluralize(alias))) > 0)
            spare = check_spare;
    }
    if (spare < 1)
        spare = _office->query_max(pluralize(_info[0]->query_short())) -
        _office->query_stock(pluralize(_info[0]->query_short()));
    if (spare < 1)
    {
        do_command("'I'm afraid we don't need any of those"+ DEARIE+ ".");
        _info->move(_busy);
        cont->dest_me();
        reset_busy();
        return;
    }
    if (number > spare)
    {
        do_command("'I'm afraid we don't need that many"+ DEARIE+
          ", but I could take "+ num_str(spare)+ " from you.");
        _info->move(_busy);
        cont->dest_me();
        reset_busy();
        return;
    }
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking money.\n");
#endif
    foreach(string item in _office->query_list_array())
    {
obs = ((class obj_match)match_objects_in_environments(item, this_object()))->objects;
        if (number = sizeof(obs))
        {
            if (obs[0]->query_collective())
                number = obs[0]->query_amount();
            amount += _office->query_buy(item) * number;
        }
        if (_counter->query_register() < amount * _smallest_value_in)
        {
            do_command("'I'm afraid we don't have enough money to buy "+
              query_multiple_short(_info) + " from you" + DEARIE+ ".");
            _info->move(_busy);
            cont->dest_me();
            reset_busy();
            return;
        }
    }
    give_back = ({});
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking we can carry it.\n");
#endif
    if (sizeof(_info))
    {
        obs = _info;
        foreach(object thing in obs)
        if ((int)thing->move(this_object()) != MOVE_OK)
        {
#ifdef DEBUG
            tell_creator(CREATOR,  "Can't carry %O.\n", thing);
#endif            _info -= ({ thing });
            give_back += ({ thing });
        }
        tell_room(environment(this_object()), query_short()+
          " takes "+ query_multiple_short(_info) +".\n");
    }
    obs = all_inventory(cont) - give_back;
    if (sizeof(give_back))
    {
        do_command("'I cannot carry "+ query_multiple_short(give_back, "the")
          +DEARIE+".");
        give_back->move(_busy);
    }
    if (sizeof(obs))
    {
        do_command("'I'm afraid we can't buy "+
          query_multiple_short(obs, "the") +" from you"+ DEARIE+ ".");
        obs->move(_busy);
    }
    obs = all_inventory(cont);
    if (sizeof(obs)) obs->move(environment(_busy),
          "$N manage$s to get knocked onto the floor.");
    if (sizeof(_info))
    {
#ifdef DEBUG
        tell_creator(CREATOR,  "Buying: %O\n", _info);
#endif
        do_command("'I'll be right back.");
        call_out("shuffle_to", NPC_DELAY, _counter, (: get_money() :));
    }
    else reset_busy();
    cont->dest_me();
}
private void check_money(mixed monies)
{
#ifdef DEBUG
    tell_creator(CREATOR, "Buying %d %s for %d each - total %d.\n", monies[1],
      monies[2], monies[3], monies[0] );
#endif
    if (monies[0] > query_value_in(_place))
    {
#ifdef DEBUG
        tell_creator(CREATOR, "No correct change (%d).\n", query_value_in(_place));
#endif
        do_command("put coins in register");
        call_out("shuffle_to", NPC_DELAY, _shop_front, (: no_coins() :));
        return;
    }
    do_command("log shop bought "+ monies[1] +" "+ monies[2] +
      " for "+ (monies[3] * monies[1]));
#ifdef DEBUG
    tell_creator(CREATOR, "Total: %d   My value: %d\n", monies[0],
      query_value_in( _place ) );
#endif
    call_out("shuffle_to", NPC_DELAY, _storeroom, (: put_in_store() :));
}
private void deposit_money()
{
    if (pointerp(_info))
    {
        do_command("log shop sold "+ _info[1]+ " "+ _info[0]+ " for "+
          _info[2]);
        do_command("put coins in register");
    }
    call_out("shuffle_to", NPC_DELAY, _storeroom, (: get_from_store() :));
}
int do_buy(string stuff)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_buy()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "say", "I would like to buy "+ stuff +
      ", please.\n%^RESET%^");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: sell_something($(stuff)) :), NPC_DELAY);
    }
    return 1;
}
int do_browse(string item)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_browse()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "ask", "How much do "+ item +" cost?\n");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: how_much($(item)) :), NPC_DELAY);
    }
    return 1;
}
int do_list(mixed *args)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_list()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    if (!sizeof(args) || !args[0] || args[0] == "")
    {
        say_to_room( this_player(), "ask", "What items do you buy and sell?\n");
        if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY);
        else
        {
            set_busy(this_player());
            call_out((: what_items() :), NPC_DELAY);
        }
        return 1;
    }
    say_to_room(this_player(), "ask", "How many "+ args[0]+ " do you have?\n");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: how_many($(args[0])) :), NPC_DELAY);
    }
    return 1;
}
int do_sell(object *obs)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_sell()\n" );
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "say", "I would like to sell " +
      query_multiple_short(obs, "the")+ ", please.\n%^RESET%^");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: buy_something($(obs)) :), NPC_DELAY);
    }
    return 1;
}
private void end_shift()
{
    if (environment() != find_object("/room/rubbish"))
        do_command(_office->query_channel()+ "@ is clocking out.");
    do_command("clock out");
    move("/room/rubbish", "$N make$s some tea.", "$N go$s home for tea.");
}
void event_person_say(object thing, string start, string mess, string lang)
{
    string words;
#ifdef DEBUG
    tell_creator(CREATOR,  "In event_person_say()\n" );
#endif
    if (outside_hours(TRUE)) return;
    if (!mess || (mess == "")) return;
    mess = lower_case(mess);
    if (query_busy()) return;
    set_busy(thing);
    if (sscanf(mess, "%*s buy %s, please.", words) == 2)
    {
        call_out((: sell_something($(words)) :), NPC_DELAY);
        return;
    }
    if (sscanf(mess, "%*show many %s", words) == 2)
    {
        call_out((: how_many($(words)) :), NPC_DELAY);
        return;
    }
    if (sscanf(mess, "%*show much %s", words) == 2)
    {
        call_out((: how_much($(words)) :), NPC_DELAY);
        return;
    }
    if (( sscanf( mess, "%*s take over%*s") == 2) &&
      (_office->query_employee(thing->query_name()) ||
        thing->query_name() == CREATOR))
    {
        call_out((: taken_over() :), NPC_DELAY);
        return;
    }
    reset_busy();
    ::event_person_say(thing, start, mess, lang);
}
private void get_from_store()
{
    if (pointerp(_info))
    {
        int number, bag_item_weight, info1 = to_int(_info[1]);
        object *inven;
        _failed = 0;
        if (info1 > (MAX_INVEN + query_dex())) number = MAX_INVEN + query_dex();
        else number = info1;
#ifdef DEBUG
        tell_creator(CREATOR, "Removing %d %s\n", number, _info[0]);
#endif
        inven = all_inventory();
        do_command("remove " + number+ " "+ _info[0]);
        if (_failed)
        {
            do_command("add "+ _failed+ " "+ _info[0]);
            do_command("get "+ _info[0]);
        }
        inven = all_inventory() - inven;
        number -= _failed;
        info1 -= number;
        foreach(object thing in inven)
        if (thing->query_weight() < MAX_BAG_WEIGHT/5)
            bag_item_weight += thing->query_weight();
        bag_item_weight = (MAX_BAG_WEIGHT+bag_item_weight-1)/MAX_BAG_WEIGHT;
        if ( number > 9 )
        {
            number = (((number+9)/10) > bag_item_weight)?
            (number+9)/10:bag_item_weight;
            for(int i=0; i < number; i++) do_command("pull roll");
            for(int i=0; i < number; i++)
                do_command("put "+ _info[0]+ " in bag "+ (i+1));
        }
        if (info1)
        {
            _info[1] = sprintf("%d",info1);
            call_out("shuffle_to", NPC_DELAY, _shop_front,
              (: get_more_stuff() :));
            return;
        }
    }
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: give_stuff() :));
}
private void get_money()
{
    if (pointerp(_info))
    {
        int total;
        mixed monies = ({0,0,0,0,});
        string *sort_keys_sing = sort_array(keys(_values_sing),
          (: sort_keys($1,$2,1) :));
        string *sort_keys_plural = sort_array(keys(_values_plural),
          (: sort_keys($1,$2,0) :));
#ifdef DEBUG
        tell_creator(CREATOR, "Singular: %O\n", sort_keys_sing);
        tell_creator(CREATOR, "Plural: %O\n", sort_keys_plural);
#endif
        foreach(string item in _office->query_list_array())
        {
            object *things = ((class obj_match)match_objects_in_environments(item,
              this_object()))->objects;
#ifdef DEBUG
            tell_creator(CREATOR, "We have %d %s\n", sizeof(things), item);
#endif
            if (monies[1] = sizeof(things))
            {
                if (things[0]->query_collective())
                    monies[1] = things[0]->query_amount();
                monies[3] = _office->query_buy(item);
                do_command( "'"+ capitalize(item) +" are worth "+
                  num_str(monies[3]) +" "+ _smallest_plural_in +
                  " each, and I have "+ num_str(monies[1]) + ".");
                monies[0] += monies[3] * monies[1];
                monies[2] = item;
                break;
            }
        }
        monies[0] *= _smallest_value_in;
        total = monies[0];
        for (int i=0; i < sizeof(sort_keys_sing); i++)
        {
            if (total < _values_sing[sort_keys_sing[i]]) continue;
            for (int c = total / _values_sing[sort_keys_sing[i]]; c > 0; c--)
            {
                string coins = sprintf("%d %s", c,
                  (c == 1)?sort_keys_sing[i]:sort_keys_plural[i]);
#ifdef DEBUG
                tell_creator(CREATOR, "Trying to get %s\n", coins);
#endif
                do_command("get "+ coins+ " from register");
                if (sizeof(match_objects_for_existence(coins, this_object())))
                {
                    total -= (c * _values_sing[sort_keys_sing[i]]);
#ifdef DEBUG
                    tell_creator(CREATOR, "New total: %d\n", total);
#endif
                    break;
                }
            }
        }
#ifdef DEBUG
        tell_creator(CREATOR, "Buying %d %s for %d each.\n", monies[1],
          monies[2], monies[3]);
#endif
        call_out((: check_money($(monies)) :), 1);
    }
    else
        call_out("shuffle_to", NPC_DELAY, _storeroom, (: put_in_store() :));
}
private void get_more_stuff()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("drop all");
        do_command("'I still need to get you "+ num_str(to_int(_info[1]))+ " "+
          _info[0]+ DEARIE+ ".  I won't be long.");
        call_out( "shuffle_to", NPC_DELAY, _storeroom,
          (: get_from_store() :) );
        return;
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
private void give_stuff()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("'Thank you for your custom" + DEARIE+ ".");
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
private void how_many(string item)
{
    _info = 0;
    foreach (string thing in _office->query_list_array())
    if (sscanf(item, "%*s"+ thing +"%*s") == 2) _info = item;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those" + DEARIE+ ".");
        reset_busy();
        return;
    }
    do_command("'"+ capitalize( _info ) +"?  I'll just go and see.");
    call_out("shuffle_to", NPC_DELAY, _office, (: look_chart() :));
}
private void how_much(string item)
{
    _info = 0;
    foreach (string thing in _office->query_list_array())
    if (sscanf(item, "%*s"+ thing +"%*s") == 2) _info = thing;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those"+ DEARIE+ ".");
        reset_busy();
        return;
    }
    do_command("'"+ capitalize( _info ) +"?  I'll just go and see.");
    call_out("shuffle_to", NPC_DELAY, _office, (: look_how_much() :));
}
void init()
{
    object tp = this_player();
#ifdef DEBUG
    tell_creator(CREATOR,  "In init()\n" );
#endif
    if (environment(this_object()) == find_object("/room/rubbish")) return;
#ifdef DEBUG
    tell_creator(CREATOR,  "Not in /room/rubbish\n");
#endif
    ::init();
    tp->add_command("buy", this_object(), "<string'item(s)'>",
      (: do_buy($4[0]) :));
    tp->add_command("sell", this_object(), "<indirect:object:me>",
      (: do_sell($1) :));
    tp->add_command("list", this_object(), ({"", "<string'item(s)'>"}),
      (: do_list($4) :));
    tp->add_command("browse", this_object(), "<string'item(s)'>",
      (: do_browse($4[0]) :));
    outside_hours(TRUE);
}
private void look_chart()
{
    if (stringp(_info)) do_command("'Now, let me see, "+ _info +"...");
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: announce_number() :));
}
private void look_how_much()
{
    if (stringp(_info)) do_command("'Now, let me see, "+ _info +"...");
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: announce_price() :));
}
private void no_coins()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("'I'm sorry" + DEARIE+ ".  I don't have the correct "
          "change to give you.  Please call again later.");
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
private int outside_hours(int working)
{
    int hrs, mins;
    string am_pm;
    if (query_busy())
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Outside working hours but already busy.  "
          "Continuing.\n");
#endif
        return FALSE;
    }
    if (sscanf(amtime(time()), "%d:%d%s,%*s", hrs, mins, am_pm) == 4)
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Time is %02d:%02d%s.\n", hrs, mins, am_pm);
#endif
        if (am_pm == "am")
        {
            if (hrs == 12) hrs = 0;
        }
        else
        if (hrs != 12) hrs += 12;
#ifdef DEBUG
        tell_creator(CREATOR, "Which is %02d:%02d.\n", hrs, mins);
#endif
        if ((hrs < _work_hrs[0] ||
            (hrs == _work_hrs[0] && mins < _work_hrs[1])) ||
          (hrs > _work_hrs[2] ||
            (hrs == _work_hrs[2] && mins > _work_hrs[3])))
        {
            if (!working)
            {
#ifdef DEBUG
                tell_creator(CREATOR, "Outside working hours & not "
                  "working.  Sending to /room/rubbish.\n");
#endif
                move("/room/rubbish");
                return TRUE;
            }
#ifdef DEBUG
            tell_creator(CREATOR, "Outside working hours & working.  "
              "Sending home now.\n");
#endif
            call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
            return TRUE;
        }
    }
    return FALSE;
}
private void put_in_store()
{
    if (pointerp(_info)) do_command("add all");
    do_command("drop all");
    foreach (string value in keys(_values_sing))
    do_command("get every "+ value);
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: give_stuff() :));
}
private int query_busy()
{
    if (!objectp(_busy) || !interactive(_busy) || _busy->query_invis())
        return 0;
    if (environment(_busy) != find_object(_shop_front)) return 0;
    return (_busy != 0);
}
string query_office() { return copy(_office); }
private void say_to_room(object me, string t, string message)
{
    tell_object(me, "You "+ t+ ": "+ message);
    foreach(object player in all_inventory(environment(this_object())))
    if (interactive(player) && player != me)
        tell_object(player, player->colour_event("say", "%^CYAN%^")+
          me->query_short()+ " "+ t + "s: "+ message);
}
private void sell_something(string items)
{
    int each, number, in_stock;
    mixed *money_array;
    _info = 0;
    foreach (string item in _office->query_list_array())
    if (sscanf(items, "%*s"+ item +"%*s") == 2) _info = item;
    else if (sscanf(pluralize(items), "%*s"+ item +"%*s") == 2)
        _info = item;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those"+ DEARIE+ ".");
        reset_busy();
        return;
    }
    if (sscanf(items, "%*s%d "+ _info +"%*s", number) != 3) number = 1;
#ifdef DEBUG
    tell_creator(CREATOR, "Customer asked for %d %s.\n", number, _info);
#endif
    if (number > (in_stock = _storeroom->query_num_items(_info)))
    {
        if (!in_stock)
        {
            do_command("'I'm afraid we don't have any "+ _info+ " in stock"+
              DEARIE+ ".");
            reset_busy();
            return;
        }
        do_command("'I'm afraid we don't have that many "+ _info +
          " in stock, but I can sell you "+ num_str(in_stock)+ ".");
        reset_busy();
        return;
    }
    if (number < 1)
    {
        do_command("'My, my.  You are amusing aren't you" + DEARIE+ "?");
        do_command("peer "+ _busy->query_name());
        reset_busy();
        return;
    }
    each = _office->query_sell(_info);
    do_command( "'"+ capitalize(_info) +" are worth "+
      num_str(each) +" "+ _smallest_plural_in + " each, and you want "+
      num_str(number) + ".");
    each *= number;
    if (_busy->query_value_in(_place) < (each * _smallest_value_in))
    {
        do_command("'I'm afraid you don't have enough money" + DEARIE+ ".");
        reset_busy();
        return;
    }
    money_array = MONEY_HAND->create_money_array(each * _smallest_value_in,
      _place);
    _busy->pay_money(money_array, _place);
    adjust_money(money_array);
#ifdef DEBUG
    tell_creator(CREATOR, "Monies adjusted by %O.\n", money_array);
#endif
    tell_room( environment( this_object() ), query_short()+
      " takes the money.\n" );
    do_command("'I'll be right back"+ DEARIE+ ".");
    _info = ({ _info, sprintf("%d", number), sprintf("%d", each) });
#ifdef DEBUG
    tell_creator(CREATOR,  "Selling: %O\n", _info);
#endif
    call_out("shuffle_to", NPC_DELAY, _counter, (: deposit_money() :));
}
protected object * item_test(mixed * items) { return ({}); }
protected void set_dearie(string *dearie) { _dearie = dearie; }
void set_failed(int failed) { _failed = failed; }
protected void set_office(string path)
{
    mapping values;
    string new_key;
    _office = path;
    _place = _office->query_place();
    _smallest_in = MONEY_HAND->smallest_in( _place );
    _smallest_value_in = MONEY_HAND->smallest_value_in(_place);
    _smallest_plural_in = MONEY_HAND->query_plural_for(_smallest_in);
    values = MONEY_HAND->query_mapped_values_in(_place);
    foreach(string key in keys(values))
    {
        new_key = MONEY_HAND->query_aliases_for(key)[0];
        _values_sing += ([new_key:values[key]]);
    new_key = MONEY_HAND->query_details_for(key)[5];
    _values_plural += ([new_key:values[key]]);
}
#ifdef DEBUG
tell_creator(CREATOR, "Singular values: %O.\n", _values_sing);
tell_creator(CREATOR, "Plural values: %O.\n", _values_plural);
#endif
_storeroom = _office->query_storeroom();
_counter = _office->query_counter();
_shop_front = _office->query_shop_front();
add_respond_to_with(({ "@say", "hello" }), "'Hello, $hcname$.  What can I do for you?");
add_respond_to_with(({ "@smile", query_name() }), "smile at $hname$");
}
protected void set_work_hours(int *hours) { _work_hrs = hours; }
void shuffle_to(string location, function next_action)
{
    string direc = environment()->directions_to(location);
    if (!direc)
    {
        if (environment() == find_object("/room/rubbish")) return;
        if (environment() == _shop_front->query_outside())
        {
            move(_shop_front, "$N enter$s the shop.",
              "$N enter$s _shop_front->query_short().");
        }
        else
        {
            do_command("'I seem to be lost...");
            do_command("sob");
            move(_office, "$N runs in, sobbing.", "$N leave$s, sobbing.");
            end_shift();
            return;
        }
        call_out("shuffle_to", NPC_DELAY, location, next_action);
        return;
    }
    if (direc == "here")
    {
        do_command("smile brightly");
        do_command("'Here we are.");
        if (next_action) call_out(next_action, NPC_DELAY);
        else reset_busy();
        return;
    }
    do_command(direc);
    call_out("shuffle_to", NPC_DELAY, location, next_action);
}
private int sort_keys(string s1, string s2, int sing)
{
    if (sing) return (_values_sing[s1] < _values_sing[s2])?1:-1;
    else return (_values_plural[s1] < _values_plural[s2])?1:-1;
}
void start_shift()
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In start_shift()\n" );
#endif
    if (outside_hours(FALSE)) return;
    set_busy(this_object());
    move(_office, "$N arrive$s for " + query_possessive()+ " shift.");
    if (_office->query_employee(query_name()) & CLOCKED_IN)
        do_command("clock out");
    do_command("claim badge");
    do_command("wear badge");
    do_command("clock in");
    do_command(_office->query_channel()+ "@ is clocking in.");
    call_out("shuffle_to", NPC_DELAY, _shop_front, 0);
}
private void taken_over()
{
    do_command("'Okay then" + DEARIE+ ".  See you later.");
    set_busy(this_object());
    call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
}
private void what_items()
{
    do_command("'Well" + DEARIE+ ", we trade in "+
      _office->query_list_string()+ ".");
    reset_busy();
}

==================================================
FILE: shops/player_shop/storeroom.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <move_failures.h>
#include "patterns.h"
private nosave string _office = "",
_counter = "",
_mgr_office = "",
_shop_front = "",
_office_dir = "",
_counter_dir = "",
_shop_dir = "";
private nosave object *_cabinets = 0;
private nosave int _num_cabinets, _call_cabs_clear;
private nosave mapping _cache = ([]);
int add_cabinet();
private void clear_cabinets();
string directions_to(string);
private int do_add(object *, mixed *);
private int do_list(mixed *, string);
private int do_remove(mixed *);
private void init_cabinets();
private int pull_roll();
int query_content(int);
int query_num_items(string, int);
string query_office();
int query_stock(string);
string remove_cabinet();
protected void set_directions(string, string, string);
protected void set_office(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("no burial", 1);
    add_property("determinate", "");
    add_item("cabinet", "There are several cabinets in the room, holding "
      "the entire stock of the shop.  If you are authorised to do so, you "
      "may \"list\" the stock, as well as \"add\" and \"remove\" "
      "items from the cabinets.");
    add_item(({"roll", "bag"}), "You could probably \"pull\" a bag off "
      "the roll and give it to a customer with their purchase.\n"
      "Bags should only be handed out with purchases of 10 or more items.");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_storeroom");
}
void init()
{
    ::init();
    if (!_office || _office == "") return;
    add_command("add", ({"<indirect:object:me'item(s)'>",
        "<indirect:object:me'item(s)'> to cabinet <number'cabinet'>"}),
      (: do_add($1,$4) :));
    add_command("pull", "roll", (: pull_roll() :));
    if (_office->query_employee(this_player()->query_name()) ||
      this_player()->query_creator())
    {
        add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}),
          (: do_list($4,$5) :));
        add_command("remove", ({"<number> <string'item(s)'>",
            "<number> <string'item(s)'> from cabinet <number'cabinet'>"}),
          (: do_remove($4) :));
    }
    else if (_office->query_retired(this_player()->query_name()))
        add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}), (: do_list($4,$5) :));
}
int add_cabinet()
{
    object cabinet;
    string cab_name;
    if (previous_object() && previous_object() != find_object(_office))
    {
        LOG_ERROR("storeroom.c", "add_cabinet()");
        return 0;
    }
    if ((_num_cabinets) == MAX_CABINETS) return 0;
    init_cabinets();
    cab_name = "cabinet"+ _num_cabinets++;
    cabinet = clone_object(CABINET);
    cabinet->set_name(cab_name);
    cabinet->set_save_file(_office->query_savedir()+ cab_name);
    _cabinets += ({cabinet});
    return 1;
}
private void clear_cabinets()
{
    if (!_cabinets) return;
#ifdef DEBUG
    tell_creator(CREATOR, "Clearing cabinets.\n");
#endif
    foreach (object cabinet in _cabinets) cabinet->dest_me();
    _cabinets = 0;
}
void dest_me()
{
    remove_call_out(_call_cabs_clear);
    clear_cabinets();
    ::dest_me();
}
string directions_to(string place)
{
    if (place == _counter) return copy(_counter_dir);
    if (place == _office) return copy(_office_dir);
    if (place == _shop_front) return copy(_shop_dir);
    return "here";
}
private int do_add(object *items, mixed *args)
{
    int cab_no = 0;
    object *okay = ({}),
    *failed = ({});
    add_succeeded_mess("");
    if (sizeof(args) > 1)
    {
        cab_no = args[1];
        if (cab_no < 1 || cab_no > _num_cabinets)
        {
            tell_object(this_player(), "That cabinet does not exist!\n");
            return 1;
        }
    }
    init_cabinets();
    foreach (string plural in _office->query_list_array())
    {
        int tot_i, number, temp_num;
        mixed *test;
        parse_command(plural, items, "%i", test);
        if (!test || !sizeof(test)) continue;
        if (!sizeof(_office->query_cabinet(plural)))
        {
            tell_object(this_player(), "There are no cabinets assigned to "+
              plural+ "!\n");
            return 1;
        }
        if ((tot_i = _office->query_max(plural) - query_stock(plural)) < 1)
        {
            tell_object(this_player(),
              "The shop is already fully stocked on "+ plural +".\n");
            test = ({});
            continue;
        }
        test = test[1..];
        if (test[0]->query_collective())
        {
            number = test[0]->query_amount();
        }
        else
        {
            number = sizeof(test);
        }
        if (cab_no)
        {
            int cab_i = 0;
            foreach (object ob in all_inventory(_cabinets[cab_no-1]))
            {
                if (ob->query_collective())
                {
                    cab_i += ob->query_amount();
                }
                else
                {
                    cab_i += 1;
                }
            }
            cab_i = STOCK_PER_CABINET - cab_i;
            if (cab_i < 1)
            {
                tell_object(this_player(), "That cabinet is already full.\n");
                return 1;
            }
            if (member_array(cab_no, _office->query_cabinet(plural)) == -1)
            {
                tell_object(this_player(), plural +
                  " do not belong in that cabinet.\n");
                return 1;
            }
            if (number > cab_i)
            {
                tell_object(this_player(), "You cannot add all of the "+ plural +
                  " to cabinet "+ cab_no+ " without exceeding the maximum.\n");
                if (test[0]->query_collective())
                {
                    object temp = test[0]->make_medium_clone(cab_i);
                    test[0]->adjust_amount(-cab_i);
                    test = ({temp});
                    test->move(this_player());
                }
                else
                {
                    test = test[0 .. (cab_i - 1)];
                }
            }
        }
        else if (number > tot_i)
        {
            tell_object(this_player(), "You cannot add all of the "+ plural +
              " to the stock without exceeding the maximum.\n");
            if (test[0]->query_collective())
            {
                object temp = test[0]->make_medium_clone(tot_i);
                test[0]->adjust_amount(-tot_i);
                test = ({temp});
                test->move(this_player());
            }
            else
            {
                test = test[0 .. (tot_i - 1)];
            }
            number = tot_i;
        }
        temp_num = number;
        if (cab_no)
        {
            object *temp_fail;
            okay += test;
            temp_fail = _cabinets[cab_no - 1]->
            add_items(test, this_player());
            failed += temp_fail;
            if (sizeof(temp_fail))
            {
                temp_num -= temp_fail[0]->query_amount();
            }
            else
            {
                temp_num -= sizeof(temp_fail);
            }
        }
        else
        {
            int cab_i = 0;
            foreach(cab_no in _office->query_cabinet(plural))
            {
                object *temp_fail;
                if (!number) break;
                foreach (object ob in all_inventory(_cabinets[cab_no-1]))
                {
                    if (ob->query_collective())
                    {
                        cab_i += ob->query_amount();
                    }
                    else
                    {
                        cab_i += 1;
                    }
                }
                cab_i = STOCK_PER_CABINET - cab_i;
                if (cab_i < 1) continue;
                if (cab_i > number)
                {
                    cab_i = number;
                }
                if (test[0]->query_collective())
                {
                    object temp = test[0]->make_medium_clone(cab_i);
                    test[0]->adjust_amount(-cab_i);
                    okay += ({temp});
                    temp_fail = _cabinets[cab_no - 1]->
                    add_items(({temp}), this_player());
                }
                else
                {
                    okay += test[0..(cab_i-1)];
                    temp_fail = _cabinets[cab_no - 1]->
                    add_items(test[0 .. (cab_i - 1)], this_player());
                    test -= test[0 .. (cab_i - 1)];
                }
                number -= cab_i;
                failed += temp_fail;
                if (sizeof(temp_fail))
                {
                    if (temp_fail[0]->query_collective())
                    {
                        temp_num -= temp_fail[0]->query_amount();
                    }
                    else
                    {
                        temp_num -= sizeof(temp_fail);
                    }
                }
            }
            if (sizeof(test) && test[0]->query_amount())
            {
                tell_object(this_player(), "There is not enough room in the "
                  "assigned cabinets for "+ query_multiple_short(test)+ ".\n");
                if (test[0]->query_collective())
                {
                    temp_num -= test[0]->query_amount();
                }
                else
                {
                    temp_num -= sizeof(test);
                }
            }
            cab_no = 0;
        }
        test = ({});
        _office->adjust_bought(plural, temp_num);
        if (!_cache[plural])
        {
#ifdef DEBUG
            tell_creator(CREATOR,"Creating %s cache entry.\n", plural);
#endif
            _cache += ([plural:({1,0})]);
        }
        else
        {
            _cache[plural][0] = 1;
        }
    }
    okay -= failed;
    if (sizeof(failed))
    {
        string short = query_multiple_short(failed);
        tell_room(environment(this_player()), this_player()->query_short()+
          " accidentally drops "+ short+
          " on the floor.\n", ({this_player()}));
        tell_object(this_player() , "You accidentally drop "+
          short+ " on the floor.\n");
    }
    if (sizeof(okay))
    {
        string short = query_multiple_short(okay);
        _office->shop_log(PURCHASE, this_player()->query_name(),
          this_player()->convert_message(short)+
          " added to stock", UNPAID);
        add_succeeded_mess("$N $V "+ short+
          " to the stock.\n");
    }
    return 1;
}
private int do_list(mixed *args, string pattern)
{
    object *found_items = ({});
    int i = 0;
    add_succeeded_mess("");
    init_cabinets();
    foreach (object cabinet in _cabinets)
    i += sizeof(all_inventory(cabinet));
    if (!i)
    {
        tell_object(this_player(),
          "There is nothing in stock at the moment.\n");
        return 1;
    }
    if (pattern == LIST_BLANK)
    {
        string result = sprintf("     Stock of %s\n     As at %s\n\n",
          _office->query_shop_name(), ctime(time()));
        foreach(string key in _office->query_list_array())
        {
            found_items = ({});
            found_items += ((class obj_match)match_objects_in_environments(key, _cabinets))->objects;
            if (sizeof(found_items))
                result += query_multiple_short( found_items )+ "\n";
        }
        tell_object(this_player(), "$P$Stock list$P$"+ result);
        return 1;
    }
    if (pattern == LIST_CABINET)
    {
        string result;
        if (args[0] < 1 || args[0] > _num_cabinets)
        {
            tell_object(this_player(), "That cabinet does not exist!\n");
            return 1;
        }
        if (!sizeof(all_inventory(_cabinets[args[0] - 1])))
        {
            result = "There is nothing in that cabinet at the moment.\n";
        }
        else
        {
            result = sprintf("     Stock of cabinet %d\n     As at %s\n\n",
              args[0], ctime(time()));
            foreach(string key in _office->query_list_array())
            {
                if (sizeof(found_items = ((class obj_match)match_objects_in_environments(key,
                        _cabinets[args[0]-1]))->objects ))
                {
                    result += query_multiple_short(found_items)+ "\n";
                }
            }
        }
        tell_object(this_player(), "$P$Cabinet "+ args[0]+
          " stock list$P$"+ result);
        return 1;
    }
    if (pattern == LIST_ITEM)
    {
        string result;
        found_items += ((class obj_match)match_objects_in_environments(args[0], _cabinets))->objects;
        if (!sizeof(found_items))
        {
            tell_object(this_player(),  "There are no "+ args[0]+
              " in stock.\n");
            return 1;
        }
        result = sprintf("     List of %s\n     As at %s\n\n%s", args[0],
          ctime(time()), query_multiple_short(found_items));
        tell_object(this_player(), "$P$List of " + args[0]+ "$P$"+ result);
        return 1;
    }
    if (args[1] < 1 || args[1] > _num_cabinets)
    {
        tell_object(this_player(), "That cabinet does not exist!\n");
        return 1;
    }
    if (!sizeof(all_inventory(_cabinets[args[1] - 1])))
    {
        tell_object(this_player(), "There is nothing in that cabinet at "
          "the moment.\n");
        return 1;
    }
    found_items = ((class obj_match)match_objects_in_environments(args[0],
        _cabinets[args[1]-1]))->objects;
    if (!sizeof(found_items))
    {
        tell_object(this_player(), "There are no "+ args[0]+ " in stock.\n");
        return 1;
    }
    tell_object(this_player(), "$P$List of "+ args[0]+ " in cabinet "+
      args[1]+ "$P$"+ sprintf("     List of %s in cabinet %d\n     "
        "As at %s\n\n%s", args[0], args[1], ctime(time()),
        query_multiple_short(found_items)));
    return 1;
}
private int do_remove(mixed *args)
{
    int cab_no = 0;
    object *items = ({}), *failed;
    failed = ({});
    add_succeeded_mess("");
    if (sizeof(args) > 2) cab_no = args[2];
    if (query_num_items(args[1], cab_no) < args[0])
    {
        tell_object(this_player(), "The stock does not contain "+
          args[0] + " "+ args[1]+ " to remove.\n");
        return 1;
    }
    init_cabinets();
    if (!cab_no)
    {
        int number = args[0];
        for(int i = sizeof(_cabinets); i > 0; i--)
        {
            object *stock = ((class obj_match)match_objects_in_environments(args[1],
                _cabinets[i-1]))->objects;
            if (sizeof(stock))
            {
                if (stock[0]->query_collective())
                {
                    if (stock[0]->query_amount() > number)
                    {
                        object ob = stock[0]->make_medium_clone(number);
                        items += ({ ob });
                        stock[0]->adjust_amount(-number);
                        if (ob->move(this_player()) != MOVE_OK)
                        {
                            ob->move(environment(this_player()));
                            failed += ({ ob });
                        }
                    }
                    else
                    {
                        number -= stock[0]->query_amount();
                        items += stock;
                        failed += _cabinets[i-1]->remove_items(stock, this_player());
                    }
                }
                else
                {
                    if (sizeof(stock) > number) stock = stock[ 0 .. (number-1) ];
                    items += stock;
                    failed += _cabinets[i-1]->remove_items(stock, this_player());
                    number -= sizeof(stock);
                }
            }
            if (!number) break;
        }
    }
    else
    {
        items = ((class obj_match)match_objects_in_environments(args[1],
            _cabinets[cab_no-1]))->objects[0 .. (args[0] - 1)];
        failed = _cabinets[cab_no - 1]->remove_items(items, this_player());
    }
    foreach (string vest in _office->query_list_array())
    {
        if (pluralize(args[1]) == vest)
        {
            args[1] = pluralize(args[1]);
            break;
        }
    }
    if (!_cache[args[1]])
    {
#ifdef DEBUG
        tell_creator(CREATOR,"Creating %s cache entry.\n", args[1]);
#endif
        _cache += ([args[1]:({1,0})]);
    }
    else
    {
        _cache[args[1]][0] = 1;
    }
    items -= failed;
    if (sizeof(failed))
    {
        tell_room(environment(this_player() ), this_player()->query_short()+
          " accidentally drops "+ query_multiple_short(failed)+
          " on the floor.\n", ({this_player()}));
        tell_object(this_player() , "You accidentally drop "+
          query_multiple_short(failed)+ " on the floor.\n");
    }
    if (find_object(_office->query_shopkeeper()) &&
      this_player() == find_object(_office->query_shopkeeper()))
        _office->query_shopkeeper()->set_failed(sizeof(failed));
    if (sizeof(items))
    {
        _office->shop_log(SALE, this_player()->query_name(),
          this_player()->convert_message(query_multiple_short(items))+
          " removed from stock", UNPAID);
        foreach (string plural in _office->query_list_array())
        {
            object *test = ({});
            parse_command(plural, items, "%i", test);
            if (!test || !sizeof(test)) continue;
            _office->adjust_sold(plural, sizeof(test) - 1);
        }
        add_succeeded_mess("$N $V "+ query_multiple_short(items)+
          " from the stock.\n");
    }
    return 1;
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k,o,k2,r,k3);
}
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
string long(string word, int dark)
{
    return sprintf("%sThere are currently %d store cabinets "
      "in the room.\n", ::long(word,dark), _num_cabinets);
}
private void init_cabinets()
{
    if (remove_call_out(_call_cabs_clear) == -1 && !_cabinets)
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Initialising cabinets.\n");
#endif
        _cabinets = ({});
        for (int i = 0; i < _num_cabinets; i++)
        {
            string cab_name = "cabinet"+ i;
            object cabinet = clone_object(CABINET);
            cabinet->set_name(cab_name);
            cabinet->set_save_file(_office->query_savedir()+ cab_name);
            _cabinets += ({cabinet});
        }
    }
    _call_cabs_clear = call_out((: clear_cabinets() :), CLEAR_DELAY);
}
private int pull_roll()
{
    object bag;
    string message, day, day2, month;
    bag = clone_object(SHOP_BAG);
    sscanf(amtime(time()), "%*s %s %s %s", day, day2, month);
    if (member_array( month, ({"Offle", "February", "March",
          "April", "May", "June", "Grune", "August", "Spune", "Sektober",
          "Ember", "December", "Ick"}) ) == -1)
        message = sprintf("A very happy %s %s %s\n\nfrom everyone at\n\n%s, %s",
          day, day2, month, _office->query_shop_name(),
          _office->query_place());
    else message = sprintf("With the compliments of\n\n%s, %s.",
          _office->query_shop_name(), _office->query_place());
    bag->set_read_mess(message);
    bag->set_max_cond(400);
    bag->set_cond(400);
    if ((int)bag->move(this_player()) != MOVE_OK)
    {
        bag->move(this_object());
        tell_object(this_player(),
          "You drop the bag as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V the roll and $I comes off in $p hand.\n",
      ({bag}) );
    return 1;
}
int query_num_items(string item, int cabinet)
{
    object *obs;
    init_cabinets();
    if (cabinet)
    {
        obs = ((class obj_match)match_objects_in_environments(item,
            _cabinets[cabinet-1]))->objects;
        if (!sizeof(obs))
        {
            return 0;
        }
        else if (obs[0]->query_collective())
        {
            return obs[0]->query_amount();
        }
        else
        {
            return sizeof(obs);
        }
    }
    else
    {
        return query_stock(item);
    }
}
string query_office() { return copy(_office); }
int query_stock(string item)
{
    object *obs;
    init_cabinets();
    if (!_cache[item])
    {
#ifdef DEBUG
        tell_creator(CREATOR,"Creating %s cache entry.\n", item);
#endif
        _cache += ([item:({1,0})]);
    }
    if (_cache[item][0])
    {
#ifdef DEBUG
        tell_creator("ringo","Updating %s in cache.\n", item);
#endif
        obs = ((class obj_match)match_objects_in_environments(item, _cabinets))->objects;
        if (!sizeof(obs))
        {
            _cache[item][1] = 0;
        }
        else if (obs[0]->query_collective())
        {
            _cache[item][1] = obs[0]->query_amount();
        }
        else
        {
            _cache[item][1] = sizeof(obs);
        }
        _cache[item][0] = 0;
    }
    return _cache[item][1];
}
string remove_cabinet()
{
    object cabinet;
    if (previous_object() && previous_object() != find_object(_office))
    {
        LOG_ERROR("storeroom.c", "remove_cabinet()");
        return "";
    }
    if ((_num_cabinets) == MIN_CABINETS) return "";
    init_cabinets();
    _num_cabinets--;
    cabinet = _cabinets[_num_cabinets];
    _cabinets -= ({cabinet});
    cabinet->move("/room/rubbish");
    return cabinet->query_name();
}
protected void set_directions(string office, string counter, string shop)
{
    _office_dir = office;
    _counter_dir = counter;
    _shop_dir = shop;
}
protected void set_long(string long_desc)
{
    long_desc += "Employees can \"add\" something to, \"remove\" "
    "something from and \"list\" the stock.\nThere is a roll of "
    "shopping bags conveniently located on one wall.\n";
    ::set_long(long_desc);
}
protected void set_office(string path)
{
    _office = path;
    _counter = _office->query_counter();
    _mgr_office = _office->query_mgr_office();
    _shop_front = _office->query_shop_front();
    _num_cabinets = _office->query_num_cabinets();
}

==================================================
FILE: shops/player_shop/office_code/admin.c
==================================================

private void add_board_message(string subject, string post)
{
   string *employees;
   if (_board)
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Posting message %s to board %s.\n", subject,
        _channel);
#endif
      BOARD_HAND->add_message(_channel, _proprietor,
        subject, post + "--\n"+ _proprietor+ " (proprietor)");
   }
   else
   {
      employees = _retired;
      foreach(string employee in m_indices(_employees))
         if (!(_employees[employee][EMP_POINTS] & NPC))
            employees += ({ employee });
      if (!sizeof(employees))
      {
#ifdef DEBUG
         tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
         return;
      }
      employees += ({CREATOR});
#ifdef DEBUG
      tell_creator(CREATOR, "Sending mail %s to all employees.\n", subject);
#endif
      AUTO_MAILER->auto_mail(implode(employees, ","), _proprietor,
           subject+ " ("+ _very_short+ ")", "", post);
   }
}
private void adjust_bonus(string emp, int amount)
{
   string sign = "";
   _accounts["bonus"] += amount;
   if (amount < 0)
   {
      sign = "-";
      amount = -amount;
   }
   shop_log( ACCOUNTS, emp, sprintf( "adjusted the bonus account by %s%s",
     sign, MONEY_HAND->money_value_string( amount, _place ) ), UNPAID );
   save_me();
}
private void adjust_profit(string emp, int amount)
{
   string sign = "";
   _accounts["profit"] += amount;
   if (amount < 0)
   {
      sign = "-";
      amount = -amount;
   }
   shop_log(ACCOUNTS, emp, sprintf("adjusted the profit account by %s%s",
     sign, MONEY_HAND->money_value_string(amount, _place)), UNPAID);
   save_me();
}
void adjust_takings(int amt)
{
   if (previous_object() && previous_object() != find_object(_counter))
   {
      LOG_ERROR("office.c", "adjust_bought("+amt+")");
      return;
   }
   _net_takings += amt;
   save_me();
}
void calc_bonus()
{
   int bonus_val, bonus_divisor = 0;
   foreach (string str in m_indices(_employees))
   {
      if (_employees[str][EMP_NOBONUS]) continue;
      if (_employees[str][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[str][EMP_POINTS] & SUPERVISOR || _eom == str)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) bonus_val = _accounts["bonus"];
   else bonus_val = ( _accounts["bonus"] * 2 ) / bonus_divisor;
   tell_object(this_player(), "Based on the bonus fund of "+
     MONEY_HAND->money_value_string(_accounts["bonus"], _place)+
     ", the following bonuses are anticipated:\n"
     "\n     Managers    - "+
     MONEY_HAND->money_value_string(bonus_val * 2, _place)+
     "\n     Supervisors - "+
     MONEY_HAND->money_value_string(to_int(bonus_val * 1.5), _place)+
     "\n     Employees   - "+
     MONEY_HAND->money_value_string(bonus_val, _place)+ "\n");
}
int calc_pay()
{
   int amount = 0;
   foreach(string word in m_indices(_employees))
      amount += _employees[word][EMP_PAY];
   return amount;
}
private string cap_name(string name)
{
   if (!name) return 0;
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}
int check_manager( string action )
{
   object tp = this_player();
   string tp_name = tp->query_name();
   if (tp->query_creator() || (_employees[tp_name][EMP_POINTS] & MANAGER) ||
     (member_array(tp_name, _retired) != -1)) return 1;
   return notify_fail( "You are not a manager here!\n" );
}
string directions_to( string place )
{
   if (place == _counter) return copy(_counter_dir);
   if (place == _storeroom) return copy(_store_dir);
   if (place == _shop_front) return copy(_shop_dir);
   return "here";
}
int do_set(mixed *args, string pattern)
{
   int value, best;
   object money;
   switch(pattern)
   {
      case SET_EMPS :
         if (args[0] < MIN_EMP || args[0] > MAX_EMP)
         {
            tell_object(this_player(), "Must be between "+ MIN_EMP+
              " and "+ MAX_EMP+ ".\n");
            return 1;
         }
         shop_log(PERSONNEL, this_player()->query_name(),
           "set maximum employees to "+ args[0], PAID);
         _max_emp = args[0];
         break;
      case SET_PAY :
         money = clone_object( MONEY_OBJECT );
         money->set_money_array(MONEY_HAND->query_values_in(_place));
         if ((best = money->find_best_fit(args[1])) == -1)
         {
            tell_object(this_player(),
              "That currency is not used by the shop.\n");
            return 1;
         }
         value = args[0] * (money->query_money_array())[best + 1];
         money->dest_me();
         if (value < 1)
         {
            tell_object(this_player(),
              "You must pay your employees something.\n");
            return 1;
         }
         shop_log(PERSONNEL, this_player()->query_name(), "set pay to "+
           MONEY_HAND->money_value_string(value, _place), PAID);
         _pay_val = value;
         add_board_message("Pay", sprintf("The base pay rate has today "
           "been set to:\n\n   Managers: %s\n   Supervisors: %s\n   "
           "Employees: %s\n", MONEY_HAND->money_value_string(value * 2, _place),
           MONEY_HAND->money_value_string(to_int(value * 1.5), _place),
           MONEY_HAND->money_value_string(value, _place)));
         break;
   }
   tell_object(this_player(), "Ok.\n");
   save_me();
   return 1;
}
int do_transfer(mixed *args)
{
   int value, best;
   object money;
   string tp;
   if (args[2] == args[3] || !args[0])
   {
      tell_object(this_player(), "The point being?\n");
      return 1;
   }
   tp = this_player()->query_name();
   money = clone_object(MONEY_OBJECT);
   money->set_money_array(MONEY_HAND->query_values_in(_place));
   if ((best = money->find_best_fit(args[1])) == -1)
   {
      tell_object(this_player(), "That currency is not used by "
        "the shop.\n");
      return 1;
   }
   value = args[0] * (money->query_money_array())[best + 1];
   money->dest_me();
   switch(args[2]) {
   case "register" :
      if (_counter->query_register() < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      _counter->adjust_register(tp, value);
      if (args[3] == "profit") adjust_profit(tp, value);
      else adjust_bonus( tp, value );
      break;
   case "bonus" :
      if (_accounts["bonus"] < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      adjust_bonus(tp, -value);
      if (args[3] == "profit") adjust_profit(tp, value);
      else
      {
         money = MONEY_HAND->make_new_amount(value, _place);
         _counter->add_money_ob(money);
         shop_log(ACCOUNTS, tp, "adjusted the register by "+
           MONEY_HAND->money_value_string(value, _place), UNPAID);
      }
      break;
   case "profit" :
      if (_accounts["profit"] < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      adjust_profit(tp, -value);
      if (args[3] == "bonus") adjust_bonus( tp, value );
      else
      {
         money = MONEY_HAND->make_new_amount(value, _place);
         _counter->add_money_ob(money);
         shop_log( ACCOUNTS, tp, "adjusted the register by "+
           MONEY_HAND->money_value_string(value, _place), UNPAID);
      }
      break;
   }
   shop_log (ACCOUNTS, tp, "transferred "+ args[0]+ " "+ args[1]+ " from "+
      args[2]+ " to "+ args[3], PAID);
   tell_object(this_player(), "Ok.\n");
   return 1;
}
private void load_applicants()
{
   if (remove_call_out(_call_apps) != -1 ||
      remove_call_out(_call_apps_clear) != -1) return;
   if (!_applicants)
      if (file_size(_savedir+ "applications") > 0)
         _applicants = restore_variable(unguarded((: read_file,
            _savedir+ "applications" :)));
      else _applicants = ([]);
}
private void load_history()
{
   if (remove_call_out(_call_hist) != -1 ||
      remove_call_out(_call_hist_clear) != -1) return;
   if (!_history)
      if (file_size(_savedir+ "history") > 0)
         _history = restore_variable(unguarded((: read_file,
            _savedir+ "history" :)));
      else _history = ([]);
}
private void load_new_policies()
{
   if (remove_call_out(_call_newpols) != -1 ||
      remove_call_out(_call_newpols_clear) != -1) return;
   if (!_new_policies)
      if ( file_size(_savedir+ "new_policies") > 0 )
         _new_policies = restore_variable(unguarded((: read_file,
            _savedir+ "new_policies" :)));
      else _new_policies = ([]);
}
private void load_policies()
{
   if (remove_call_out(_call_pols) != -1 ||
      remove_call_out(_call_pols_clear) != -1) return;
   if (!_policies)
      if ( file_size( _savedir+ "policies" ) > 0 )
         _policies = restore_variable( unguarded( (: read_file,
            _savedir+ "policies" :) ) );
      else _policies = ([]);
}
string * query_eom() { return ({_last_month,_eom,}); }
private void remove_employee(string employee)
{
   employee = lower_case(employee);
   if (_employees[employee])
   {
      map_delete(_employees, employee);
      save_emps();
   }
   remove_applicant(employee);
   remove_retired(employee);
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
}
private void remove_retired(string retired)
{
   retired = lower_case(retired);
   if (member_array(retired, _retired) == -1) return;
   _retired -= ({retired});
   save_me();
}
private void reset_employee(string word, int bit)
{
   if (!_employees[word]) return;
   if ((bit < EMPLOYEE) || (bit > CLOCKED_IN))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Trying to reset an employee bit < %d || > %d\n",
         EMPLOYEE, CLOCKED_IN );
#endif
      return;
   }
   _employees[word][EMP_POINTS] -= _employees[word][EMP_POINTS] & bit;
   if (bit != CLOCKED_IN) save_emps();
}
mixed *restore_register() { return copy(_register + ({})); }
void set_employee(string word, int bit)
{
   if (!_employees[word]) return;
   _employees[word][EMP_POINTS] |= bit;
   if (bit != CLOCKED_IN) save_emps();
}
void summon_shopkeeper()
{
   object shopkeeper = find_object(_shopkeeper);
   if (shopkeeper && environment(shopkeeper)) return;
   if (num_employees_in()) return;
   _shopkeeper->start_shift();
}

==================================================
FILE: shops/player_shop/office_code/applications.c
==================================================

void add_applicant(string player, string message)
{
   if (previous_object() && previous_object() != find_object(_shop_front))
   {
      LOG_ERROR("office.c", "add_applicant("+player+","+message+")");
      return;
   }
   player = lower_case(player);
   if (!query_applicant(player))
   {
      load_applicants();
      if (!sizeof(_applicants)) _applicants = ([ player:APP_MAP ]);
      else _applicants += ([ player:APP_MAP ]);
      _applicants[player][APP_TIME] = time();
      _applicants[player][APP_MESSAGE] = message;
      employee_log( player, "Applied for employment" );
      save_applicants();
   }
}
private void add_declined(string applicant)
{
   applicant = lower_case(applicant);
   if (!query_declined(applicant))
   {
      if (!sizeof(_declined)) _declined = ([applicant:0]);
      else _declined += ([applicant:0]);
      _declined[applicant] = time();
      save_me();
   }
}
private void add_vote(string applicant, int vote)
{
   string voter = this_player()->query_name();
   int managers = sizeof(get_managers());
   if (!managers) managers = 1;
   load_applicants();
   if (vote == VABSTAIN) _applicants[applicant][APP_ABSTAIN] += ({voter});
   else if (vote == VFOR) _applicants[applicant][APP_FOR] += ({voter});
   else _applicants[applicant][APP_AGAINST] += ({voter});
   shop_log(GENERAL, voter, "voted on "+ cap_name(applicant), PAID);
   save_applicants();
   managers -= sizeof(_applicants[applicant][APP_ABSTAIN]);
   if (sizeof(_applicants[applicant][APP_FOR]) > managers / 2)
   {
      PLAYER_SHOP->auto_mail(applicant, _proprietor, _shop_name, "",
         "Congratulations!  You've been accepted to work at "+
         _shop_name+ ".  Please return to the shop within the next "
         "seven days to \"confirm\" that you wish to accept "
         "the position.\n");
      _applicants[applicant][APP_TYPE] = HIRED;
      _applicants[applicant][APP_TIME] = time();
      employee_log(applicant, "Application was accepted");
   }
   else if (sizeof(_applicants[applicant][APP_AGAINST]) >=
      managers / 2)
   {
      remove_applicant(applicant);
      PLAYER_SHOP->auto_mail(applicant, _proprietor, _shop_name, "",
         "Thank you for your recent application for employment "
         "with us.  Unfortunately, I have to inform you that you "
         "have been unsuccessful at this time.  Please feel free "
         "to re-apply again in the future, when your application "
         "will be re-considered.\n");
      employee_log(applicant, "Application was declined");
      add_declined(applicant);
   }
}
void check_hire_list()
{
   int count;
   string *hirees = ({});
   load_applicants();
   foreach (string word in m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == HIRED :))))
      if (time() - _applicants[word][APP_TIME] > HIRE_TIMEOUT)
      {
         PLAYER_SHOP->auto_mail(word, _proprietor,
            _shop_name, "", "Since you have not returned to confirm "
            "your employment with us, we have assumed that you are no "
            "longer interested, and removed your name from our files.  "
            "If you wish to re-apply at any time in the future, please "
            "return to the shop to do so.\n");
         employee_log(word, "Lapsed their application");
         remove_applicant(word);
      }
   foreach (string word in m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == APPLIED :))))
      if (sizeof(_applicants[word][APP_FOR]) >
         sizeof(get_managers()) / 2)
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
            "Congratulations!  You've been accepted to work at "+
            _shop_name+ ".  Please return to the shop within the next "
            "seven days to \"confirm\" that you wish to accept "
            "the position.\n");
         _applicants[word][APP_TYPE] = HIRED;
         _applicants[word][APP_TIME] = time();
         employee_log(word, "Application was accepted");
      }
      else if (time() - _applicants[word][APP_TIME] > VOTE_TIMEOUT)
      {
         if (sizeof(_applicants[word][APP_FOR]) <=
            sizeof(_applicants[word][APP_AGAINST]))
         {
            remove_applicant(word);
            PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
               "Thank you for your recent application for employment "
               "with us.  Unfortunately, I have to inform you that you "
               "have been unsuccessful at this time.  Please feel free "
               "to re-apply again in the future, when your application "
               "will be re-considered.\n");
            employee_log(word, "Application was declined");
            add_declined(word);
         }
         else
         {
            PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
               "Congratulations!  You've been accepted to work at "+
               _shop_name+ ".  Please return to the shop within the next "
               "seven days to \"confirm\" that you wish to accept "
               "the position.\n");
            _applicants[word][APP_TYPE] = HIRED;
            _applicants[word][APP_TIME] = time();
            employee_log(word, "Application was accepted");
         }
      }
   count = _max_emp - sizeof(_employees);
   if (count < 1) return;
   hirees = sort_array(keys(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))),
      (: _applicants[$1][APP_TIME] - _applicants[$2][APP_TIME] :));
   if (count > sizeof(hirees)) count = sizeof( hirees );
   for (int n = 0; n < count; n++) hire(hirees[n]);
   save_applicants();
}
int do_cancel()
{
   object tp = this_player();
   remove_applicant(tp->query_name());
   employee_log(tp->query_name(), "Cancelled application");
   tell_object(tp, "You cancel your application.\n");
   return 1;
}
int do_confirm()
{
   object tp = this_player();
   string applicant = lower_case(tp->query_name());
   if (previous_object() && previous_object() != find_object(_shop_front))
   {
      LOG_ERROR("office.c", "do_confirm()");
      return 0;
   }
   load_applicants();
   _applicants[applicant][APP_TYPE] = AWAITING;
   _applicants[applicant][APP_TIME] = time();
   tell_object(tp, "You have now been added to "
      "our waiting list.  You will be notified of your position in the "
      "list as it changes.  You may \"cancel\" your application at "
      "any time.  You are currently at position " +
      sizeof(m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))))+
      " in the waiting list.\n");
   save_applicants();
   employee_log(applicant, "Confirmed employment");
   tell_object(tp, "You confirm your employment.\n");
   return 1;
}
int do_vote(mixed *args, string pattern)
{
   int query_app;
   string tp = this_player()->query_name();
   if (pattern == VOTE_APPLICANT)
   {
      args[0] = lower_case(args[0]);
      if (!(query_app = query_applicant(args[0])))
      {
         tell_object(this_player(),cap_name(args[0])+
            " hasn't applied!\n");
         return 1;
      }
      if (query_app != APPLIED)
      {
         tell_object(this_player(), cap_name( args[0])+
            " has already been hired!\n");
         return 1;
      }
      load_applicants();
      if (member_array(tp, _applicants[args[0]][APP_FOR]) != -1 ||
         member_array(tp, _applicants[args[0]][APP_AGAINST]) != -1 ||
         member_array(tp, _applicants[args[0]][APP_ABSTAIN]) != -1)
      {
         tell_object(this_player(),
            "You have already voted for this person!\n");
         return 1;
      }
      switch (args[1][0])
      {
      case 'y' :
         add_vote(args[0], VFOR);
         tell_object(this_player(), "You vote for " +
            cap_name( args[0] ) + " to work for the shop.\n");
         break;
      case 'a' :
         add_vote(args[0], VABSTAIN);
         tell_object(this_player(), "You abstain on " +
            cap_name(args[0] ) + ".\n");
         break;
      default :
         add_vote(args[0], VAGAINST);
         tell_object(this_player(), "You vote against " +
            cap_name( args[0] ) + " working for the shop.\n");
      }
      clear_applicants();
   }
   else do_policy_vote(tp, args[0], args[1]);
   return 1;
}
private void mail_hirees()
{
   string *hirees;
   load_applicants();
   hirees = sort_array(keys(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))),
      (: _applicants[$1][APP_TIME] - _applicants[$2][APP_TIME] :));
   for (int x = 0; x < sizeof(hirees); x++)
      PLAYER_SHOP->auto_mail(hirees[x], _proprietor, _shop_name, "",
         "I am writing to inform you that you have now moved to position "+
         (x + 1)+ " in the employment waiting list.  If you are not near "
         "the top of the list, please be patient.\nThank you.\n");
   clear_applicants();
}
private void remove_applicant(string applicant)
{
   applicant = lower_case(applicant);
   if (query_applicant(applicant))
   {
      load_applicants();
      map_delete(_applicants, applicant);
      save_applicants();
   }
}
private void remove_declined(string declined)
{
   declined = lower_case(declined);
   if (query_declined(declined))
   {
      map_delete(_declined, declined);
      save_me();
   }
}

==================================================
FILE: shops/player_shop/office_code/baddies.c
==================================================

private void add_baddie(string word, string reason, string banner)
{
   object ob;
   word = lower_case(word);
   if (query_baddie(word))
   {
      if (_baddies[word][BAD_TIME] == time() ||
         reason == _baddies[word][BAD_REASON]) return;
      remove_baddie( word );
   }
   if (!sizeof(_baddies)) _baddies = ([word:BAD_MAP]);
   else _baddies += ([word:BAD_MAP]);
   _baddies[word][BAD_REASON] = reason;
   _baddies[word][BAD_BANNER] = banner;
   _baddies[word][BAD_TIME] = time();
   save_me();
   shop_log(GENERAL, banner, "banned "+ cap_name(word)+
      " for "+ reason, PAID);
   employee_log(word, sprintf("Banned by %s for %s.", cap_name(banner),
      reason));
   fire_them(_proprietor, word, reason);
   remove_applicant(word);
   if (!(ob = find_player(word))) return;
   if (environment(ob) == find_object(_shop_front))
   {
      tell_room(_shop_front, ob->query_short()+ " drifts out of the door, "
        "seemingly against "+ ob->query_possessive()+ " will.\n", ({ob}));
      tell_object(ob , "You feel yourself pushed out of the shop "
        "by a mysterious force.\n");
      tell_room(_shop_front->query_outside(), ob->query_short()+
        " drifts through the door of "+ _shop_name +
        ", seemingly against "+ ob->query_possessive()+ " will.\n", ({ob}));
      ob->move(_shop_front->query_outside());
   }
}
int do_ban(mixed *args)
{
   if (!test_player(lower_case(args[0])))
   {
      tell_object(this_player(), args[0]+ " is not a player.\n");
      return 1;
   }
   if (_employees[args[0]][EMP_POINTS] & MANAGER &&
      !this_player()->query_creator())
   {
      tell_object(this_player(), "You cannot ban "+ cap_name(args[0])+
         ".\n");
      return 1;
   }
   add_baddie(args[0], args[1], this_player()->query_name());
   tell_object(this_player(), "You ban "+ cap_name(args[0])+
     " for "+ args[1]+ ".\n");
   return 1;
}
int do_unban(string person)
{
   if (!query_baddie(person))
   {
      tell_object(this_player(), person+ " is not currently banned.\n");
      return 1;
   }
   remove_baddie(person);
   shop_log(GENERAL, this_player()->query_name(),
     "removed the ban on "+ cap_name(person), PAID);
   tell_object(this_player(), "You remove the ban on "+
     cap_name(person)+ ".\n" );
   return 1;
}
private void remove_baddie(string word)
{
   if (!query_baddie(word)) return;
   map_delete(_baddies, word);
   save_me();
}

==================================================
FILE: shops/player_shop/office_code/cabinets.c
==================================================

private void add_chart_cabinet(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_CAB] += ({number});
   _list[word][CHART_CAB] = sort_array(_list[word][CHART_CAB], 1);
   save_list();
}
void confirm_cabinet(string confirm, int rent)
{
   if (previous_object() && previous_object() != this_object())
   {
      LOG_ERROR("office.c", "confirm_cabinet("+confirm+","+rent+")");
      return;
   }
   confirm = lower_case(confirm);
   if ( strlen(confirm) < 1 ||
     (confirm[0] != 'y' && confirm[0] != 'n'))
   {
       tell_object(this_player(), sprintf("Please enter 'yes' or 'no'.\n"
         "Are you sure you want to %s a cabinet? ", (rent)?"rent":"remove"));
       input_to("confirm_cabinet", 0, rent);
       return ;
   }
   if (confirm[0] == 'n')
   {
      tell_object(this_player(), "Ok.\n");
      return;
   }
   if (rent)
      if (_storeroom->add_cabinet())
      {
         _num_cabinets++;
         adjust_profit(this_player()->query_name(), -CABINET_COST);
         shop_log(ACCOUNTS, this_player()->query_name(),
           "rented cabinet for "+ MONEY_HAND->money_value_string(CABINET_COST,
           _place), PAID);
         save_me();
      }
   else
   {
      string cab_name;
      if ((cab_name = _storeroom->remove_cabinet()) != "")
      {
         _num_cabinets--;
         shop_log(ACCOUNTS, this_player()->query_name(),
           "removed cabinet", PAID);
         if (file_size(_savedir+ _cab_name + ".o") > 0)
         {
            _cab_name = cab_name;
            call_out((: rm_cab() :), 5);
         }
         save_me();
      }
   }
   tell_object(this_player(), "Cabinet "+ (rent)?"rent":"remov" + "ed.\n");
}
private int do_check()
{
   string result = "Current cabinet assignments are:\n";
   for (int x = 0; x < _num_cabinets; x++)
   {
      string *items = ({});
      result += sprintf("Cabinet %2d: ", x+1);
      foreach(string item in m_indices(_list))
         if (member_array(x+1, _list[item][CHART_CAB]) != -1)
            items += ({sprintf("%s (%d)", item, _list[item][CHART_MAX])});
      if (sizeof(items)) result += query_multiple_short( items );
      result += "\n";
   }
   result += "\n";
   tell_object(this_player(), "$P$Cabinet assignments$P$"+ result);
   return 1;
}
int do_remove()
{
   int stock;
   if (!((stock = _num_cabinets) > MIN_CABINETS))
   {
      tell_object(this_player(), "The shop already contains the "
        "minimum number of cabinets.\n");
      return 1;
   }
   if (sizeof(_storeroom->query_stock(stock)))
   {
      tell_object(this_player(), "Cabinet "+ stock+
        " still contains stock.\n");
      return 1;
   }
   if (query_cabinet_used(stock))
   {
      tell_object(this_player(), "Cabinet "+ stock+
        " is still assigned to hold stock.\n");
      return 1;
   }
   tell_object(this_player(), "Are you sure you wish to remove a cabinet? ");
   input_to("confirm_cabinet", 0, 0);
   return 1;
}
int do_rent()
{
   if (!(_num_cabinets < MAX_CABINETS))
   {
      tell_object(this_player(), "The shop already contains the "
        "maximum number of cabinets.\n");
      return 1;
   }
   if (CABINET_COST > _accounts["profit"])
   {
      tell_object(this_player(), "Cabinets currently cost "+
        MONEY_HAND->money_value_string(CABINET_COST, _place) +
        ".  There is not enough money in the profit account.\n");
      return 1;
   }
   tell_object(this_player(), "Are you sure you wish to rent a cabinet for "+
     MONEY_HAND->money_value_string( CABINET_COST, _place ) + " per month? ");
   input_to("confirm_cabinet", 0, 1);
   return 1;
}
int *query_cabinet(string item)
{
   return (!_list[item])?({}):copy(_list[item][CHART_CAB]);
}
int query_cabinet_used(int cabinet)
{
   foreach(string word in m_indices(_list))
      if ( member_array(cabinet, _list[word][CHART_CAB]) != -1)
         return TRUE;
   return FALSE;
}
private void remove_chart_cabinet(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_CAB] -= ({number});
   save_list();
}
private void rm_cab()
{
#ifdef DEBUG
   tell_creator(CREATOR, "Removing cabinet file %s.\n",
     _savedir+ _cab_name+ ".o");
#endif
   unguarded((: rm, _savedir+ _cab_name+ ".o" :));
   _cab_name = "";
}

==================================================
FILE: shops/player_shop/office_code/emp_cmd.c
==================================================

private int do_bank(mixed *args)
{
   object tp = this_player();
   string word = tp->query_name();
   if (tp->query_creator())
   {
      tell_object(tp, "Creators don't get paid.\n");
      return 1;
   }
   add_succeeded_mess( "" );
   if ( !sizeof( args ) )
   {
      string message = "You are currently being paid into your account at "+
        BANKS[_employees[word][EMP_BANK]][0]+ ".  To change which bank "
        "you would like your pay to be deposited at, use the command "
        "\"bank <number>\" where <number> is one of the following:\n\n";
      for (int x = 0; x < sizeof(BANKS); x++)
         message += sprintf("     %d: %s\n", x+1, BANKS[x][0]);
      tell_object(tp, message + "\n");
      return 1;
   }
   if (args[0] < 1 || args[0] > sizeof(BANKS))
   {
      tell_object(tp,  "There are "+ sizeof(BANKS)+
        " banks to choose from.\n");
      return 1;
   }
   _employees[word][EMP_BANK] = args[0] - 1;
   save_emps();
   tell_object(tp, "You change your bank details.\n");
   return 1;
}
private int do_claim(string item)
{
   object thing,
          tp = this_player();
   int give_bonus;
   string tp_name = tp->query_name();
   switch(item)
   {
     case "badge" :
        thing = clone_object(BADGE);
        thing->set_props(file_name(this_object()), tp->query_name());
        break;
     case "handbook" :
        thing = clone_object(STAFF_BOOK);
        thing->set_read_mess("\n   "+ _shop_name+ "\n\n"
          "   Staff Handbook\n\n   This handbook belongs to: "+
          tp->query_short()+ "\n\n", "common", 100);
        thing->set_office(file_name(this_object()));
        tp->add_property(_very_short+ " handbook",1);
        break;
     case "bonus" :
        if (member_array(tp_name, _got_bonus) != -1)
        {
           tell_object(tp, "You are not entitled to a "
             "bonus this month!\n");
           return 1;
        }
        if (_employees[tp_name][EMP_POINTS] & MANAGER)
        {
           give_bonus = _bonus_val * 2;
        }
        else if (_employees[tp_name][EMP_POINTS] & SUPERVISOR ||
           _eom == tp_name)
        {
           give_bonus = to_int(_bonus_val * 1.5);
        }
        else
        {
           give_bonus = _bonus_val;
        }
        if (!give_bonus)
        {
           tell_object(tp,  "There is no money in the bonus "
             "fund this month.\n");
           return 1;
        }
        _got_bonus += ({tp_name});
        _bonus -= give_bonus;
        if (_bonus < 0) _bonus = 0;
        thing = MONEY_HAND->make_new_amount(give_bonus, _place);
        shop_log(GENERAL, tp_name, "claimed "+
          MONEY_HAND->money_value_string(give_bonus, _place), UNPAID);
        if (thing->move(tp) != MOVE_OK)
        {
           thing->move(environment(tp));
           tell_object(tp, "You drop "+ thing->query_short()+
             " as you're carrying too much.\n");
        }
        save_me();
        add_succeeded_mess("$N $V "+ MONEY_HAND->
          money_value_string(give_bonus, _place )+ ".\n");
        return 1;
        break;
   }
   if (thing->move(tp) != MOVE_OK)
   {
      thing->move(this_object());
      tell_object(tp, "You drop your "+ item+
        " as you're carrying too much.\n");
   }
   add_succeeded_mess("$N $V a new "+ item+ ".\n");
   return 1;
}
private int do_clock(string clock)
{
   object tp = this_player();
   string word = tp->query_name();
   int pay_them = UNPAID;
   if (tp->query_creator())
   {
      tell_object(tp, "Creators don't clock in or out.\n");
      return 1;
   }
   switch(clock)
   {
     case "in" :
        if (_employees[word][EMP_POINTS] & CLOCKED_IN)
        {
           tell_object(tp, "You are already clocked in!\n");
           return 1;
        }
        remove_call_out(_call_summon);
        if (tp->query_property("no score") &&
           !_employees[word][EMP_NOPROMOTE])
        {
           _employees[word][EMP_NOPROMOTE] = TRUE;
           save_emps();
        }
        pay_them = PAID;
        set_employee(word, CLOCKED_IN);
        break;
     case "out" :
        if (!(_employees[word][EMP_POINTS] & CLOCKED_IN))
        {
           tell_object(tp, "You are already clocked out!\n");
           return 1;
        }
        remove_call_out(_call_summon);
        _call_summon = call_out((: summon_shopkeeper() :), 60);
        reset_employee(word, CLOCKED_IN);
        break;
   }
   add_succeeded_mess("$N $V "+ clock+ ".\n");
   shop_log(GENERAL, word, "clocked "+ clock, pay_them);
   return 1;
}

==================================================
FILE: shops/player_shop/office_code/lists.c
==================================================

string badge_list()
{
   string *results = ({}),
          *creators = ({});
   foreach(object ob in children(BADGE))
   {
      if (ob == find_object(BADGE)) continue;
      if (ob->query_channel() != _channel) continue;
      if (environment(ob)->query_creator())
         creators += ({ environment(ob)->query_name() });
   }
   if (member_array(CREATOR, creators) != -1)
   {
      object ob = find_player(CREATOR);
      creators -= ({CREATOR});
      if (ob && !ob->query_invis())
      {
         string temp_result = ob->query_cap_name() +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   }
   if (sizeof(creators))
      foreach(string word in sort_array(creators, 1))
      {
         string temp_result = cap_name(word) +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   foreach (string word in sort_array(_retired, 1))
   {
      object ob;
      if (ob = find_player(word))
      {
         string temp_result = "%^CYAN%^"+ ob->query_cap_name() +
            "%^RESET%^ (R)";
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_managers())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (m)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_supervisors())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (s)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_employees())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   if (!sizeof(results))
      return "\nJust you, I'm afraid.\n";
   return sprintf("\n%s\n", query_multiple_short(results));
}
int do_list()
{
   int emps_in;
   string results = "   Employees of "+ _shop_name + "\n"
                    "     As at " + ctime(time()) + "\n\n";
   foreach (string word in sort_array(_retired, 1))
   {
      object ob = find_player(word);
      if (ob)
         results += "%^GREEN%^";
      results += "     "+ cap_name(word)+
      "%^RESET%^ (retired manager)\n";
   }
   foreach (string word in get_managers())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (manager)"+
        list_stuff(word);
   }
   foreach (string word in get_supervisors())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (supervisor)"+
        list_stuff(word);
   }
   foreach (string word in get_employees())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in ++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^"+ list_stuff(word);
   }
   results += "\n";
   if (this_player()->query_creator() ||
     _employees[this_player()->query_name()][EMP_POINTS] & MANAGER)
   {
      results += (emps_in == 1)?"   There is one employee ":
                 "   There are "+ query_num(emps_in,0)+ " employees ";
      results += "out of "+ query_num(sizeof(_employees) - 1)+
        " on " + mud_name() + " at the moment, with "+ query_num(num_employees_in(),
          0) + " currently clocked in.\n\n";
   }
   tell_object(this_player(), "$P$Employees$P$"+ results);
   add_succeeded_mess("");
   return 1;
}
private int do_office()
{
   int employee;
   object tp = this_player();
   string tp_name = tp->query_name(),
          board_mess = "";
   if (!_board)
      board_mess = "   memo      - send a memo to the other employees\n";
   add_succeeded_mess("");
   tp = this_player();
   tp_name = tp->query_name();
   if (member_array(tp_name, _retired) != -1)
   {
      tell_object( tp, "As a retired manager, you can use the following "
        "commands:\n"
        "   claim     - claim a badge or handbook\n"
        "   list      - list the other employees of the shop\n"
        "   logs      - review the shop's logs\n"
        "   resign    - terminate your association with Tarnach's\n"+
        board_mess+
        "You may also enter the managers' office for more commands.\n" );
      return 1;
   }
   employee = (tp->query_creator())?SUPERVISOR + MANAGER:
              _employees[tp_name][EMP_POINTS];
   tell_object(tp, "As an employee, you can use the following commands:\n"
     "   clock     - start or finish your working day\n"+
     "   claim     - claim a badge, handbook, or this month's bonus\n"
     "   bank      - set to which bank account you are paid\n"
     "   list      - list the other employees of the shop\n"
     "   promotion - request to be ignored for promotion\n"
     "   resign    - end your employment at the shop\n"+
     board_mess );
   if (employee & SUPERVISOR)
      tell_object( tp, "\nAs a supervisor, you can also use:\n"
        "   chart   - change the information on the sales chart\n"
        "   check   - check cabinet assignments\n"
        "   logs    - review the shop's logs\n" );
   if (employee & MANAGER)
      tell_object( tp, "\nAs a manager you can enter the managers' "
        "office and use the commands listed there.\n" );
   add_succeeded_mess("");
   return 1;
}
string employees_clocked_in()
{
   object *words = ({}), ob;
   if (!num_employees_in()) words = ({"No employees"});
   if (find_object(_shopkeeper) &&
      _employees[_shopkeeper->query_name()][EMP_POINTS] & CLOCKED_IN)
      words = ({_shopkeeper->query_short()});
   foreach (string word in m_indices(_employees))
   {
      ob = find_player(word);
      if (ob && _employees[word][EMP_POINTS] & CLOCKED_IN)
            words += ({ob->query_cap_name()});
   }
   return query_multiple_short(words);
}
private string list_stuff(string word)
{
   string results = "",
          tp = this_player()->query_name();
   if (member_array(word, _retired) != -1) return "\n";
   if (_employees[word][EMP_POINTS] & NPC) return query_worked(word) + "\n";
   if (this_player()->query_creator())
      results = " ["+ (_employees[word][EMP_POINTS] / 32) +"]";
   else if ((word == tp) && !(_employees[word][EMP_POINTS] & MANAGER))
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] /
           32 - SUPER_POINTS)) /
           (MANAGER_POINTS - SUPER_POINTS)) +"%]";
      else
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] / 32)) /
           SUPER_POINTS) +"%]";
   if (this_player()->query_creator() || (_employees[tp][EMP_POINTS] & MANAGER))
      results += query_worked(word);
   return results + "\n";
}

==================================================
FILE: shops/player_shop/office_code/logging.c
==================================================

int do_logs(mixed *args, string pattern)
{
    string start, end, file, *files, words;
    add_succeeded_mess("");
    switch (pattern)
    {
    case LOG_BLANK :
        files = get_dir(_savedir +"general.log*");
        words = "Available logs:\n\n";
        if (sizeof(files))
            words += " 1: current log\n";
        for (int i = sizeof(files); i > 1; i--)
        {
            sscanf(unguarded((: read_file, _savedir + files[i-1], 2, 1 :)),
              "%*s, %s:", start);
            sscanf(unguarded((: read_file, _savedir + files[i-1],
                  file_length(_savedir + files[i-1]), 1 :)),
              "%*s, %s: %*s", end );
            if (start == end)
                words += sprintf("%2d: %s\n",
                  sizeof(files)-(i-2), start);
            else
                words += sprintf("%2d: %s to %s\n",
                  sizeof(files)-(i-2), start, end);
        }
        words += "\nUse \"logs <number>\" to read one of them, or \"logs ";
        if ((_employees[this_player()->query_name()] &&
            _employees[this_player()->query_name()][EMP_POINTS] & MANAGER) ||
          this_player()->query_creator())
        {
            words += "{personnel|accounts|chart}\" to view "
            "those logs.\n";
        }
        else
        {
            words += "chart\" to view that log.\n";
        }
        tell_object(this_player(),"$P$Logs$P$"+ words);
        break;
    case LOG_NUMBER :
        files = get_dir(_savedir +"general.log*");
        if ((args[0] < 1) || (args[0] > sizeof(files)))
        {
            tell_object(this_player(), "There are "+ sizeof(files) +
              " logs.  Use \"logs\".\n");
            return 1;
        }
        if (args[0] == 1)
            sscanf(unguarded((: read_file, _savedir +
                  files[0] :)), "%*s\n%s", words);
        else
            sscanf(unguarded((: read_file, _savedir +
                  files[sizeof(files) - (args[0]-1)] :)), "%*s\n%s", words);
        tell_object(this_player(),"$P$Log "+ args[0]+ "$P$"+ words);
        break;
    case LOG_CHART :
        file = _savedir + "chart.log";
        if (file_size(file) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$Chart log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The chart log is empty.\n");
            return 1;
        }
        break;
    case LOG_MGR :
        file = _savedir + args[0] + ".log";
        if (file_size( file ) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$"+ capitalize(args[0])+
              " log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The "+ args[0]+ " log is empty.\n");
            return 1;
        }
        break;
    }
    return 1;
}
private void employee_log(string employee, string note)
{
    load_history();
    if (!sizeof(_history)) _history = ([employee:({({}),({}),})]);
    else if (!_history[employee]) _history += ([employee:({({}),({}),})]);
    _history[employee][0] += ({time()});
    _history[employee][1] += ({note});
    save_hist();
    remove_call_out(_call_times);
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([ employee:0 ]);
    _times[employee] = time();
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
void shop_log(int logtype, string word, string words, int paid)
{
    string date, month, colour;
    sscanf(amtime(time()), "%*s %*s %*s %s %*s", month);
    if (file_size(_savedir +"general.log") > 0)
    {
        date = ctime(time())[0 .. 9];
        if (date != unguarded((: read_file,
              _savedir +"general.log", 1, 1 :))[0 .. 9])
        {
            string logfile = _savedir +"general.log-"+ time(),
            summary = sprintf( "%sFor the period ending %s:%s\n",
              "%^BOLD%^", amtime(time()), "%^RESET%^" ),
            sign = "";
            _storeroom->force_load();
            call_out((: update_averages() :), 60);
            unguarded((: rename, _savedir +"general.log", logfile :));
            call_out((: review_employees() :), 5 );
            foreach (string item in m_indices(_list))
            {
                summary += sprintf(" %s - Bought %d, Sold %d\n", capitalize(item),
                  _list[item][CHART_BOUGHT], _list[item][CHART_SOLD]);
                _list[item][CHART_AVESALE] = (_list[item][CHART_AVESALE] +
                  _list[item][CHART_SOLD] + random(2)) / 2;
                _list[item][CHART_SOLD] = 0;
                _list[item][CHART_BOUGHT] = 0;
            }
            save_list();
            if (_net_takings < 0)
            {
                _net_takings = -_net_takings;
                sign = "-";
            }
            summary += sprintf("%sThe net takings of the shop were %s%s.%s\n\n",
              "%^BOLD%^", sign, MONEY_HAND->money_value_string(_net_takings,
                _place), "%^RESET%^");
            _net_takings = 0;
            save_me();
            unguarded((: write_file, _savedir +"general.log",
                date +"\n" + summary :));
            foreach (string file in get_dir(_savedir +"general.log-*"))
            {
                sscanf(file, "%*s-%s", date);
                if (time() - to_int(date) > (60*60*24*LOG_DAYS))
                    unguarded((: rm, _savedir + "general.log-"+ date :));
            }
        }
    }
    if (month != _last_month && !_call_review)
    {
        if (member_array(month, ({"Offle", "February", "March",
              "April", "May", "June", "Grune", "August", "Spune",
              "Sektober", "Ember", "December", "Ick"})) != -1)
        {
            _review_month = month;
            remove_call_out(_call_review);
            _call_review = call_out((: monthly_review() :), 60);
        }
    }
    if (_employees[word])
    {
        if (!(_employees[word][EMP_POINTS] & NPC))
            _employees[word][EMP_EOM]++;
        if (paid && _employees[word][EMP_POINTS] & CLOCKED_IN)
        {
            if (_employees[word][EMP_POINTS] & MANAGER)
                _employees[word][EMP_PAY] += (_pay_val * 2);
            else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
              _eom == word)
            {
                _employees[word][EMP_PAY] += to_int(_pay_val * 1.5);
                _employees[word][EMP_POINTS] += 32;
            }
            else
            {
                _employees[word][EMP_PAY] += _pay_val;
                _employees[word][EMP_POINTS] += 32;
            }
        }
        set_emp_time(word);
        save_emps();
    }
    switch (logtype)
    {
    case PURCHASE :
        colour = "%^GREEN%^";
        break;
    case SALE :
        colour = "%^RED%^";
        break;
    case GENERAL :
        colour = "%^CYAN%^";
        break;
    case PERSONNEL :
        log_file(_savedir+ "personnel.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case ACCOUNTS :
        log_file(_savedir+ "accounts.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case CHARTLOG :
        log_file(_savedir+ "chart.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    default :
        colour = "%^RESET%^";
        break;
    }
    unguarded((: write_file, _savedir +"general.log", colour + amtime(time())+
        ": "+ cap_name(word) +"%^RESET%^ - "+ words +"\n" :));
}

==================================================
FILE: shops/player_shop/office_code/masked.c
==================================================

void dest_me()
{
   if (_very_short != UNSET_STR)
   {
      if (remove_call_out(_call_save) != -1) do_save();
      if (remove_call_out(_call_apps) != -1) do_save_applicants();
      if (remove_call_out(_call_hist) != -1) do_save_hist();
      if (remove_call_out(_call_newpols) != -1) do_save_new_policies();
      if (remove_call_out(_call_pols) != -1) do_save_policies();
      if (remove_call_out(_call_times) != -1) save_times();
      if (remove_call_out(_call_emps) != -1) do_save_emps();
   }
   if (_chart) _chart->dest_me();
   if (_board) _board->dest_me();
   if (_notice) _notice->dest_me();
   ::dest_me();
}
void event_death(object killed, object *others, object killer,
  string rmess, string kmess)
{
   if (!killed->query_player() &&
     !(query_employee(killed->query_name()) & NPC)) return;
   if (!killer) return;
   if ((query_employee(killed->query_name()) & NPC)  ||
    (query_employee(killed->query_name())))
   {
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
      foreach(object baddie in others)
         if (baddie->query_player())
            add_baddie(baddie->query_name(),
              "the vicious assault on "+ killed->query_name(),
              _proprietor);
      return;
   }
   if (query_employee(killer->query_name()) & CLOCKED_IN)
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
   if (sizeof(others))
      foreach(object baddie in others)
      {
         if (!baddie->query_player()) continue;
         if (query_employee(baddie->query_name())& CLOCKED_IN)
            add_baddie(baddie->query_name(), "the vicious assault on "+
               killed->query_name(), _proprietor);
      }
}
void event_enter(object ob, string message, object from)
{
   string room;
   if (!from || ob->query_creator() || from == find_object("/room/void") ||
     !ob->query_player()) return;
   room = file_name(from);
   if (room == _counter || room == _shop_front || room == _storeroom ||
     room == _mgr_office || from == this_object()) return;
#ifdef DEBUG
   tell_creator(CREATOR, "%s arrived from %O.\n", ob->query_name(), from);
#endif
   fire_them(_proprietor, ob->query_name(), "for teleporting into the shop");
}
void init()
{
   object tp = this_player();
   string word = tp->query_name();
   ::init();
   if (!tp->query_creator() && !_employees[word] &&
     (member_array(word, _retired) == -1)) return;
   add_command("claim", "{badge|handbook|bonus}", (: do_claim($4[0]) :));
   add_command("resign", "", (: do_resign() :));
   add_command("list", "", (: do_list() :));
   add_command("office", "", (: do_office() :));
   if (!_board) add_command("memo", "", (: do_memo() :));
   if (member_array(word, _retired) != -1) return;
   add_command("clock", "{in|out}", (: do_clock($4[0]) :));
   add_command("bank", ({ "", "<number>" }), (: do_bank($4) :));
   if (!this_player()->query_property("no score"))
      add_command( "promotion", "{on|off}", (: do_promote($4[0]) :) );
   if (!tp->query_creator() &&  !(_employees[word][EMP_POINTS] & SUPERVISOR))
      return;
   add_command("chart", ({CHART_ADDITEM, CHART_REMITEM, CHART_MAXITEM,
      CHART_BUYITEM, CHART_SELLITEM, CHART_ASSIGN_ITEM, CHART_UNASSIGN_ITEM}),
     (: do_chart($4,$5) :));
   add_command("check", "cabinets", (: do_check() :));
   if (!tp->query_creator() && !(_employees[word][EMP_POINTS] & MANAGER))
      add_command( "logs", ({LOG_BLANK, LOG_NUMBER, LOG_CHART}),
      (: do_logs($4,$5) :));
   else
      add_command("logs", ({LOG_BLANK, LOG_NUMBER,
        LOG_MGR}), (: do_logs($4,$5) :));
}
void refresh_function(mixed employee, int flag)
{
   string emp_name;
   switch (flag)
   {
      case PLAYER_DELETED :
        emp_name = employee;
        break;
      case TOTAL_REFRESH :
      case PARTIAL_REFRESH :
        emp_name = employee->query_name();
        break;
   }
   if (query_applicant(emp_name))
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your application at "+ _shop_name+
             " has been removed.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }
   }
   if (member_array(emp_name, _retired) != -1)
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your employment at "+ _shop_name+
             " has been terminated.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }
   }
   if (!_employees[emp_name]) return;
   switch (flag)
   {
      case PLAYER_DELETED :
        shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
        employee_log(emp_name, "Deleted character");
        remove_employee(emp_name);
        break;
      case TOTAL_REFRESH :
        tell_object(employee, "Your employment at "+ _shop_name+
          " has been terminated.\n");
        shop_log(PERSONNEL, emp_name, "refreshed totally", UNPAID);
        employee_log(emp_name, "Refreshed totally");
        remove_employee(emp_name);
        break;
      case PARTIAL_REFRESH :
        tell_object(employee, "Your employment level at "+ _shop_name+
          " has been reset.\n");
        shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
        employee_log(emp_name, "Refreshed character");
        _employees[emp_name] = EMP_MAP;
        set_emp_time(emp_name);
        _got_bonus += ({emp_name});
        save_me();
        break;
   }
}
protected void set_long(string long_desc)
{
   string ob_file = file_name(this_object());
   _chart = clone_object(SHOP_CHART);
   _chart->set_office(ob_file);
   add_hidden_object(_chart);
   _notice = clone_object(SHOP_NOTICE);
   _notice->set_office(ob_file);
   add_hidden_object(_notice);
   long_desc += "Employees may \"clock\" in and out of work here "
     "and examine the items chart.  There is also a policy notice "
     "located next to the chart.\n";
   ::set_long(long_desc);
}

==================================================
FILE: shops/player_shop/office_code/memo.c
==================================================

private int do_memo()
{
   tell_object(this_player(), "Subject: (hit enter for general memo)\n");
   input_to((: write_memo($1) :), 0);
   add_succeeded_mess("");
   return 1;
}
private void end_memo(string text, string subject)
{
   if (!text)
   {
      tell_object(this_player(), "Aborted.\n");
      return;
   }
   tell_object(this_player(), "Do you want to keep a copy of the memo? ");
   input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
private void send_memo(string ans, string subject, string text)
{
   object tp = this_player();
   string *employees = _retired,
          tp_name = tp->query_name();
   tp = this_player();
   tp_name = tp->query_name();
   ans = lower_case(ans);
   if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
   {
      tell_object(tp,
        "Do you want to keep a copy of the memo? (Yes or No)? ");
      input_to((: send_memo($1,$(subject),$(text)) :), 0);
      return;
   }
   if (tp->query_creator() && tp_name != _creator)
      employees += ({tp_name});
   employees += ({_creator});
   foreach(string employee in m_indices(_employees))
      if (!(_employees[employee][EMP_POINTS] & NPC))
         employees += ({employee});
   if (ans[0] == 'n') employees -= ({tp_name});
   if (!sizeof(employees))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
      tell_object(tp, "There is no-one to send a memo to!\n");
      return;
   }
#ifdef DEBUG
   tell_creator(CREATOR, "Sending employee memo to %s.\n",
     implode(employees, "," ));
#endif
   tell_object( tp, "Sending your memo.\n" );
   if (subject && subject != "") subject = " - " + subject;
   else subject = "";
   AUTO_MAILER->auto_mail(implode(employees, ","),
     tp_name, _very_short+ " employee memo" + subject, "", text, 0, 0);
}
private void write_memo(string text)
{
   this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}

==================================================
FILE: shops/player_shop/office_code/personnel.c
==================================================

private void add_employee(string player)
{
    if (!_employees[player])
    {
        _employees += ([player:EMP_MAP]);
        _employees[player][EMP_NOBONUS] = 1;
        set_emp_time(player);
        _got_bonus += ({player});
        save_me();
        save_emps();
    }
}
private void demote(string demoter, string demotee)
{
    int points = _employees[demotee][EMP_POINTS] & CLOCKED_IN;
    if (_employees[demotee][EMP_POINTS] & MANAGER)
        points += (SUPER_POINTS * 32) + EMPLOYEE + SUPERVISOR;
    else points += EMPLOYEE;
    _employees[demotee][EMP_POINTS] = points;
    save_emps();
    PLAYER_SHOP->auto_mail(demotee, _proprietor, "Demotion", "",
      "This is to advise you that you have today been demoted.\n"
      "This demotion will now stay on your employment record.\n");
    employee_log(demotee, "Demoted by "+ demoter);
    shop_log(PERSONNEL, demoter, "demoted "+ cap_name(demotee), PAID);
}
int do_commend(string emp)
{
    string commender;
    if (!_employees[emp])
    {
        tell_object(this_player(), cap_name(emp)+
          " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        tell_object(this_player(), "You can't commend a manager.\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  "
          "You can't commend $C$"+ emp +".\n");
        return 1;
    }
    commender = this_player()->query_cap_name();
    AUTO_MAILER->auto_mail(emp, lower_case(commender), "Commendation",
      "", "This is to advise you that you have today received a "
      "commendation for outstanding service.\nThis will now stay on "
      "your employment record.\n");
    employee_log(emp, "Received a commendation from "+ commender);
    shop_log(PERSONNEL, commender, "commended "+ cap_name(emp), PAID);
    _employees[emp][EMP_POINTS] += (_employees[emp][EMP_POINTS] & SUPERVISOR)?
    to_int(MANAGER_POINTS * 0.05 * 32) : to_int(SUPER_POINTS * 0.05 * 32);
    save_emps();
    tell_object(this_player(), "You commend "+ cap_name(emp)+ ".\n");
    return 1;
}
int do_demote(string emp)
{
    object tp = this_player();
    emp = lower_case(emp);
    if (!_employees[emp])
    {
        tell_object(tp, cap_name(emp)+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER && !tp->query_creator())
    {
        tell_object(tp, "You don't have the authority to "
          "demote $C$"+ emp +".\n");
        return 1;
    }
    if (!( _employees[emp][EMP_POINTS] & SUPERVISOR))
    {
        tell_object(tp, "Don't be silly!  You can't demote $C$"+
          emp +".\n");
        return 1;
    }
    demote(tp->query_cap_name(), emp);
    tell_object(tp, "You demote "+ cap_name(emp)+ ".\n");
    return 1;
}
int do_fire(mixed *args)
{
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(this_player(), cap_name(args[0])+
          " doesn't work at the shop!\n");
        return 1;
    }
    if ((member_array(args[0], _retired) != -1) ||
      query_manager(args[0]) && !this_player()->query_creator())
    {
        tell_object(this_player(), "You don't have the authority "
          "to fire $C$"+ args[0] +".\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  You can't fire $C$"+
          args[0] +".\n");
        return 1;
    }
    fire_them(this_player()->query_name(), args[0], args[1]);
    tell_object(this_player(), "You fire "+ cap_name(args[0])+
      " for "+ args[1]+ ".\n" );
    return 1;
}
int do_leave(mixed *args)
{
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an employee!\n");
        return 1;
    }
    if (args[1] > MAX_LEAVE)
    {
        tell_object(tp, "You cannot place an employee on leave "
          "for more than "+ MAX_LEAVE+ " days at a time.\n");
        return 1;
    }
    _times[args[0]] = time() + (args[1] * 86400);
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
    add_succeeded_mess(cap_name(args[0])+
      " is on leave until "+ ctime(time() + (args[1] * 86400))+ ".\n");
    shop_log(PERSONNEL, tp->query_name(), "placed "+
      cap_name(args[0])+ " on leave for " + args[1]+ " days", PAID);
    employee_log(args[0], "Placed on leave by "+ tp->query_cap_name()+
      " for "+ args[1]+ " days.");
    tell_object(tp, "You place "+ cap_name(args[0])+
      " on leave for " + args[1]+ " days.\n");
    return 1;
}
private int do_promote(string on)
{
    object tp = this_player();
    add_succeeded_mess("");
    if (tp->query_creator())
    {
        tell_object(tp, "Creators don't get promoted.\n");
        return 1;
    }
    switch (on)
    {
    case "off" :
        _employees[tp->query_name()][EMP_NOPROMOTE] = TRUE;
        tell_object(tp, "You have now requested to be "
          "passed over for promotion.\n");
        break;
    case "on" :
        if (tp->query_property("no score"))
        {
            tell_object(tp, "Sorry, you cannot be promoted.\n");
            return 1;
        }
        _employees[tp->query_name()][EMP_NOPROMOTE] = FALSE;
        tell_object(tp, "You have now requested to be "
          "considered for promotion.\n");
        break;
    }
    save_emps();
    return 1;
}
private int do_resign()
{
    string word = this_player()->query_name();
    add_succeeded_mess("$N $V.\n");
    remove_employee(word);
    shop_log(PERSONNEL, word, "resigned", UNPAID);
    employee_log(word, "Resigned");
    return 1;
}
int do_retire()
{
    string manager = this_player()->query_name();
    if (!(_employees[manager][EMP_POINTS] & MANAGER)) return 0;
    remove_employee(manager);
    _retired += ({manager});
    shop_log(PERSONNEL, manager, "retired from management", UNPAID);
    employee_log(manager, "Retired from management");
    save_me();
    add_succeeded_mess("$N retire$s.\n");
    return 1;
}
int do_suspend(mixed *args)
{
    string suspender;
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if ((_employees[args[0]][EMP_POINTS] & MANAGER) &&
      (!tp->query_creator()))
    {
        tell_object(tp, "You don't have the authority to "
          "suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  "
          "You can't suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    suspender = tp->query_cap_name();
    _employees[args[0]][EMP_NOBONUS] = args[1];
    save_emps();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Suspended bonus", "",
      sprintf( "This is to advise you that you have had your bonus "
        "entitlement suspended for %d month%s.\nThis suspension will "
        "now stay on your employment record.\n", args[1],
        (args[1] == 1)?"":"s"));
    employee_log(args[0], sprintf("Bonus suspended for %d month%s by %s",
        args[1], (args[1] == 1)?"":"s", suspender));
    shop_log(PERSONNEL, suspender,
      sprintf("suspended %s's bonus for %d month%s", args[0],
        args[1], (args[1] == 1)?"":"s"), PAID);
    tell_object(tp, "You suspend "+ cap_name(args[0])+
      "'s bonus for "+ args[1]+ " months.\n");
    return 1;
}
int do_warn(mixed *args)
{
    string warner;
    object tp = this_player();
    int points;
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & MANAGER && !tp->query_creator() )
    {
        tell_object( tp, "You don't have the authority to "
          "warn $C$"+ args[0] +".\n" );
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  You can't warn $C$"+ args[0] +".\n");
        return 1;
    }
    warner = tp->query_cap_name();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Official warning", "",
      "This is to advise you that you have today received a formal "
      "warning for " + args[1] + ".\nThis warning will now stay on "
      "your employment record.\n");
    employee_log(args[0], "Received a warning from "+ warner+
      " for "+ args[1]);
    shop_log(PERSONNEL, warner, "warned "+
      cap_name( args[0] ) + " for "+ args[1], PAID);
    points = _employees[args[0]][EMP_POINTS] & CLOCKED_IN;
    if (_employees[args[0]][EMP_POINTS] & SUPERVISOR)
        _employees[args[0]][EMP_POINTS] -= to_int(MANAGER_POINTS * 0.05 * 32);
    else
    {
        _employees[args[0]][EMP_POINTS] -= to_int(SUPER_POINTS * 0.05 * 32) +
        EMPLOYEE;
        if (_employees[args[0]][EMP_POINTS] < 1)
            _employees[args[0]][EMP_POINTS] = EMPLOYEE + points;
    }
    save_emps();
    tell_object(tp, "You warn "+ cap_name(args[0])+ " for "+
      args[1]+ ".\n");
    return 1;
}
private void fire_them(string word, string them, string reason)
{
    if (!_employees[them]) return;
    BANK_HANDLER->adjust_account(them, BANKS[_employees[them][EMP_BANK]][1],
      _employees[them][EMP_PAY]);
    shop_log(ACCOUNTS, _proprietor, "paid "+
      MONEY_HAND->money_value_string(_employees[them][EMP_PAY], _place)+
      " to "+ cap_name(them), UNPAID);
    shop_log(PERSONNEL, word, "fired "+ cap_name(them) +
      " for "+ reason, PAID);
    PLAYER_SHOP->auto_mail(them, word, _shop_name, "",
      "Unfortunately, I have to inform you that you have today "
      "been fired for " + reason + ".  You have been paid the sum of "+
      MONEY_HAND->money_value_string( _employees[them][EMP_PAY], _place )+
      " for the work you have carried out to this date.\nIf you feel you "
      "have been unfairly dismissed, please refer to a manager.\n");
    employee_log(them, "Fired by "+ cap_name(word)+
      " for "+ reason);
    remove_employee(them);
}
private void hire(string word)
{
    int gender;
    remove_applicant(word);
    if (!test_player(word) || _employees[word] || query_baddie(word)) return;
    add_employee(word);
    employee_log(word, "Hired");
    shop_log(PERSONNEL, _proprietor, "hired "+ cap_name(word), UNPAID);
    PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
      "Congratulations!  You've been hired to work at "+ _shop_name+
      ".  You'll find that you can now move through the counter "
      "to the back areas of the shop.  The first things you should "
      "do are \"claim\" a new badge and staff handbook.\n");
    gender = PLAYER_HANDLER->test_gender(word);
    add_board_message("New employee", sprintf("%s has today been employed to "
        "work for the shop.  Please make %s feel welcome, and assist %s while "
        "%s gets started in %s new position.\n", cap_name(word),
        ({"it", "him", "her"})[gender] ,({"it", "him", "her"})[gender],
        ({"it", "he", "she"})[gender], ({"its", "his", "her"})[gender]));
    remove_call_out(_call_mail_hirees);
    _call_mail_hirees = call_out((: mail_hirees() :), 5);
}
private string query_worked(string emp)
{
    string blurb;
    if (_employees[emp][EMP_POINTS] & CLOCKED_IN)
        return " is currently clocked in";
    if (_employees[emp][EMP_POINTS] & NPC)
        return " has gone home for tea";
    if (_times[emp] > time())
        return " - %^CYAN%^on leave until "+ ctime(_times[emp])+ "%^RESET%^";
    blurb = " - last action ";
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        if ((time() - _times[emp]) > ((60*60*24*MGR_DEMOTE)-7))
            blurb += "%^RED%^";
        else if ((time() - _times[emp]) > (60*60*24*MGR_WARN))
            blurb += "%^RED%^";
    }
    else if (_employees[emp][EMP_POINTS] & SUPERVISOR)
    {
        if (( time() - _times[emp]) > ((60*60*24*SPR_DEMOTE)-7))
            blurb += "%^RED%^";
        else if ((time() - _times[emp]) > (60*60*24*SPR_WARN))
            blurb += "%^YELLOW%^";
    }
    else if (( time() - _times[emp]) > ((60*60*24*EMP_FIRE)-7))
        blurb += "%^RED%^";
    else if ((time() - _times[emp]) > (60*60*24*EMP_WARN))
        blurb += "%^YELLOW%^";
    return blurb + ctime(_times[emp])+ "%^RESET%^";
}
private void set_emp_time(string employee)
{
    if (!_employees[employee]) return;
    if (_employees[employee][EMP_INACTIVE])
    {
        _employees[employee][EMP_INACTIVE] = 0;
        save_emps();
    }
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([employee:0]);
    _times[employee] = time();
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
void view_record(string person, string pattern)
{
    if (pattern == VIEW_EMP)
    {
        string text = sprintf("Employment history of %s:\n\n", cap_name(person));
        load_history();
        if (!sizeof(_history) || !_history[person])
        {
            tell_object(this_player(), "There is no history for that person.\n");
            return;
        }
        for(int i = 0; i < sizeof(_history[person][0]); i++)
            text += sprintf("%s: %s\n", ctime(_history[person][0][i]),
              _history[person][1][i]);
        tell_object(this_player(), sprintf("$P$%s's history$P$%s",
            cap_name(person), text));
        clear_history();
    }
    else
    {
        if (!query_applicant(person))
        {
            tell_object(this_player(), "That person has no application form "
              "on file.\n");
            return;
        }
        load_applicants();
        tell_object(this_player(),
          sprintf("$P$%s's history$P$Application of %s:\n\n%s", cap_name(person),
            cap_name(person), _applicants[person][APP_MESSAGE]));
        clear_applicants();
    }
}

==================================================
FILE: shops/player_shop/office_code/policies.c
==================================================

private void add_policy(string policy)
{
   load_policies();
   load_new_policies();
   if (!_policies[policy])
   {
      _policies += ([policy:({"",0})]);
      _policies[policy][0] = _new_policies[policy][POLICY_TEXT];
      _policies[policy][1] = _new_policies[policy][POLICY_TYPE];
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "", "Your proposition has been "
        "accepted by majority vote and is now policy.\n" );
      shop_log(GENERAL, "Shop", "accepted the "+ policy + " policy.", UNPAID);
   }
   else
   {
      map_delete(_policies, policy);
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "",
        "Your proposition to remove the above policy has been accepted "
        "by majority vote.\n");
      shop_log(GENERAL, "Shop", "removed the "+ policy + " policy.", UNPAID);
   }
   map_delete(_new_policies, policy);
   save_policies();
   save_new_policies();
}
void add_policy_suggest(string name, string text, string mgr, int type)
{
   if (previous_object() && previous_object() != find_object(_mgr_office))
   {
      LOG_ERROR("office.c", "add_policy_suggest("+name+","+text+","+mgr+")");
      return;
   }
   load_new_policies();
   if (!sizeof(_new_policies)) _new_policies = ([ name:POLICY_MAP ]);
   else _new_policies += ([ name:POLICY_MAP ]);
   load_policies();
   if (sizeof(_policies) && _policies[name]) text = _policies[name][0];
   _new_policies[name][POLICY_TIME] = time();
   _new_policies[name][POLICY_MGR] = mgr;
   _new_policies[name][POLICY_TEXT] = text;
   _new_policies[name][POLICY_TYPE] = type;
   do_policy_vote(mgr, name, "y");
   clear_policies();
   save_new_policies();
}
private int do_policy_vote(string mgr, string policy, string decision)
{
   int managers;
   load_new_policies();
   if (!m_sizeof(_new_policies) || !_new_policies[policy])
   {
      tell_object(this_player(), "There is no such policy pending!\n");
      return 1;
   }
   if (member_array(mgr, _new_policies[policy][POLICY_FOR]) != -1 ||
     member_array(mgr, _new_policies[policy][POLICY_AGAINST]) != -1 )
   {
      tell_object(this_player(), "You have already voted on this policy!\n");
      return 1;
   }
   if (decision == "y")
   {
      _new_policies[policy][POLICY_FOR] += ({mgr});
      tell_object(this_player(), "You vote for the " + policy+ " policy.\n");
   }
   else
   {
      _new_policies[policy][POLICY_AGAINST] += ({mgr});
      tell_object(this_player(), "You vote against the "+
         policy+ " policy.\n");
   }
   shop_log(GENERAL, mgr, "voted on the "+ policy + " policy.", PAID);
   save_new_policies();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   if (sizeof(_new_policies[policy][POLICY_FOR]) > managers / 2)
      add_policy(policy);
   else if (sizeof(_new_policies[policy][POLICY_AGAINST]) >= managers / 2)
      remove_policy(policy);
   return 1;
}
string get_stock_policy() { return copy(_stock_policy); }
private void remove_policy(string policy)
{
   load_new_policies();
   PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR],
     "Tarnach Fendertwin", "Policy proposition - "+ policy, "",
     "Your proposition has been rejected by majority vote.\n");
   shop_log(GENERAL, "Shop", "rejected the "+ policy + " policy.\n", UNPAID);
   map_delete(_new_policies, policy);
   save_new_policies();
}

==================================================
FILE: shops/player_shop/office_code/review.c
==================================================

private void monthly_review()
{
   int amount = calc_pay(),
       bonus_divisor = 0,
       cabinet_cost = (_num_cabinets - MIN_CABINETS) * CABINET_COST,
       pay;
   float pay_multiplier = 1.0;
   string *emps = m_indices(_employees);
   log_file("/log/PLAYER_SHOP", "%s: %s entered monthly review (review.c)\n",
      ctime(time()), _very_short);
   if (cabinet_cost)
   {
      adjust_profit(_proprietor, -cabinet_cost);
      shop_log(ACCOUNTS, _proprietor,
         "paid "+ MONEY_HAND->money_value_string(cabinet_cost,
         _place) + " for the rent of " + (_num_cabinets - MIN_CABINETS) +
         " cabinets", UNPAID);
   }
   if (_accounts["profit"] < 0) adjust_bonus("Shop",_accounts["profit"]);
   if (amount > _accounts["profit"])
      pay_multiplier = _accounts["profit"] / amount;
   foreach (string word in emps)
   {
      if (!_employees[word][EMP_PAY]) continue;
      pay = to_int(_employees[word][EMP_PAY] * pay_multiplier);
      if (!(_employees[word][EMP_POINTS] & NPC))
      {
         BANK_HANDLER->adjust_account(word,
            BANKS[_employees[word][EMP_BANK]][1], pay );
         PLAYER_SHOP->auto_mail(word, _proprietor, "Pay advice for "+
            _last_month, "", sprintf("For your work during %s, you have been "
            "paid a total of %s.  Keep up the good work.\n--\n%s "
            "(proprietor)\n", _last_month, MONEY_HAND->money_value_string(pay,
            _place ), _proprietor));
      }
      else _employees[word][EMP_POINTS] = EMPLOYEE + NPC;
      shop_log(ACCOUNTS, _proprietor, "paid "+ MONEY_HAND->
        money_value_string(pay, _place)+ " to "+ cap_name(word), UNPAID);
      _employees[word][EMP_PAY] = 0;
      _accounts["profit"] -= pay;
   }
   _bonus += _accounts["bonus"];
   if (_bonus < 0)
   {
      _accounts["bonus"] = _bonus;
      _bonus = 0;
   }
   else _accounts["bonus"] = 0;
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS]) continue;
      if (!test_prop(word, _very_short+ " handbook")) continue;
      if (_employees[word][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
         _eom == word)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) _bonus_val = _bonus;
   else _bonus_val = (_bonus * 2) / bonus_divisor;
   _got_bonus = ({});
   _eom = sort_array(get_employees(),
      (: _employees[$2][EMP_EOM] - _employees[$1][EMP_EOM] :))[0];
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS])
      {
         _employees[word][EMP_NOBONUS]--;
         _got_bonus += ({word});
      }
      _employees[word][EMP_EOM] = 0;
   }
   employee_log(_eom, _last_month+ "'s Employee Of The Month");
   add_board_message("Bonuses for "+ _last_month,
      sprintf("Based on the bonus fund of %s for %s, the following "
      "bonuses have been awarded:\n\n     Managers    - %s\n     Supervisors"
      " - %s\n     Employees   - %s\n\n%s's Employee Of The Month was %s.  "
      "Well done to you.\n", MONEY_HAND->money_value_string(_bonus, _place),
      _last_month, MONEY_HAND->money_value_string(_bonus_val * 2, _place),
      MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
      MONEY_HAND->money_value_string(_bonus_val, _place), _last_month,
      cap_name(_eom)));
   if (_bonus)
   {
      shop_log( ACCOUNTS, _proprietor, "paid out "+
        MONEY_HAND->money_value_string(_bonus, _place)+
        " in bonuses for "+ _last_month, UNPAID );
   }
   if (_eom == _shopkeeper->query_name())
   {
      _bonus -= to_int(_bonus_val * 1.5);
      shop_log(GENERAL, _eom, "claimed "+
         MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
         UNPAID);
   }
   else
   {
      _bonus -= _bonus_val;
      shop_log(GENERAL, _shopkeeper->query_name(), "claimed "+
         MONEY_HAND->money_value_string(_bonus_val, _place), UNPAID);
   }
   if (_bonus < 0) _bonus = 0;
   _last_month = _review_month;
   _call_review = 0;
   save_me();
   save_emps();
}
private void review_employees()
{
   int prom = FALSE,
       prom_number,
       managers,
       time = time();
   string *promos = ({}),
          promopost,
          *emps = _retired + m_indices(_employees);
   log_file("/log/PLAYER_SHOP", "%s: %s entered review_employees (review.c)\n",
      ctime(time()), _very_short);
   foreach (string word in emps)
   {
      if (!test_player(word))
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         fire_them(_proprietor, word, "not existing");
      }
      else if (test_cre(word))
         fire_them(_proprietor, word, "being a creator");
      else if (test_prop(word,"no score") &&
         _employees[word][EMP_POINTS] & SUPERVISOR )
      {
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
         save_emps();
         PLAYER_SHOP->auto_mail(word, _proprietor, "Demotion", "",
         "This is to advise you that, due to you having a creator alt, "
         "you have today been demoted.\n");
         employee_log(word, "Demoted by "+ _proprietor);
         shop_log(PERSONNEL, _proprietor, "demoted "+ cap_name(word), UNPAID);
      }
      if (!test_prop(word, _very_short+ " handbook"))
      {
         _employees[word][EMP_PAY] = 0;
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
      }
   }
   foreach (string word in get_managers())
      if ((time - _times[word]) > (60*60*24*MGR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*MGR_WARN) &&
         !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
           "", "It has come to my attention that you have now been "
           "inactive for over " + MGR_WARN+ " days.  As you are a manager, "
           "you are required to meet certain levels of attendance.  "
           "You are now in serious danger of being demoted without "
           "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
               cap_name(word) + " about inactivity", UNPAID);
      }
   foreach(string word in sort_array(get_supervisors(),
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
      if (time - _times[word] > (60*60*24*SPR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*SPR_WARN) &&
        !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
            "", "It has come to my attention that you have now been "
            "inactive for over "+ SPR_WARN+ " days.  As you are a supervisor, "
            "you are required to meet certain levels of attendance.  "
            "You are now in serious danger of being demoted without "
            "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
            cap_name(word) + " about inactivity", UNPAID);
      }
      else
      {
         prom_number = (_max_emp * PERCENT_M) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * MANAGER_POINTS) &&
           sizeof(get_managers()) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            set_employee(word, MANAGER);
            shop_log(PERSONNEL, _proprietor, "promoted "+
               cap_name(word)+ " to manager", UNPAID);
            employee_log(word, "Promoted to manager");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!",
              "", "Congratulations!  You've been promoted to manager "
              "of "+ _shop_name+ ".  You'll find that you can now enter "
              "the managers' office.  Please remember to use the \"memo\" "
              "facility from there to discuss any major admin points with "
              "other managers.  This includes hiring, firing, and so on.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   foreach(string word in sort_array(get_employees(),
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
   {
      if (_employees[word][EMP_POINTS] & NPC) continue;
      if (time - _times[word] > (60*60*24*EMP_FIRE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         fire_them(_proprietor, word, "serious inactivity");
         continue;
      }
      if (time - _times[word] > (60*60*24*EMP_WARN))
      {
         if (!_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
         {
            PLAYER_SHOP->auto_mail(word, _proprietor, "Inactivity",
              "", "It has come to my attention that you have now been "
              "inactive for over "+ EMP_WARN+ " days.  Unless this "
              "situation is resolved, the management may have no option "
              "but to terminate your employment.\n---\n"+ _proprietor+
              " (proprietor)\n");
            _employees[word][EMP_INACTIVE] = TRUE;
            shop_log(PERSONNEL, _proprietor, "warned "+
              cap_name(word)+ " about inactivity", UNPAID);
            employee_log(word, "Warned about inactivity");
         }
      }
      else
      {
         prom_number = (_max_emp * PERCENT_S) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * SUPER_POINTS) &&
           sizeof( get_supervisors() ) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            if(_employees[word][EMP_POINTS] & CLOCKED_IN)
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR + CLOCKED_IN;
            else
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR;
            shop_log(PERSONNEL, _proprietor, "promoted "+
              cap_name(word)+ " to supervisor", UNPAID);
            employee_log(word, "Promoted to supervisor");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!", "",
              "Congratulations!  You've been promoted to supervisor "
              "of "+ _shop_name+ ".  You will now be able to use your "
              "newly acquired supervisor commands.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   }
   if (prom)
   {
      promopost = "The following employees have been promoted:\n\n";
      foreach (string word in promos)
         promopost += sprintf("     %s has been promoted to %s\n",
           cap_name(word), (_employees[word][EMP_POINTS] & MANAGER)?
           "manager":"supervisor");
      promopost += "\nCongratulations!\n";
      add_board_message("Promotions", promopost);
   }
   foreach (string word in m_indices(_baddies))
      if (time - _baddies[word][BAD_TIME] > (60*60*24*BAN_LENGTH))
         remove_baddie( word );
   foreach (string word in m_indices(_declined))
      if (time - _declined[word] > (60*60*24*DECLINE_LENGTH))
         remove_declined(word);
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
   save_emps();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   load_new_policies();
   if (sizeof(_new_policies))
   {
      foreach (string word in m_indices(_new_policies))
      {
         if (sizeof(_new_policies[word][POLICY_FOR]) > managers / 2)
         {
            add_policy(word);
         }
         else if (time - _new_policies[word][POLICY_TIME] > VOTE_TIMEOUT)
         {
            if (sizeof(_new_policies[word][POLICY_FOR]) >=
               sizeof(_new_policies[word][POLICY_AGAINST]))
            {
               add_policy(word);
            }
            else remove_policy(word);
         }
      }
   }
   clear_new_policies();
   load_history();
   foreach (string word in m_indices(_history))
   {
      if (!test_player(word) || test_cre(word) ||
        !_times[word] || _times[word] < (time - HIST_TIMEOUT))
      {
         map_delete(_times, word);
         map_delete(_history, word);
      }
   }
   save_hist();
   save_times();
}

==================================================
FILE: shops/player_shop/office_code/save.c
==================================================

private void do_save()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving shop data to %s/.\n", _savedir);
#endif
   unguarded((: save_object, _savedir+ "shop_data" :));
}
private void do_save_applicants()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving applications data to %s.\n",
     _savedir+ "applications");
#endif
   unguarded((: write_file, _savedir+ "applications",
     save_variable(_applicants), 1 :));
   clear_applicants();
}
private void do_save_emps()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving employee data to %s.\n",
     _savedir+ "employees");
#endif
   unguarded((: write_file, _savedir+ "employees",
     save_variable(_employees), 1 :));
}
private void do_save_hist()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving history data to %s.\n",
     _savedir+ "history");
#endif
   unguarded((: write_file, _savedir+ "history",
     save_variable(_history), 1 :));
   clear_history();
}
private void do_save_new_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving new policies data to %s.\n",
     _savedir+ "new_policies");
#endif
   unguarded((: write_file, _savedir+ "new_policies",
     save_variable(_new_policies), 1 :));
   _call_newpols_clear = call_out((: _new_policies= 0 :), CLEAR_DELAY);
}
private void do_save_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving policies data to %s.\n",
     _savedir+ "policies");
#endif
   unguarded((: write_file, _savedir+ "policies",
      save_variable(_policies), 1 :));
   clear_policies();
}
private void save_list()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving chart list data to %s.\n",
     _savedir+ "list");
#endif
   unguarded((: write_file, _savedir+ "list",
     save_variable(_list), 1 :));
}
void save_register(mixed *money)
{
   _register = money;
   save_me();
}
private void save_times()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving times data to %s.\n",
     _savedir+ "times");
#endif
   unguarded((: write_file, _savedir+ "times",
     save_variable(_times), 1 :));
}

==================================================
FILE: shops/player_shop/office_code/stock.c
==================================================

void adjust_bought(string item, int amt)
{
   if (previous_object() && previous_object() != find_object(_storeroom))
   {
      LOG_ERROR("office.c", "adjust_bought("+item+","+amt+")");
      return;
   }
   _list[item][CHART_BOUGHT] += amt;
   save_list();
}
void adjust_sold(string item, int amt)
{
   if (previous_object() && previous_object() != find_object(_storeroom))
   {
      LOG_ERROR("office.c", "adjust_sold("+item+","+amt+")");
      return;
   }
   _list[item][CHART_SOLD] += amt;
   save_list();
}
private int do_chart(mixed *args, string pattern)
{
   int number;
   string word = this_player()->query_name();
   if (sizeof(args) > 1) number = args[1];
   if (pattern == CHART_ADDITEM)
   {
      if(query_on_list(args[0]))
      {
         tell_object( this_player(), args[0] +
            " are already on the sales list.\n" );
         return 1;
      }
   }
   else if (!query_on_list(args[0]))
   {
      tell_object(this_player(), args[0] +" are not on the sales list.\n");
      return 1;
   }
   switch (pattern)
   {
   case CHART_ADDITEM :
      add_succeeded_mess("$N put$s "+ args[0] +" on the sales list.\n");
      put_on_list(args[0]);
      shop_log(CHARTLOG, word, "put "+ args[0] +" on the sales list", PAID);
      break;
   case CHART_REMITEM :
      add_succeeded_mess("$N take$s "+args[0] +" off the sales list.\n");
      take_off_list( args[0] );
      shop_log(CHARTLOG, word, "took "+args[0] +" off the sales list", PAID);
      break;
   case CHART_MAXITEM :
      if (number < 1)
      {
         tell_object(this_player(), "Maximum must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the maximum stock of "+ args[0] +" to "+
         number +".\n");
      set_max(args[0], number);
      shop_log(CHARTLOG, word, "set max of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_BUYITEM :
      if (number < 1)
      {
         tell_object(this_player(), "Price must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the buying price of "+ args[0] +" to "+
         number +".\n");
      set_buy(args[0], number);
      shop_log(CHARTLOG, word, "set buy of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_SELLITEM :
      if (number < 1)
      {
         tell_object(this_player(), "Price must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the selling price of "+ args[0] +" to "+
         number +".\n");
      set_sell(args[0], number);
      shop_log(CHARTLOG, word, "set sell of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_ASSIGN_ITEM :
      if (member_array( number, _list[args[0]][CHART_CAB] ) != -1)
      {
         tell_object(this_player(), args[0]+
            " are already assigned to cabinet "+ number+ ".\n");
         return 1;
      }
      if (number < 1 || number > _num_cabinets)
      {
         tell_object(this_player(), "That cabinet does not exist.\n");
         return 1;
      }
      add_chart_cabinet(args[0], number);
      add_succeeded_mess("$N assign$s "+ args[0] +" to use cabinet "+
         number +".\n");
      shop_log(CHARTLOG, word, "assigned "+ args[0] +
         " to cabinet "+ number, PAID);
      break;
   case CHART_UNASSIGN_ITEM :
      if (member_array( number, _list[args[0]][CHART_CAB] ) == -1)
      {
         tell_object(this_player(), args[0]+
            " are not assigned to cabinet "+ number+ ".\n");
         return 1;
      }
      remove_chart_cabinet(args[0], number);
      add_succeeded_mess("$N stop$s "+ args[0] +" using cabinet "+
         number +".\n");
      shop_log(CHARTLOG, word, "unassigned "+ args[0] +
         " from cabinet "+ number, PAID);
      break;
   }
   return 1;
}
private void put_on_list(string word)
{
   if (!_list[word])
   {
      _list[word] = ({5, 0, 20, 25, ({}), 0, 0, 0});
      save_list();
   }
}
int query_ave(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_AVE]);
}
int query_buy(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_BUY]);
}
int query_max(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_MAX]);
}
int query_on_list(string item) { return (!_list[item])?FALSE:TRUE; }
int query_sell(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_SELL]);
}
private void set_buy(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_BUY] = number;
   save_list();
}
private void set_max(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_MAX] = number;
   save_list();
}
private void set_sell(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_SELL] = number;
   save_list();
}
private void take_off_list(string word)
{
   if (!_list[word]) return;
   map_delete(_list, word);
   save_list();
}
private void update_averages()
{
   log_file("/log/PLAYER_SHOP", "%s: %s entered update_averages (stock.c)\n",
      ctime(time()), _very_short);
   foreach (string words in m_indices(_list))
   {
      _list[words][CHART_AVE] = (_list[words][CHART_AVE] +
         query_stock(words) + random(2)) / 2;
   }
   save_list();
}

==================================================
FILE: room/auction_room.c
==================================================

#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
#include <mail.h>
#define COLOUR_ID "colour code"
#define AUCTION_PLAYER_NAME 0
#define AUCTION_PLAYER_BID 1
#define ERRNOSPACE -1
#define ERRBADPARM -2
#define ERRBADCBOB -3
#define ERROBNOMOVE -4
#define ERRGENFAIL -5
#define ERRNORECV -6
#define ERRRECVEMP -7
#define WARNUNDEST -8
#define WARNEXCL -9
#define WARNNOLOTS "NULL"
#define TCTP( x, y ) tell_creator( this_player(), x, y )
#define GECM( x ) "/global/events"->convert_message( x )
#define c_item class item
#define c_store class store
#define c_lot class lot
#define OPEN "open"
#define CLOSED "closed"
#define WAIT_SELLER "waitsell"
#define WAIT_BUYER "waitbuy"
#define WAIT_BUYER_LAPSE "waitbuylapse"
#define WAIT_CRE_INTERVENTION "waitcreint"
#define CHECK_CYCLE 10
#define COLOURS ({ "red", "orange", "yellow", "blue", "green", "indigo",\
  "violet", "crimson", "puce", "emerald", "ochre", "tangerine", "aquamarine",\
  "silver", "gold", "copper", "lilac" })
#define NO_COLOURS sizeof( COLOURS )
nosave inherit "/std/room";
inherit "/global/auto_load";
c_item {
  string name;
  string *alias;
  string *adjectives;
  string long;
  string read_mess;
  string enchant_mess;
}
c_store {
  int case_code;
  string colour;
  string inv_string;
  c_item *inventory;
}
c_lot {
  int case_code;
  c_store assoc_store;
  string seller;
  string status;
  int expiration_time;
  int reserve_price;
  mapping bids;
  mixed *lot_autoload;
  mixed *current_bid;
  string *auto_bids;
  string notes;
  string *excluded;
}
c_lot *lots = ({ });
mapping payments = ([ ]);
int lot_count = 0;
nosave string *used_colours = ({ });
nosave string currency = "default";
nosave string location = "unset";
nosave string shop_name = "REAS Auction Inheritable";
nosave int admin_cost = 2000;
nosave float commission = ( 5.0/100.0 );
mapping cases = ([ ]);
void save_file();
void load_file();
void set_location( string loc );
void set_currency( string cur );
void set_admin_cost( int value );
void set_commission( int percent );
void set_case_desc( string *bits );
mixed recover_lot( mixed lot_autoload );
int change_status( int lot_ident, string new_status );
void adjust_money( int amount, object player );
mixed generate_auto_load( object *obs );
c_store generate_store( object *things, int lot_id );
c_lot query_status( int lot_ident );
int do_deposit( object *things, int auction_time, string time_type,
  string res_price );
int do_bid( string offer, object *boxes );
int do_collect( string pattern );
int do_list();
int do_withdraw( object *boxes);
int do_describe( object *boxes, string int_desc );
int do_exclude( object *cases, string excluded );
int do_browse( object *cases, string target, int identifier );
int do_unexclude( object *cases, string excluded );
string generate_advertising_string( c_lot lot );
string generate_random_adv_str();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) {
       this_object()->setup();
       this_object()->reset();
    }
    call_out( "load_file", 1 );
    call_out( "load_store", 2 );
    call_out( "lot_check", 5 );
}
void init() {
    this_player()->add_command( "bid", this_object(),
      "<string'amount'> {on|for} <indirect:object:here'case'>",
      (: do_bid( $4[0], $1 ) :) );
   this_player()->add_command( "collect", this_object(),
      ({ "successful bids", "money", "expired lots",
        "all" }),
      (: do_collect( $5 ) :) );
    this_player()->add_command( "deposit", this_object(),
      "<indirect:object:me'items'> for <number> "
      "{minute|hour|day} auction" ,
      (: do_deposit( $1, $4[1], $4[2], "" ) :) );
   this_player()->add_command( "deposit", this_object(),
      "<indirect:object:me'items'> for <number> "
      "{minute|hour|day} "
      "auction with [a] reserve price of <string'amount'>",
      (: do_deposit( $1, $4[1], $4[2], $4[3] ) :) );
    this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "browse", this_object(),
       "<string'object'> in <indirect:object'case'>", (: do_browse( $1, $4[0], 0 ) :) );
    this_player()->add_command( "browse", this_object(),
       "<string'object'> <number> in <indirect:object'case'>",
       (: do_browse( $1, $4[0], $4[1] ) :) );
    this_player()->add_command( "withdraw", this_object(),
      "<indirect:object'case'> from auction",
      (: do_withdraw( $1 ) :) );
   this_player()->add_command( "write", this_object(),
      "<string'text'> on <indirect:object'case'>",
      (: do_describe( $1, $4[0] ) :) );
   this_player()->add_command( "exclude", this_object(),
      "<string'name'> from bidding on <indirect:object'case'>",
      (: do_exclude( $1, $4[0] ) :) );
   this_player()->add_command( "exclude", this_object(),
      "list for <indirect:object'case'>",
      (: do_exclude( $1, "list" ) :) );
   this_player()->add_command( "exclude", this_object(),
      "current ignore list from bidding on <indirect:object'case'>",
      (: do_exclude( $1, "ignore list" ) :) );
   this_player()->add_command( "unexclude", this_object(),
      "<string'name'> from bidding on <indirect:object'case'>",
      (: do_unexclude( $1, $4[0] ) :) );
}
int automated_deposit( object *things, int auction_length,
 string function_cb, string object_cb, int res_price,
  string int_desc ) {
  mixed *auto_load_string;
  c_lot temp;
  c_store temp2;
 if ( !sizeof( COLOURS - used_colours ) ) {
#ifdef DEBUG
   log_file( "REAS", "%s: ERRNOSPACE generated by: %s!\n", ctime( time() ),
             (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRNOSPACE;
  }
  if ( !sizeof( things ) || auction_length < 0 ) {
#ifdef DEBUG
    log_file( "REAS", "%s: ERRBADPARM generated by: %s!\n", ctime( time() ),
      (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRBADPARM;
  }
  if ( !objectp( load_object( object_cb ) ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: ERRBADCBOB generated by: %s!\n", ctime( time() ),
      (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRBADCBOB;
  }
 lot_count ++;
  temp2 = generate_store( things, lot_count );
  auto_load_string = generate_auto_load( things );
  if ( !arrayp( auto_load_string ) ) {
   if ( (int) auto_load_string == ERROBNOMOVE ) {
#ifdef DEBUG
      log_file( "REAS", "%s: ERROBNOMOVE generated by: %s!\n", ctime( time() ),
        query_multiple_short( map( things, (: file_name( $1 ) :) ) ) );
#endif
      return ERROBNOMOVE;
    }
#ifdef DEBUG
    log_file( "REAS", "%s: ERRGENFAIL generated by: %s!\n", ctime( time() ),
      query_multiple_short( map( things, (: file_name( $1 ) :) ) ) );
#endif
    return ERRGENFAIL;
    }
   temp = new( c_lot, assoc_store: temp2, case_code: lot_count, seller: "Auto", status: OPEN,
      expiration_time: time() + auction_length, reserve_price: res_price,
      bids: ([ ]), current_bid: allocate( 2 ), lot_autoload: auto_load_string,
      auto_bids: ({ function_cb, object_cb }), notes: int_desc, excluded: ({ }) );
    lots += ({ temp });
   return lot_count;
}
mixed generate_auto_load( object *obs ) {
 object box = clone_object( "/obj/baggage" );
string *temp;
  box->set_name( "box" );
  box->set_long( "This is a box used in the auction room inheritable. "
    "How did you get hold of one?\n" );
  box->set_weight( 500000 );
  box->set_max_weight( 500000 );
  box->set_volume( 500000 );
 if ( sizeof( filter( obs->move( box ), (: $1 != 0 :) ) ) )
   return ERROBNOMOVE;
  temp = create_auto_load( ({ box }), 0 );
  if ( !arrayp( temp ) )
  return ERRGENFAIL;
   obs->dest_me();
   obs -= ({ 0 });
   if ( sizeof( obs ) ) {
#ifdef DEBUG
     log_file( "REAS", "%s: WARNUNDEST generated by object %s.\n", ctime( time() ),
     query_multiple_short( map( obs, (: file_name( $1 ) :) ) ) );
#endif
   }
   box->dest_me();
   return temp;
}
c_store generate_store( object *things, int lot_id ) {
  c_store temp;
  c_item temp2;
  object temp3;
  string *avail_colours = COLOURS - used_colours;
  string _colour = avail_colours[ random( sizeof( avail_colours ) ) ];
  temp = new( c_store, case_code: lot_id, colour: _colour,
    inventory: ({ }), inv_string: GECM( query_multiple_short( things ) ) );
    used_colours += ({ _colour });
  foreach( temp3 in things ) {
    temp2 = new( c_item, name: temp3->query_name(),
    alias: temp3->query_alias(), long: temp3->query_long(),
    read_mess: temp3->query_readable_message(), enchant_mess:
    temp3->enchant_string(), adjectives: temp3->query_adjectives() );
    temp->inventory += ({ temp2 });
    if ( !stringp( temp2->read_mess ) )
      temp2->read_mess = "";
  }
 return temp;
}
void lot_check() {
  c_lot temp_lot;
  c_store current_store;
  object new_case;
  object *all_new_cases = ({ });
  object *obs;
  object *exp_cases;
  int *active_lots;
  string name;
  int *bids;
  cases = filter( cases, (: objectp( $1 ) :) );
  active_lots = map( filter( lots, (: ( (c_lot) $1)->status == OPEN :) ),
   (: ( (c_lot) $1)->case_code :) );
  if ( sizeof( cases ) < sizeof( active_lots ) ) {
    active_lots = active_lots - values( cases );
    foreach( int temp in active_lots ) {
      temp_lot = filter( lots, (: $1->case_code == $(temp) :) )[0];
      current_store = temp_lot->assoc_store;
      new_case = clone_object( "/std/object" );
      new_case->set_name( "case" );
      new_case->set_short( current_store->colour + " case" );
      new_case->set_long( "This is a display case used in this auction shop. "
        "It contains " + current_store->inv_string +".\nYou can \"browse\" these"
        " items.\n" );
      new_case->add_adjective( current_store->colour );
      new_case->move( this_object() );
      new_case->reset_get();
      new_case->add_extra_look( this_object() );
      used_colours += ({ current_store->colour });
      cases += ([ new_case: temp ]);
      all_new_cases += ({ new_case });
    }
    if ( sizeof( all_new_cases ) )
      this_object()->add_new_case( all_new_cases );
  }
  foreach( temp_lot in ( filter( lots, (: $1->expiration_time < time() :) ) ) ) {
    TCTP( "Looking at lot %d. ", temp_lot->case_code );
    TCTP( "Status is: %s\n", temp_lot->status );
    switch( temp_lot->status ) {
      case OPEN:
      TCTP( "In open %s", "\n" );
        current_store = temp_lot->assoc_store;
        exp_cases = filter( cases, (: $2 == $(temp_lot)->case_code :) );
        map( exp_cases, (: this_object()->remove_lot( $1 ) :) );
        if ( sizeof( temp_lot->auto_bids ) ) {
          obs = recover_lot( temp_lot->lot_autoload );
          call_other( temp_lot->auto_bids[1], temp_lot->auto_bids[0],
          temp_lot->case_code, stringp( temp_lot->current_bid[ AUCTION_PLAYER_NAME ] ),
          temp_lot->current_bid[ AUCTION_PLAYER_NAME ],
          temp_lot->current_bid[ AUCTION_PLAYER_BID ], obs );
          temp_lot->status = CLOSED;
          temp_lot->expiration_time = time() + ( 2 * 60 * 60 );
          continue;
        }
        if ( stringp( name = temp_lot->current_bid[ AUCTION_PLAYER_NAME ] ) ) {
          if ( PLAYER_HANDLER->test_user( name ) ) {
            AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!",
            "","Congratulations! You have successfully purchased "+
            current_store->inv_string +" with a bid of "
            + MONEY_HAND->money_value_string( temp_lot->current_bid[ AUCTION_PLAYER_BID ],
            currency )+ ".\n\nYou have one week to collect your items before they are "
            "forfeit.\n", 0, 0 );
          }
          temp_lot->status = WAIT_BUYER;
          temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
          continue;
        }
        case WAIT_BUYER_LAPSE:
        name = temp_lot->seller;
        if (PLAYER_HANDLER->test_user( name ) ) {
          AUTO_MAILER->auto_mail( name, shop_name, "Your unsuccessful sale!",
          "", "Dear "+ capitalize( name ) +",\n\nIt is with some regret that I inform you "
          "that we were unable to sell " + current_store->inv_string +
          ".\n\nYou have one week to collect your items before they are forfeit.\n",
          0, 0 );
        }
        temp_lot->status = WAIT_SELLER;
        temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
        continue;
      case WAIT_SELLER:
        name = temp_lot->seller;
        if ( PLAYER_HANDLER->test_user( name ) ) {
          AUTO_MAILER->auto_mail( name, shop_name, "Your unsuccessful sale!",
          "", "Dear "+ name +",\n\nAs you have not collected your items within "
          "7 days, they have been disposed of.\n\nHave a nice day.\n",
         0, 0 );
        }
        temp_lot->status = CLOSED;
        temp_lot->expiration_time = time() + ( 2 * 60 * 60 );
        continue;
    case WAIT_BUYER:
      name = temp_lot->current_bid[ AUCTION_PLAYER_NAME ];
      if ( PLAYER_HANDLER->test_user( name ) ) {
        AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!",
        "","Dear " + name +",\nBecause you have not picked up your items, "+
        "they have been sold to another client.\n\nHave a nice day.", 0, 0 );
      }
      map_delete( temp_lot->bids, name );
      if ( sizeof( temp_lot->bids ) == 0 ) {
        temp_lot->status = WAIT_BUYER_LAPSE;
        temp_lot->expiration_time = time() + ( 2 * 60 * 60 );
        continue;
      }
      bids = sort_array( values( temp_lot->bids ), -1 );
      TCTP( "bids is %O.\n", bids );
      name = filter( temp_lot->bids, (: $2 == $(bids[0]) :) );
      temp_lot->current_bid[ AUCTION_PLAYER_NAME ] = name;
      temp_lot->current_bid[ AUCTION_PLAYER_BID ] = bids[0];
      if ( PLAYER_HANDLER->test_user( name ) ) {
        AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!",
        "","Congratulations! You have successfully purchased "+
        current_store->inv_string +" with a bid of "
        + MONEY_HAND->money_value_string( temp_lot->current_bid[ AUCTION_PLAYER_BID ],
        currency )+ ".\n\nYou have one week to collect your items before they are "
        "forfeit.\n", 0, 0 );
      }
      temp_lot->status = WAIT_BUYER;
      temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
      continue;
    case WAIT_CRE_INTERVENTION:
#ifdef DEBUG
      log_file("REAS", "%s: Lot %d is still waiting for manual intervention!\n",
        ctime( time() ), temp_lot->case_code );
#endif
      temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
      continue;
      case CLOSED:
        TCTP( "In closed %s", "" );
        lots -= ({ temp_lot });
#ifdef DEBUG
        log_file( "REAS", "%s: Closed lot %d\n", ctime( time() ), temp_lot->case_code );
#endif
        continue;
    }
  }
  call_out( "lot_check", CHECK_CYCLE );
  return ;
}
int do_deposit( object *things, int auction_time, string time_type, string res_price ) {
  mixed *auto_load_string;
  c_lot temp;
  c_store temp2;
 int value;
  int finishtime;
 if ( auction_time <= 0 || ( time_type == "day" && auction_time > 10 )
    || ( time_type == "minute" && auction_time > 59 ) ||
    ( time_type == "hour" && auction_time > 23 ) ) {
      this_player()->add_failed_mess( this_object(),
        "That's not a valid length.\n" );
      return 0;
  }
  if ( sizeof( res_price ) ) {
   value = MONEY_HAND->value_from_string( res_price, currency );
    if ( value == 0 ) {
      this_player()->add_failed_mess( this_object(),
        res_price +" isn't a valid reserve price.\n" );
      return 0;
    }
  }
 if ( !sizeof( COLOURS - used_colours ) ) {
    this_player()->add_failed_mess( this_object(), "The auction house "
      "doesn't have any display cases left to auction your item.\n" );
    return 0;
  }
  switch( time_type ) {
    case "minute":
      if ( auction_time < 5 ) {
        this_player()->add_failed_mess( this_object(),
          "Auctions must go for at least 5 minutes.\n" );
        return 0;
      }
      finishtime = time() + ( auction_time * 60 );
      break;
    case "hour":
       finishtime = time() + ( auction_time * 60 * 60 );
       break;
    case "day":
      if ( auction_time > 14 ) {
        this_player()->add_failed_mess( this_object(),
          "Auction can not go for longer then two weeks.\n" );
        return 0;
      }
      finishtime = time() + ( auction_time * 60 * 60 * 24 );
      break;
    default:
       return 0;
 }
  foreach( object tmp in things ) {
    if ( base_name( tmp ) == "/obj/money.c" ) {
      this_player()->add_failed_mess( this_player(), "You can't auction money.\n" );
      things->move( this_player(), "" );
      filter( things, (: environment( $1 ) != this_player() :) )->
        move( environment( this_player() ),  "$N falls to the floor!\n" );
      return 0;
    }
  }
  lot_count ++;
  temp2 = generate_store( things, lot_count );
  auto_load_string = generate_auto_load( things );
  if ( !arrayp( auto_load_string ) ) {
    this_player()->add_failed_mess( this_player(), "You can't auction that.\n" );
    things->move( this_player(), "" );
    filter( things, (: environment( $1 ) != this_player() :) )->
      move( environment( this_player() ),  "$N falls to the floor!\n" );
    return 0;
 }
  temp = new( c_lot, assoc_store: temp2, case_code: lot_count, seller: this_player()->query_name(),
    status: OPEN, expiration_time: finishtime, reserve_price: value,
    bids: ([ ]), current_bid: allocate( 2 ), lot_autoload: auto_load_string,
    auto_bids: ({ }), notes: "", excluded: ({ }) );
  lots += ({ temp });
 if ( strlen( res_price ) )
    this_player()->add_succeeded_mess( this_object(), "$N $V "+
    temp2->inv_string + " for "+ add_a( query_num( auction_time, 5000 ) ) +
    " " + time_type + " auction, with a reserve price of "+
      MONEY_HAND->money_value_string( value, currency ) +".\n" );
  else
    this_player()->add_succeeded_mess( this_object(), "$N $V "+
    temp2->inv_string +" for a "+ query_num( auction_time, 5000 ) +
    " " + time_type + " auction, with no reserve price.\n" );
    TCTP( "Generated lot %d.\n", lot_count );
    return 1;
}
int do_list() {
  c_lot *_lots;
  c_lot _lot;
  string str;
  if ( !sizeof( cases ) ) {
    write( "There is nothing up for auction in this store.\n" );
    return 1;
  }
  str = "Items currently for auction:\n" ;
  foreach( object _case in keys( cases ) ) {
    _lots = filter( lots, (: $1->case_code == $( cases[ _case ] ) :) );
    if ( !sizeof( _lots ) ) continue;
    _lot = _lots[0];
    str +=  "$I$6=   " +
      capitalize( _lot->assoc_store->colour + " case" ) + ": " +
      _lot->assoc_store->inv_string;
    if (_lot->current_bid[AUCTION_PLAYER_NAME]) {
       str += "; bid: "+ MONEY_HAND->money_value_string(
        _lot->current_bid[1], currency ) + ", by " +
        capitalize(_lot->current_bid[ AUCTION_PLAYER_NAME ] ) +".\n";
    } else {
       str += ", no bid yet.\n";
    }
  }
  write("$P$Auctions$P$" + str);
  return 1;
}
void remove_lot( object ob ) {
  if ( member_array( ob, keys( cases ) ) == -1 )  {
    return;
  }
  map_delete( cases, ob );
  ob->dest_me();
  return;
}
int do_bid( string offer, object *boxes ) {
c_lot temp;
c_lot *temps;
c_store temp2;
object box;
int value;
 if ( sizeof( boxes ) > 1 ) {
    this_player()->add_failed_mess( this_object(),
      "You can only $V on one case at "
      "a time.\n" );
    return 0;
  }
  box = boxes[0];
  if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(),
      "$I isn't being auctioned here.\n", ({ box }) );
    return 0;
  }
  temps = filter_array( lots, (: $1->case_code == cases[ $(box) ] :) );
  temp = temps[0];
  temp2 = temp->assoc_store;
  if ( temp->status != OPEN ) {
    this_player()->add_failed_mess(this_object(),
      "The bidding on this item is finished.\n" );
    return 0;
  }
  if ( member_array( this_player()->query_name(),
       temp->excluded ) != -1 ) {
    write( "You have been excluded from bidding on this object.\n" );
    return WARNEXCL;
  }
  if ( !classp( temp2 ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Open lot without store! Lot code: %d.\n",
      ctime( time() ), temp->case_code );
#endif
    write( "Something has gone wrong. Please fetch a liaison post haste!\n" );
    printf( "Your lot code is: %d.\n", temp->case_code );
    temp->status = WAIT_CRE_INTERVENTION;
    temp->expiration_time = time() + ( 7 * 24 * 60 * 60 );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
  }
  value = MONEY_HAND->value_from_string( offer, currency );
  if ( value == 0 ) {
        this_player()->add_failed_mess( this_object(),
          offer +" isn't worth anything here.\n" );
        return 0;
  }
 if ( this_player()->query_value_in( currency ) < value ) {
   this_player()->add_failed_mess( this_object(), "You don't "
     "have that much.\n" );
   return 0;
 }
 if ( temp->reserve_price != 0 && value < temp->reserve_price ) {
   this_player()->add_failed_mess( this_object(),
     "The reserve price for this lot is "+
     MONEY_HAND->money_value_string( temp->reserve_price, currency ) +".\n" );
     return 0;
 }
  if ( value < 400 ) {
   this_player()->add_failed_mess( this_object(),
     "You must bid at least "+
     MONEY_HAND->money_value_string( 400, currency ) + ".\n" );
     return 0;
 }
 if ( sizeof( temp->current_bid ) &&
   temp->current_bid[ AUCTION_PLAYER_BID ] >= value ) {
   this_player()->add_failed_mess(this_object(),
     "Someone else has already bid more than that.\n");
   return 0;
 }
 if ( sizeof( temp->current_bid ) &&
   ( ( value - temp->current_bid[ AUCTION_PLAYER_BID ] ) <
     ( temp->current_bid[ AUCTION_PLAYER_BID ] / 20 ) ) ) {
     this_player()->add_failed_mess( this_object(), "You must bid 5% "
     "more then the current bid.\n" );
   return 0;
 }
 temp->bids[ this_player()->query_name() ] = value;
 temp->current_bid[0] = this_player()->query_name();
 temp->current_bid[1] = value;
 this_player()->add_succeeded_mess(this_object(),
   "$N $V "+ offer +" for "+ temp2->inv_string +".\n" );
 return 1;
}
int do_browse( object *boxes, string target, int identifier ) {
object box;
c_store container;
c_item temp;
mapping contents = ([ ]);
string *names = ({ });
mixed *longadj = ({ });
string temp2;
mixed *contenders;
string *contender;
string *adjectives;
string name;
string word;
int keep_flag;
 if ( sizeof( boxes ) > 1 ) {
    this_player()->add_failed_mess( this_object(),
      "You can only $V one case at a time.\n" );
    return 0;
  }
  box = boxes[0];
 if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(),
      "$I isn't being auctioned here.\n", ({ box }) );
    return 0;
  }
  container = filter( lots, (: $1->case_code == cases[ $(box) ] :) )[ 0 ]->assoc_store;
  TCTP( "The case code for this case is: %d.\n", container->case_code );
  foreach( temp in container->inventory ) {
    names = temp->alias + ({ temp->name });
    names = uniq_array( names );
    longadj = ({ temp->long + temp->read_mess +
      ( this_player()->query_see_octarine() ? temp->enchant_mess : "" ),
      temp->adjectives });
    foreach( temp2 in names ) {
      if ( arrayp( contents[ temp2 ] ) )
        contents[ temp2 ] += ({ longadj });
      else
        contents[ temp2 ] = ({ longadj });
    }
  }
  adjectives = explode( target, " " );
    name = adjectives[ sizeof( adjectives ) - 1 ];
    adjectives -= ({ name });
  TCTP( "Search Name: %s ", name );
  TCTP( "Search Adj: %O.\n", adjectives );
  if ( !arrayp( contents[ name ] ) ) {
    this_player()->add_failed_mess( this_object(),
      "There is nothing like that in the case.\n" );
    return 0;
 }
  contenders = contents[ name ];
  if ( sizeof( contenders ) == 1 ) {
    contender = contenders[0];
    this_player()->add_succeeded_mess( this_player(),
     "$N $V "+ target +" in $I.\n", ({ box }) );
    call_out( (: tell_object( this_player(),
      $(GECM( contender[0]) ) ) :) );
    return 1;
  }
  if ( identifier != 0 ) {
    if ( identifier > sizeof( contenders ) ) {
     this_player()->add_failed_mess( this_player(),
        "There are only " + sizeof( contenders ) +
        " " + pluralize( target ) + " in $I.\n", ({ box }) );
       return 0;
      }
    this_player()->add_succeeded_mess( this_player(),
      "$N $V "+ add_a( target ) +" in $I.\n", ({ box }) );
    call_out( (: tell_object( this_player(),
      GECM( $(contenders[ identifier - 1 ][0]) ) ) :), 0 );
    return 1;
  }
  if ( !sizeof( adjectives ) ) {
    this_player()->add_failed_mess( this_object(),
      "There are "+ sizeof( contenders ) +" objects like that in the case.\n" );
    return 0;
 }
  foreach ( contender in contenders ) {
    keep_flag = 0;
    foreach( word in contender[ 1 ] ) {
      if ( member_array( word, adjectives ) != -1 )
        keep_flag = 0;
      continue;
    }
    if ( !keep_flag )
      contenders -= ({ contender });
    continue;
  }
  if ( !sizeof( contenders ) ) {
    this_player()->add_failed_mess( this_object(),
      "There is nothing matching "+ target +" in the case.\n" );
    return 0;
  }
  if ( sizeof( contenders ) > 1 ) {
     this_player()->add_failed_mess( this_object(),
       "There are " + sizeof( contenders ) + " items like that in the case. "
       "Please specify which one you want to browse.\n" );
     return 0;
  }
  contender = contenders[0];
  this_player()->add_succeeded_mess( this_player(),
    "$N peruse "+ add_a( target ) +" in $I.\n", ({ box }) );
  call_out( (: tell_object( this_player(),
    GECM( $(contender[0]) ) ) :), 0 );
  return 1;
}
void adjust_money( int amount, object player ) {
    object money;
    if ( amount < 0 ) {
        player->pay_money(MONEY_HAND->create_money_array(-amount, currency ));
        return;
    }
    money = MONEY_HAND->create_money_array( amount, currency );
    player->adjust_money( money, currency );
}
void load_file() {
    if ( !stringp( location ) ) return;
    if ( file_size( location +".o" ) < 0 ) return;
    unguarded( (: restore_object, location :) );
    return;
}
void save_file() {
    if ( location == "unset" ) return;
    unguarded( (: save_object, location :) );
    return;
}
void set_shop_name( string _name ) { shop_name = _name; }
void set_save_path( string path ) { location = path; }
void set_currency( string cur ) { currency = cur; }
void set_admin_cost( int value ) { admin_cost = value; }
void set_commission( int percent ) { commission = percent/100.0; }
mapping query_payments() { return payments; }
void dest_me() {
    save_file();
    if ( sizeof( cases ) ) keys( cases )->dest_me();
    ::dest_me();
}
mixed recover_lot( mixed lot_autoload ) {
  object *boxes;
  object *stuff;
  boxes = load_auto_load_to_array( lot_autoload, this_player() );
  if ( !objectp( boxes[0] ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Could not recover: %O.\n", ctime( time() ),
      lot_autoload );
#endif
    return ERRNORECV;
  }
  stuff = all_inventory( boxes[ 0 ] );
  if ( !sizeof( stuff ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Recovered case as empty: %O.\n", ctime( time() ),
      lot_autoload );
#endif
    return ERRRECVEMP;
  }
  call_out( (: $(boxes)->dest_me() :), 5 );
  return stuff;
}
int do_withdraw( object *boxes ) {
object box;
c_lot *_lots;
object *obs;
  if ( sizeof( boxes ) > 1  ) {
    this_player()->add_failed_mess( this_object(),
      "You can only $V on one case at "
      "a time.\n" );
      return 0;
  }
  box = boxes[0];
  if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(),
      "$I isn't being auctioned here.\n", boxes );
    return 0;
  }
  _lots = filter( lots, (: $1->case_code == cases[ $(box) ] :) );
  if ( this_player()->query_name() != _lots[0]->seller &&
    !this_player()->query_creator() ) {
     this_player()->add_failed_mess( this_player(), "This isn't your "
       "lot to withdraw!\n" );
     return 0;
  }
  _lots[0]->status = CLOSED;
  _lots[0]->expiration_time = time() + ( 2 * 60 * 60 );
  obs = recover_lot( _lots[0]->lot_autoload );
  if ( !arrayp( obs ) ) {
    write( "Something has gone wrong. Please fetch a liaison post haste!\n" );
    printf( "Your lot code is: %d.\n", _lots[0]->case_code );
    _lots[0]->status = WAIT_CRE_INTERVENTION;
    _lots[0]->expiration_time = time() + ( 7 * 24 * 60 * 60 );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
  }
  obs->move( this_player(), "You collect $N." );
  filter( obs, (: environment( $1 ) != this_player() :) )->
    move( environment( this_player() ), "$N falls to the floor!\n" );
  this_object()->remove_lot( box );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}
int do_describe( object *boxes, string int_desc ) {
    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(),
          "You can only $V on one case at "
          "a time.\n" );
        return 0;
    }
    box = boxes[0];
    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }
    code = cases[ box ];
    _lots = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    _lot = _lots[0];
    if ( this_player()->query_name() != _lot->seller &&
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to describe!\n" );
        return 0;
    }
    _lot->notes = int_desc;
    printf( "You neatly letter %s on the case.\n", int_desc );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
string extra_look( object ob ) {
    c_lot temp, *temp2;
    mixed bid_info;
    string ret;
    int code;
    if ( member_array( ob, keys( cases ) ) == -1 ) return "";
    code = cases[ ob ];
    temp2 = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( temp2 ) != 1 ) return sizeof( temp2 ) +" found in lot array!\n";
    temp = temp2[0];
    bid_info = temp->current_bid;
    ret = "";
    if ( !stringp( bid_info[ AUCTION_PLAYER_NAME ] ) ) {
        if ( temp->reserve_price ) {
          ret += "Reserve price is: ";
          ret += MONEY_HAND->money_value_string( temp->reserve_price, currency );
          ret += ".\n";
        }
        else
            ret += "No bid as of yet.\n";
    }
    else
      ret += "The current bid is "+ MONEY_HAND->money_value_string(
        bid_info[1], currency ) + ", made by "+ capitalize(
        bid_info[ AUCTION_PLAYER_NAME ] ) +".\n";
    ret += "The bidding on this lot stops at "+ amtime( temp->expiration_time )+
      ".\n";
    if ( sizeof( temp->notes ) ) {
      ret += "Neatly lettered on the case is: ";
      ret += temp->notes;
      ret += ".\n";
    }
    return ret;
}
int do_collect( string pattern ) {
    int amount;
    c_lot _lot, *_lots = ({ }), *_exp_lots;
    object *items = ({ });
    _exp_lots = filter( lots, (: ((c_lot)$1)->status != OPEN :) );
    _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != CLOSED :) );
    _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != WAIT_CRE_INTERVENTION :) );
    if ( pattern == "all" ) {
        do_collect( "money" );
        do_collect( "successful bids" );
        do_collect( "expired lots" );
        return 1;
    }
    if ( pattern == "money" ) {
      _lots = filter( lots, (: ( $1->seller == $2 ) &&
        ( stringp( $1->current_bid[ AUCTION_PLAYER_NAME ] ) ) :),
        this_player()->query_name() );
      if ( undefinedp( payments[ this_player()->query_name() ] ) ) {
        if ( sizeof( _lots ) ) {
          foreach( c_lot tempy in _lots ) {
            write( capitalize( tempy->current_bid[ AUCTION_PLAYER_NAME ] ) +
              " must pay for the items they bid on before you can collect "
              "the money for them! They have until "+ amtime( tempy->expiration_time )+".\n" );
            }
       }
      }
      if ( undefinedp( payments[ this_player()->query_name() ] ) ) {
        write( "You aren't owed any money!\n" );
        return 0;
      }
      amount = payments[ this_player()->query_name() ];
      adjust_money( amount - to_int( amount * commission ), this_player() );
      printf( "You recieve %s, minus %s commission.\n",
        MONEY_HAND->money_value_string( amount, currency ),
        MONEY_HAND->money_value_string( to_int( amount * commission ),
        currency ) );
      map_delete( payments, this_player()->query_name() );
      this_player()->add_succeeded_mess( this_object(),
        "$N $V some money from $D.\n" );
      save_file();
      return 1;
    }
    if ( pattern == "successful bids" ) {
        _lots = filter( _exp_lots,
          (: $1->current_bid[ AUCTION_PLAYER_NAME ] == $2 :),
          this_player()->query_name() );
        if ( !sizeof( _lots ) ) {
            write( "You aren't expecting any bids!\n" );
            return 0;
        }
        foreach( _lot in _lots )
          amount += _lot->current_bid[ 1 ];
        if ( this_player()->query_value_in( currency ) < amount ) {
            printf( "You have %d %s waiting, for a total cost of %s.\n"
              "You don't have enough money.\n",
              sizeof( _lots ),
              sizeof( _lots ) > 1 ? "lots" : "lot",
              MONEY_HAND->money_value_string( amount, currency ) );
            this_player()->add_failed_mess( this_object(), "" );
            return 0;
        }
        adjust_money( -amount, this_player() );
        foreach( _lot in _lots ) {
          items += recover_lot( _lot->lot_autoload );
          if ( undefinedp( payments[ _lot->seller ] ) )
            payments[ _lot->seller ] = _lot->current_bid[ AUCTION_PLAYER_BID ];
          else
            payments[ _lot->seller ] += _lot->current_bid[ AUCTION_PLAYER_BID ];
          _lot->status = CLOSED;
          _lot->expiration_time = time() + ( 2 * 60 * 60 );
        }
        items->move( this_player(), "You collect $N." );
        filter( items, (: environment( $1 ) != this_player() :) )->
          move( environment( this_player() ), "$N falls to the floor!\n" );
        printf( "You had %d %s waiting, for a total cost of %s.\nYou "
          "hand over the money.\n", sizeof( _lots ),
          sizeof( _lots ) > 1 ? "lots" : "lot",
          MONEY_HAND->money_value_string( amount, currency ) );
        return 1;
    }
    if ( pattern == "expired lots" ) {
        _lots = filter( _exp_lots,
          (: !stringp( $1->current_bid[ AUCTION_PLAYER_NAME ] ) &&
            $1->seller == $2 :), this_player()->query_name() );
        if ( !sizeof( _lots ) ) {
            this_player()->add_failed_mess( this_object(), "You aren't expecting "
              "any items.\n" );
            return 0;
        }
        amount = admin_cost * sizeof( _lots );
        if ( this_player()->query_value_in( currency ) < amount ) {
            printf( "You have %d %s waiting, for a total administration "
              "cost of %s.\n"
              "You don't have enough money.\n",
              sizeof( _lots ),
              sizeof( _lots ) > 1 ? "lots" : "lot",
              MONEY_HAND->money_value_string( amount, currency ) );
            return 0;
        }
        adjust_money( -amount, this_player() );
        foreach( _lot in _lots ) {
          items += recover_lot( _lot->lot_autoload );
          if ( undefinedp( payments[ _lot->seller ] ) )
            payments[ _lot->seller ] = _lot->current_bid[ AUCTION_PLAYER_BID ];
          else
            payments[ _lot->seller ] += _lot->current_bid[ AUCTION_PLAYER_BID ];
          _lot->status = CLOSED;
          _lot->expiration_time = time() + ( 2 * 60 * 60 );
        }
        items->move( this_player(), "You collect $N." );
        filter( items, (: environment( $1 ) != this_player() :) )->
          move( environment( this_player() ), "$N falls to the floor!\n" );
        printf( "You had %d %s waiting, for a total administration "
          "cost of %s.\n"
          "You hand over the money.\n",
          sizeof( _lots ), sizeof( _lots ) > 1 ?
          "lots" : "lot",
          MONEY_HAND->money_value_string( amount, currency ) );
        return 1;
    }
}
int do_exclude( object *boxes, string excluded ) {
    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    string *ignored = this_player()->query_property( "ignoring" );
    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(),
          "You can only $V people from one case at "
          "a time.\n" );
        return 0;
    }
    box = boxes[0];
    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }
    code = cases[ box ];
    _lots = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    _lot = _lots[0];
    if ( this_player()->query_name() != _lot->seller &&
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to exclude people from!\n" );
        return 0;
    }
    if ( excluded == "list" ) {
      if ( !sizeof( _lot->excluded ) )
        write( "No one is being excluded from bidding on this lot.\n" );
      else
        write( query_multiple_short( _lot->excluded ) + " is being excluded from "
          "bidding on this lot.\n" );
      return 1;
    }
    if ( excluded != "ignore list" ) {
      if ( member_array( excluded, _lot->excluded ) != -1 ) {
        write( excluded + " is already excluded from this lot.\n" );
        return 1;
      }
      if ( !PLAYER_HANDLER->test_user( excluded ) )
        return notify_fail( excluded +" is not a player here!\n" );
      else  {
        _lot->excluded += ({ excluded });
        _lot->excluded = uniq_array( _lot->excluded );
        write( excluded +" will not be allowed to bid on "+
          query_multiple_short( boxes ) +".\n" );
        return 1;
      }
    }
    if ( !arrayp( ignored ) || !sizeof( ignored ) ) {
      write( "You aren't ignoring anyone!\n" );
      return 1;
    }
    _lot->excluded += ignored;
    _lot->excluded = uniq_array( _lot->excluded );
    write( query_multiple_short( ignored ) + " will not be allowed to bid on "+
      query_multiple_short( boxes ) +".\n"  );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
int do_unexclude( object *boxes, string excluded ) {
    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(),
          "You can only $V people from one case at "
          "a time.\n" );
        return 0;
    }
    box = boxes[0];
    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }
    code = cases[ box ];
    _lots = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    _lot = _lots[0];
    if ( this_player()->query_name() != _lot->seller &&
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to unexclude people from!\n" );
        return 0;
    }
    if ( member_array( excluded, _lot->excluded ) == -1 ) {
      if ( !sizeof( _lot->excluded ) ) {
        write( "No one is excluded from bidding on this case!\n" );
        return 1;
      }
      write( "Only "+ query_multiple_short( _lot->excluded ) +
        ( sizeof( excluded ) == 1 ? " is " : " are " ) +
        " being excluded from bidding on this case!\n" );
      return 1;
    }
    _lot->excluded -= ({ excluded });
    write( capitalize( excluded ) + " is now allowed to bid on this case.\n" );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
c_lot find_spec_lot( int pos ) { return lots[ pos ]; }
string generate_advertising_string( c_lot lot ) {
  string c_string;
  if ( intp( lot->current_bid[ 0 ] ) && ( lot->current_bid[ 0 ] ) )
    c_string = MONEY_HAND->money_value_string( lot->current_bid[ 0 ], currency );
  else
    if ( intp( lot->reserve_price ) && lot->reserve_price )
      c_string = MONEY_HAND->money_value_string( lot->reserve_price, currency );
    else
     c_string = "make an offer";
  if ( c_string == "make an offer" )
    return lot->assoc_store->inv_string + ", " + c_string +
    " but hurry, bidding stops at " + amtime( lot->expiration_time );
  return lot->assoc_store->inv_string + ", currently going for " + c_string +
    " but hurry, bidding stops at " + amtime( lot->expiration_time );
}
string generate_random_adv_string() {
c_lot temp;
  if ( sizeof( lots ) ) {
    temp = lots[ random( sizeof( lots ) ) ];
    if ( temp->status != OPEN )
      return WARNNOLOTS;
    else return generate_advertising_string( temp );
  }
  else
    return WARNNOLOTS;
}

==================================================
FILE: room/basic_room.c
==================================================

#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <weather.h>
#include <nroff.h>
inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";
inherit "/std/basic/effects";
nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string long_exit_mxp;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *_exits;
nosave object item;
private nosave object chatter;
nosave object sitchanger;
nosave object linker;
nosave object terrain;
nosave object wall;
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;
private nosave string *variablelongs;
private nosave mixed variablechats;
private nosave mixed variableitems;
private nosave int is_day = -1;
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
private void setup_room_chat( );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );
protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;
   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   effects::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   _exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
               catch(replace_program(fname));
           }
         }, 0, inhs[0]);
      }
   }
}
int query_is_room()
{
  return 1;
}
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }
  return enchant_level;
}
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }
  if (previous_object()==this_object()) {
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
}
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
}
void set_background_enchant( int number ) {
  background_enchant = number;
}
void set_dynamic_enchant( float number ) {
  dynamic_enchant = number;
  enchant_time = time();
}
int query_background_enchant() {
  return background_enchant;
}
float query_dynamic_enchant() {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
}
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
}
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
}
void flush_co_ord() {
    co_ord = 0;
    co_ord_calculated = 0;
}
int query_co_ord_calculated() { return co_ord_calculated; }
string query_long_exit() { return long_exit; }
string query_long_exit_mxp() { return long_exit_mxp; }
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    long_exit_mxp = mxp_expire("Exits") + "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ] + ".";
    long_exit_mxp = mxp_expire("Exits") +
                    "There is one obvious exit: "+ mxp_tag("Exit", words[ 0 ], 1) + ".";
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
    long_exit_mxp = mxp_expire("Exits") +
      "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( map(words, (: mxp_tag("Exit", $1, 1) :) ) ) +
      ".";
  }
}
string query_theft_handler() { return theft_handler; }
void set_theft_handler( string word ) { theft_handler = word; }
string *query_aliases() { return copy( aliases ); }
void add_alias( mixed names, string word ) {
  string name;
  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
}
void remove_alias( mixed names, string word ) {
  int i;
  string name;
  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );
    }
  }
}
string *query_exits() { return copy(_exits); }
void reset_exits() { _exits = ({ }); }
object query_item() { return item; }
object query_chatter() { return chatter; }
object query_situation_changer() { return sitchanger; }
object query_linker() { return linker; }
object query_terrain() { return terrain; }
object query_wall() { return wall; }
object *query_hidden_objects() { return hidden_objects + ({ }); }
int add_hidden_object( object thing ) {
  if ( !hidden_objects ) {
    hidden_objects = ({ });
  }
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
}
int remove_hidden_object( object thing ) {
  int i;
  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
}
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
}
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
}
object* query_use_internal_objects() {
   return _use_internal_objects;
}
varargs mixed query_door_control( string direc, string name ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   if (name) {
      return door_control[ direc + " " + name ];
   }
   return door_control[ direc ];
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
}
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
}
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
}
string query_destination( string exit ) {
   int i;
   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
}
int test_add( object thing, int flag ) { return 1; }
int test_remove( object thing, int flag, mixed dest ) { return 1; }
int add_weight( int number ) { return 1; }
int query_no_writing() { return 1; }
int query_decay() { return 10; }
int query_day() { return is_day; }
int attack_speed() { return 15; }
string query_dark_mess() {
  mixed dark_mess;
  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
}
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
}
string query_bright_mess() {
  mixed bright_mess;
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
}
void set_bright_mess( string word ) { add_property( "bright mess", word ); }
mixed query_room_size() {
   mixed room_size;
   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
}
int *query_room_size_array() {
   mixed room_size;
   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
}
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
}
int id( string word ) { return 0; }
string expand_alias( string word ) {
   int i;
   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
}
string calc_short_exit_string() {
   int i, add;
   string *words;
   int pos;
   string tmp_dir;
   mixed tmp;
   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               pos = strsrch(dest_other[i], " ");
               if (pos != -1) {
                  tmp_dir = dest_other[i][pos + 1..];
                  tmp = SHORTEN[tmp_dir];
                  if (tmp) {
                     tmp_dir = tmp;
                  }
                  words += ({ dest_other[i][0..pos] + tmp_dir });
               } else {
                  words += ({ dest_other[i] });
               }
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
}
string query_short_exit_string() {
   string tmp;
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
}
string enchant_string() {
   string words;
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
}
string long( string word, int dark ) {
   string ret;
   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = mxp_tag("RoomDesc", this_object()->query_dark_mess(), this_player()) +"\n";
      } else {
         ret = mxp_tag("RoomDesc", this_object()->query_bright_mess(), this_player()) +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ mxp_tag("RoomName", a_short(), this_player()) +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +
           mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }
      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret = mxp_tag("RoomDesc", ret, this_player());
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
         mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
         +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return mxp_secure(this_player()) + ret + mxp_open(this_player());
}
string pretty_short( object thing ) {
   int dark;
   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
}
int query_visibility() {
   return 100;
}
int can_use_for_co_ords(string other) {
   return 1;
}
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
  mixed* std_orders = STD_ORDERS;
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
       continue;
    }
    if ( other->query_do_not_use_coords()) {
       continue;
    }
    if (stringp(other) && other[0..2] == "/w/") {
       continue;
    }
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }
    if (!other_co_ord[0] && !other_co_ord[1] && !other_co_ord[2]) {
      continue;
    }
    if (!can_use_for_co_ords(other)) {
       continue;
    }
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, std_orders);
      }
    }
    if (j == -1) {
      j = member_array( dest_other[ i ], std_orders );
      if ( j == -1 ) {
        continue;
      }
    }
    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += std_orders[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
}
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;
   _exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, _exits ) == -1 ) {
         _exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            _exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, _exits ) == -1 ) {
               _exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
}
void init() {
  object ob;
  int i;
  if(this_player() && interactive(this_player())) {
    if(((!last_visited && uptime() > 1800 + random(3600)) ||
      (last_visited && (time() - last_visited > random(900) + 900)))) {
      if(clonep(this_object()))
        this_player()->adjust_xp(random(random(50)), 0);
      else
        this_player()->adjust_xp(random(random(500)), 0);
    }
    last_visited = time();
  }
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    setup_room_chat();
  }
  if(chatter) {
    chatter->check_chat();
  }
  if(sitchanger) {
    sitchanger->check_situations();
  }
  if(!sizeof(_exits)) {
    calc_exits();
  }
  if(!pointerp(co_ord)) {
    this_object()->calc_co_ord();
  }
  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }
  if (this_player() && userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }
  if(item) {
    item->init();
  }
}
string *query_zones() {
  string *zones;
  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
}
void add_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
}
void remove_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      return;
   } else {
      zones -= ({ zone });
   }
   add_property( "room zone", zones );
}
void set_zone( string zone ) {
   add_zone(zone);
}
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
}
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;
   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   stuff = ROOM_HANDLER->query_door_type( type, direc,
                                                         dest );
   if ( stuff ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      if (door_control[ direc ]->query_door_name()) {
         door_control[ dest + " " + door_control[ direc ]->query_door_name()] = direc;
      } else {
         door_control[ dest ] = direc;
      }
   }
   if ( find_call_out( "calc_exits" ) == -1 ) {
      call_out( "calc_exits", 1 );
   }
   long_exit = 0;
   short_exit = 0;
   return 1;
}
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
         if (door_control[ direc ]->query_door_name()) {
            door_control[ data[ j + 1 ] + " " + door_control[ direc ]->query_door_name()] = direc;
         }
       }
       break;
     case "door name" :
       if ( objectp( door_control[ direc ] ) ) {
          map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
          door_control[ direc ]->set_door_name( data[ j + 1 ] );
          door_control[ door_control[ direc ]->query_dest() + " " + data[ j + 1 ]] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "lock owner" :
       if ( objectp( door_control[ direc ] ) ) {
          door_control[ direc ]->set_lock_owner( data[ j + 1 ] );
       }
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_closed();
         } else {
            door_control[ direc ]->set_open();
         }
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_open();
         } else {
            door_control[ direc ]->set_closed();
         }
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] + " " +
                                   door_control[ direc ]->query_door_name() );
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         map_delete( door_control, direc );
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
       }
       break;
     case "no follow" :
       if (data[j + 1]) {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 1;
       } else {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 0;
       }
       break;
     }
   }
   return 1;
}
int remove_exit( string direc ) {
  int i;
  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
}
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
}
int query_relative( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
}
string query_look( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
}
mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
}
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
}
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() )[4..18], (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
}
int query_last_visited() { return last_visited; }
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }
  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
}
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
}
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
}
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
}
int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
}
void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
}
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
}
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
}
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
}
void dest_me() {
  object thing;
  if ( file_name( this_object() ) != ROOM_VOID ) {
    foreach( thing in all_inventory( this_object() ) ) {
      if ( userp( thing ) ) {
        thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
        continue;
      }
      thing->dest_me();
    }
  }
  if ( chatter )
    chatter->dest_me();
  if ( sitchanger )
    sitchanger->dest_me();
  if ( linker )
    linker->destruct_shadow( linker );
  if ( terrain )
    terrain->destruct_shadow( terrain );
  if(wall)
    wall->destruct_shadow(wall);
  if ( item )
    item->dest_me();
  if(door_control)
    foreach(thing in keys(door_control))
      if(objectp(thing))
        catch(thing->dest_me());
  if ( sizeof( hidden_objects ) )
    foreach( thing in hidden_objects ) {
      if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
        catch( thing->dest_me() );
    }
  destruct( this_object() );
}
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
}
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (this_object()->query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
}
int real_clean() {
   object thing;
   foreach ( thing in all_inventory( this_object() ) ) {
     if(thing->query_property("transient")) {
       if(thing->query_property("hospital"))
         thing->move(thing->query_property("hospital"), "$N wander$s in.",
                     "$N wander$s out.");
       else
         thing->move("/room/rubbish", "$N wander$s in.", "$N wander$s out.");
     }
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
}
int filter_inventory(object item, object looker) {
  return item && item->short(0) && (!looker || item->query_visible(looker));
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }
   if (looker && userp(looker)) {
      things = filter(things, "filter_inventory", this_object(), looker);
   }
   if ( item ) {
      things += ({ item });
   }
   return things;
}
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;
  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(implode(map(sign_name[1..], (: explode($1, " ")[<1] :)),
           (: $1 | ({ $2 }) :), ({ })));
    sign->add_plural(implode(map(sign_name[1..],
           (: pluralize(explode($1, " ")[<1]) :)), (: $1 | ({ $2 }) :), ({ })));
    sign->add_adjective(implode(map(sign_name[1..],
           (: explode($1, " ")[0..<2] :)), (: $1 | ({ $2 }) :), ({ })));
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else {
    hidden_objects += ({ sign });
    bits = sign->query_adjectives();
    if (sizeof(bits) > 0)
      sign->set_short(implode(bits, " ") + " " + sign->query_name());
    else
      sign->set_short(sign->query_name());
  }
  return sign;
}
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
}
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
}
string query_door( mixed dest, string name ) {
   int i;
   string direc;
   mixed bing;
   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if (name) {
      bing = door_control[ dest + " " + name];
      if (!bing) {
         bing = door_control[ dest ];
      }
   } else {
      bing = door_control[ dest ];
   }
   if ( bing ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
}
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
}
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}
void add_room_chats( string *new_chats ) {
  if (chatter) {
    chatter->add_room_chats( new_chats );
  }
}
void remove_room_chats( string *dead_chats ) {
  if (chatter) {
    chatter->remove_room_chats( dead_chats );
  }
}
mixed *query_room_chats() {
  if (chatter) {
    return chatter->query_room_chats();
  }
  return 0;
}
private void setup_room_chat() {
  mixed* chats;
  if (!chatter) {
    chatter = clone_object( CHATTER_OBJECT );
    if(base_name(this_object()) == "/d/sur/Maps/basic_rooms/plains/plains")
      log_file("CHATTER", "%s cloned chatter: %O\n",
               file_name(this_object()), chatter);
  }
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if (!variablechats) {
    variablechats = allocate(3);
  }
  if (is_day) {
    chats = variablechats[ROOM_DAY_INDEX];
  } else {
    chats = variablechats[ROOM_NIGHT_INDEX];
  }
  if (!chats) {
    chats = variablechats[ROOM_DEFAULT_INDEX];
  } else if (variablechats[ROOM_DEFAULT_INDEX]) {
    chats[2] += variablechats[ROOM_DEFAULT_INDEX][2];
  }
  chatter->setup_chatter( this_object(), chats );
}
varargs void room_chat( mixed *args, object chatobj ) {
   if (!args)  {
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
   if (!chatter && objectp(chatobj)) {
     chatter = chatobj;
   }
   if (!variablechats) {
      variablechats = allocate(3);
   }
   variablechats[ROOM_DEFAULT_INDEX] = args;
   setup_room_chat();
}
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );
  } else if (objectp(changer)) {
    sitchanger = changer;
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
}
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
}
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
}
void start_situation(int label, int do_start_mess) {
  if (sitchanger)
    sitchanger->start_situation( label, do_start_mess );
}
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
}
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger)
    return sitchanger->change_situation(label,duration,words,0);
  return 0;
}
varargs void automate_situation( mixed label, mixed duration, mixed when,
    mixed chance, mixed category ) {
  if (sitchanger)
    sitchanger->automate_situation(label,duration,when,chance,category);
}
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
}
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
}
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
}
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
}
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + effects::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
}
void set_day_long( string str ) {
  if(!variablelongs) {
    variablelongs = allocate(2);
  }
  variablelongs[ROOM_DAY_INDEX] = str;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    set_long(str);
  }
}
string query_day_long() {
   if(variablelongs && strlen(variablelongs[ROOM_DAY_INDEX]))
     return variablelongs[ROOM_DAY_INDEX];
   return this_object()->query_long();
}
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[ROOM_NIGHT_INDEX] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_NIGHT_INDEX)
    set_long(str);
}
string query_night_long() {
   if(variablelongs && strlen(variablelongs[ROOM_NIGHT_INDEX]))
     return variablelongs[ROOM_NIGHT_INDEX];
   return this_object()->query_long();
}
private string return_long(mixed desc) {
  int ma;
  if(!pointerp(desc))
    return (string)desc;
  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  return (string)desc[ma+1];
}
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[ROOM_DAY_INDEX] += ({ the_item, return_long(desc) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_DAY_INDEX)
    return add_item(shorts, desc, no_plural);
  return 1;
}
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[ROOM_NIGHT_INDEX] += ({ the_item, return_long( desc ) });
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX)  {
    return add_item(shorts, desc, no_plural);
  }
  return 1;
}
void room_day_chat(mixed *args) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  variablechats[ROOM_DAY_INDEX] = args;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    setup_room_chat();
  }
}
void room_night_chat( mixed *args ) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  variablechats[ROOM_NIGHT_INDEX] = args;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX) {
    setup_room_chat();
  }
}
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
}
mixed* query_room_night_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_NIGHT_INDEX];
  }
  return ({ });
}
mixed* query_room_day_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_DAY_INDEX];
  }
  return ({ });
}
mixed* query_room_default_chats() {
   if (sizeof(variablechats)) {
      return variablechats[ROOM_DEFAULT_INDEX];
   }
   return ({ });
}
mixed* query_day_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_DAY_INDEX];
  }
  return ({ });
}
mixed* query_night_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_NIGHT_INDEX];
  }
  return ({ });
}

==================================================
FILE: room/basic_room_new.c
==================================================

#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <twilight.h>
#include <nroff.h>
inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";
nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *exits;
nosave object item;
nosave object chatter;
nosave object sitchanger;
nosave object effects;
nosave object linker;
nosave object terrain;
nosave object wall;
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;
nosave string *variablelongs;
nosave mixed variablechats;
nosave mixed variableitems;
nosave int is_day = -1;
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
varargs void room_chat( mixed *args, object chatobj );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );
protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;
   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
             replace_program(fname);
           }
         }, 0, inhs[0]);
      }
   }
}
int query_is_room()
{
  return 1;
}
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }
  return enchant_level;
}
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }
  if (previous_object()==this_object()) {
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
}
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
}
void set_background_enchant( int number ) {
  background_enchant = number;
}
void set_dynamic_enchant( float number ) {
  dynamic_enchant = number;
  enchant_time = time();
}
int query_background_enchant() {
  return background_enchant;
}
float query_dynamic_enchant() {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
}
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
}
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
}
int query_co_ord_calculated() { return co_ord_calculated; }
string query_long_exit() { return long_exit; }
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ];
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
  }
}
string query_theft_handler() { return theft_handler; }
void set_theft_handler( string word ) { theft_handler = word; }
string *query_aliases() { return copy( aliases ); }
void add_alias( mixed names, string word ) {
  string name;
  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
}
void remove_alias( mixed names, string word ) {
  int i;
  string name;
  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );
    }
  }
}
string *query_exits() { return copy(exits); }
void reset_exits() { exits = ({ }); }
object query_item() { return item; }
object query_chatter() { return chatter; }
object query_situation_changer() { return sitchanger; }
object query_effects() { return effects; }
object query_linker() { return linker; }
object query_terrain() { return terrain; }
object query_wall() { return wall; }
object *query_hidden_objects() { return hidden_objects + ({ }); }
int add_hidden_object( object thing ) {
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
}
int remove_hidden_object( object thing ) {
  int i;
  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
}
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
}
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
}
object* query_use_internal_objects() {
   return _use_internal_objects;
}
varargs mixed query_door_control( string direc ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   return door_control[ direc ];
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
}
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
}
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
}
string query_destination( string exit ) {
   int i;
   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
}
int test_add( object thing, int flag ) { return 1; }
int test_remove( object thing, int flag, mixed dest ) { return 1; }
int add_weight( int number ) { return 1; }
int query_no_writing() { return 1; }
int query_decay() { return 10; }
int attack_speed() { return 15; }
string query_dark_mess() {
  mixed dark_mess;
  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
}
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
}
string query_bright_mess() {
  mixed bright_mess;
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
}
void set_bright_mess( string word ) { add_property( "bright mess", word ); }
mixed query_room_size() {
   mixed room_size;
   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
}
int *query_room_size_array() {
   mixed room_size;
   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
}
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
}
int id( string word ) { return 0; }
string expand_alias( string word ) {
   int i;
   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
}
string calc_short_exit_string() {
   int i, add;
   string *words;
   mixed tmp;
   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               words += ({ dest_other[i] });
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
}
string query_short_exit_string() {
   string tmp;
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
}
string enchant_string() {
   string words;
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
}
string long( string word, int dark ) {
   string ret;
   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = this_object()->query_dark_mess() +"\n";
      } else {
         ret = this_object()->query_bright_mess() +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ a_short() +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +long_exit
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }
      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
        long_exit +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return ret;
}
string pretty_short( object thing ) {
   int dark;
   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
}
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
      continue;
    }
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, STD_ORDERS);
      }
    }
    if (j == -1) {
      j = member_array( dest_other[ i ], STD_ORDERS );
      if ( j == -1 ) {
        continue;
      }
    }
    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += STD_ORDERS[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
}
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;
   exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, exits ) == -1 ) {
         exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, exits ) == -1 ) {
               exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
}
void init() {
  object ob;
  int i;
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    if(variablechats)
      room_chat(variablechats[is_day]);
  }
  if(chatter)
    chatter->check_chat();
  if(sitchanger)
    sitchanger->check_situations();
  if(!sizeof(exits))
    calc_exits();
  if(!pointerp(co_ord))
    this_object()->calc_co_ord();
  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }
  if (userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }
  if(item)
    item->init();
}
string *query_zones() {
  string *zones;
  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
}
void add_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
}
void set_zone( string zone ) {
   add_zone(zone);
}
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
}
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;
   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   if ( ( stuff = (mixed *)ROOM_HANDLER->query_door_type( type, direc,
                                                         dest ) ) ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      door_control[ dest ] = direc;
   }
   if ( find_call_out( "calc_exits" ) == -1 )
      call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
   return 1;
}
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_closed() :
           door_control[ direc ]->set_open();
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_open() :
           door_control[ direc ]->set_closed();
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         door_control = m_delete( door_control, direc );
         door_control = m_delete( door_control,
                                  dest_other[ i + 1 ][ ROOM_DEST ] );
       }
       break;
     }
   }
   return 1;
}
int remove_exit( string direc ) {
  int i;
  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
}
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
}
int query_relative( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
}
string query_look( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
}
mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
}
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
}
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() ), (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
}
void event_exit(object ob, string message, object to) {
    if(interactive(ob))
    last_visited = time();
}
int query_last_visited() { return last_visited; }
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }
  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
}
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
}
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
}
void add_effect( string eff, mixed arg ) {
   effects = clone_object( "/std/shadows/misc/effects" );
   effects->setup_shadow( this_object() );
   effects->add_effect( eff, arg );
}
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
}
int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
}
void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
}
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
}
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
}
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
}
void dest_me() {
   int in_armoury, in_void;
   object thing, *things;
   if ( file_name( this_object() ) == ARMOURY )
      in_armoury = 1;
   if ( file_name( this_object() ) == ROOM_VOID )
      in_void = 1;
   if ( !in_void ) {
      things = all_inventory( this_object() );
      foreach( thing in things ) {
         if ( userp( thing ) ) {
            thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
            continue;
         }
         if(thing->cleaning_room())
           continue;
         thing->move("/room/rubbish");
      }
   }
   if ( chatter )
      chatter->dest_me();
   if ( sitchanger )
      sitchanger->dest_me();
   if ( effects )
      effects->destruct_shadow( effects );
   if ( linker )
      linker->destruct_shadow( linker );
   if ( terrain )
      terrain->destruct_shadow( terrain );
   if(wall)
     wall->destruct_shadow(wall);
   if ( item )
      item->dest_me();
   if(door_control)
     foreach(thing in keys(door_control))
       if(objectp(thing))
         catch(thing->dest_me());
   if ( sizeof( hidden_objects ) )
      foreach( thing in hidden_objects ) {
         if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
           catch( thing->dest_me() );
      }
   destruct( this_object() );
}
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
}
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
}
int real_clean() {
   object thing;
   foreach ( thing in all_inventory( this_object() ) ) {
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }
   if (looker && userp(looker)) {
      things = filter(things, (: $1 && $1->short(0) &&
                              (!$2 || $1->query_visible($2)) :), looker);
   }
   if ( item ) {
      things += ({ item });
   }
   return things;
}
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;
  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(sign_name[1..]);
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else hidden_objects += ({ sign });
  return sign;
}
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
}
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
}
string query_door( mixed dest ) {
   int i;
   string direc;
   mixed bing;
   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if ( bing = door_control[ dest ] ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
}
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
}
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}
void add_room_chats( string *new_chats ) {
  if (chatter) chatter->add_room_chats( new_chats );
}
void remove_room_chats( string *dead_chats ) {
 if (chatter) chatter->remove_room_chats( dead_chats );
}
mixed *query_room_chats() {
  if (chatter) return chatter->query_room_chats();
  return 0;
}
varargs void room_chat( mixed *args, object chatobj ) {
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
  if ( chatter ) {
    chatter->setup_chatter( this_object(), args );
    return;
  }
  if (objectp(chatobj)) chatter = chatobj;
  else chatter = clone_object( CHATTER_OBJECT );
  chatter->setup_chatter( this_object(), args );
}
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );
  } else if (objectp(changer)) {
    sitchanger = changer;
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
}
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
}
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
}
void start_situation(int label, int do_start_mess) {
  if (sitchanger)
    sitchanger->start_situation( label, do_start_mess );
}
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
}
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger)
    return sitchanger->change_situation(label,duration,words,0);
  return 0;
}
varargs void automate_situation( mixed label, mixed duration, mixed when,
    mixed chance, mixed category ) {
  if (sitchanger)
    sitchanger->automate_situation(label,duration,when,chance,category);
}
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
}
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
}
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
}
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
}
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
}
void set_day_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[DAY] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    set_long(str);
}
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[NIGHT] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    set_long(str);
}
string query_night_long() {
   if(variablelongs && strlen(variablelongs[NIGHT]))
     return variablelongs[NIGHT];
   return this_object()->query_long();
}
private string return_long(mixed desc) {
  int ma;
  if(!pointerp(desc))
    return (string)desc;
  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  return (string)desc[ma+1];
}
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[DAY] += ({ the_item, return_long(desc) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    return add_item(shorts, desc, no_plural);
  return 1;
}
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[NIGHT] += ({ the_item, return_long( desc ) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    return add_item(shorts, desc, no_plural);
  return 1;
}
void room_day_chat(mixed *args) {
  if(!variablechats)
    variablechats = allocate(2);
  variablechats[DAY] = args;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    room_chat(args);
}
void room_night_chat( mixed *args ) {
  if(!variablechats)
    variablechats = allocate(2);
  variablechats[NIGHT] = args;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    room_chat(args);
}
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
}

==================================================
FILE: room/bath_house_inside.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/bath_house";
void create() {
    basic_room::create();
    bath_house::create();
}
void init() {
    basic_room::init();
    bath_house::init();
}

==================================================
FILE: room/bath_house_outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/inherit/bath_house";
void create() {
    bath_house::create();
    outside::create();
}
void init() {
    outside::init();
    bath_house::init();
}

==================================================
FILE: room/club_control_room.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/club_control_room";
void create() {
    do_setup++;
    basic_room::create();
    club_control_room::create();
    do_setup--;
    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
}
void init() {
    basic_room::init();
    club_control_room::init();
}

==================================================
FILE: room/complaints_room.c
==================================================

inherit "/std/room/inherit/complaints_room";
inherit "/std/room/basic_room";
void create() {
    add_help_file("complaints_room");
    do_setup++;
    basic_room::create();
    do_setup--;
    set_not_replaceable( 1 );
    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
}
void init() {
    complaints_room::init();
    basic_room::init();
}

==================================================
FILE: room/council_archive.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>
void create() {
   ::create();
   add_help_file("council_archive");
}
string query_case_short(class nomic_case the_case) {
   string ret;
   ret = "Case #" + the_case->id + " \"" +
         the_case->short + "\" opened by " + the_case->opener +
         " against " + query_multiple_short(the_case->people) + " at " +
         ctime(the_case->time_opened);
   return ret;
}
int do_list_all_cases() {
   int* cases;
   string ret;
   int id;
   cases = NOMIC_HANDLER->query_closed_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   ret = "Currently closed cases:\n";
   foreach (id in cases) {
      ret += "$I$5=$C$Case #" + id;
      ret += "\n";
   }
   this_player()->more_string(ret, "closed cases");
   return 1;
}
int do_list_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   ret = "";
   the_case = NOMIC_HANDLER->query_closed_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " +
                event->mess + "\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "closed case");
   return 1;
}
int do_list_citizens() {
    object* cits;
    string ret;
    string area;
    area = this_object()->query_council_area();
    cits = filter( users(), (: NOMIC_HANDLER->is_citizen_of(
       this_object()->query_council_area(), $1->query_name() ) &&
       $1->query_visible( this_player() ) :) );
    cits = sort_array(cits, (: strcmp($1->query_name(), $2->query_name()) :));
    ret = "The online citizens (and magistrates) of " + area + " are:\n\n";
    ret += query_multiple_short(cits);
    write("$P$Citizens Online$P$" + ret);
    return 1;
}
void init() {
   add_command("list", "", (: do_list_all_cases() :));
   add_command("list", "[case] <number>", (: do_list_case($4[0]) :));
   add_command("list", "citizens", (: do_list_citizens() :));
}
