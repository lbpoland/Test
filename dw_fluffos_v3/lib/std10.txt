
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/living.no_eff_shad.c ===
#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/crafts.c ===
private mixed _processes;
void create() {
   _processes = ([ ]);
}
mapping query_processes() {
   return _processes;
}
mapping query_processes_nocase() {
  mapping lc_processes = ([]);
  filter( this_object()->query_processes(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_processes );
  return lc_processes;
}
int add_process(string name, string ob) {
   _processes[name] = ob;
   return 1;
}
int remove_process(string name) {
  string process, name_lc;
  name_lc = lower_case(name);
  foreach (process in keys(_processes)) {
     if (lower_case(process) == name_lc) {
        map_delete(_processes, process);
     }
  }
  return 1;
}
string query_process( string word ) {
   return _processes[word];
}
protected void reset_processes() {
   _processes = ([ ]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/nationality/pumpkin.c ===
inherit "/std/nationality/basic";
void setup() {
   set_name( "pumpkin" );
   set_information( "Pumpkin is a large orange ball shaped town.\n");
   add_region( "round",
               "Pumpkins which are round.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/round");
   add_region( "square",
               "Sto Lat is the second biggest city in the Morporkian kingdom, "
               "it sits on the river Ankh on the way to the Carrack "
               "Mountains.  It is a harder starting location than "
               "Ankh-Morpork but close enough that it is not that much of an "
               "issue.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/square");
   set_language("pumpkin");
   set_currency_area("Pumpkin");
   set_default_start_location("/d/am/buildings/drum/mendeddrum");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/nationality/basic.c ===
inherit "/std/basic/setup";
class region {
   string description;
   string start_location;
   string accent_ob;
}
private string _name;
private string _information;
private string _same_nat_description;
private string _different_nat_description;
private string _start_loc;
private string _language;
private string _accent;
private string _currency;
private mapping _regions;
void create() {
   _regions = ([ ]);
   do_setup();
}
void add_region(string name, string description, string start, string accent) {
   class region bing;
   bing = new(class region,
              description : description,
              start_location : start,
              accent_ob : accent);
   _regions[name] = bing;
}
void set_name(string name) {
   _name = name;
}
string query_name() {
   return _name;
}
void set_same_nationality_description(string description) {
   _same_nat_description = description;
}
string query_same_nationality_description() {
   return _same_nat_description;
}
void set_different_nationality_description(string description) {
   _different_nat_description = description;
}
string query_different_nationality_description() {
   return _different_nat_description;
}
string query_look_description(object person, object looker) {
   return "";
   if (person->query_nationality() == looker->query_nationality()) {
      return capitalize(person->query_pronoun()) + " " +
             _same_nat_description;
   } else {
      return capitalize(person->query_pronoun()) + " " +
             _different_nat_description;
   }
}
void set_default_start_location(string start_loc) {
   _start_loc = start_loc;
}
string query_default_start_location() {
   return _start_loc;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
void set_information(string info) {
   _information = info;
}
string query_information() {
	if (!_information) {
      _information = "The $C$" + query_name() + " nationality is yet to "
                     "be described.\n";
   }
   return _information;
}
string* query_regions() {
   return keys(_regions);
}
string query_region_description(string region) {
   return _regions[region]->description;
}
string query_region_start_location(string region) {
   return _regions[region]->start_location;
}
string query_start_location(string region) {
   if (_regions[region] && _regions[region]->start_location) {
      return _regions[region]->start_location;
   }
   return _start_loc;
}
string query_region_accent_ob(string region) {
   if (_regions[region]) {
      return _regions[region]->accent_ob;
   }
   return 0;
}
void set_currency_area(string area) {
   _currency = area;
}
string query_currency_area() {
   return _currency;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/nationality/accents/accent_base.c ===
#define NATIONAL_ACCENT_PATH "/std/nationality/accents/national/"
mapping accent_lang_map = ([
   "Pumpkin" : "pumpkin",
   ]);
string query_nat_accent( string lang ) {
   return NATIONAL_ACCENT_PATH + lang;
}
string national_garble( string mess, object person, object sayer, int say_type,
                        string def_lang, string accent ) {
   string accent_lang = accent_lang_map[ accent ];
   string nat_accent = query_nat_accent( accent_lang );
   if( def_lang != accent_lang ) {
      if( nat_accent )
         mess = load_object( query_nat_accent( accent_lang ) )->garble_say( mess,
                                                                            person,
                                                                            sayer,
                                                                            say_type );
   } else {
   }
   return mess;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/nationality/accents/regional/round.c ===
inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Morporkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "au", "$AU_PROTECT",
                               "oo", "$OO_PROTECT",
                               "ou", "$OU_PROTECT",
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                                "$OO_PROTECT", "oo",
                               "$OU_PROTECT", "ou",
                               "$AU_PROTECT", "au"
                               }) );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/nationality/accents/regional/square.c ===
inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Pumpkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "a", "aa",
                               "oo", "o",
                               "ou", "ooou"
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                               }) );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/nationality/accents/national/pumpkin.c ===
string garble_say( string mess, object person,
                   object sayer, int say_type ) {
   return replace( mess, ({
                            "eh", "a",
                            "ah", "eh",
                            "ou", "oo"
                         }) );
}
string query_accent_name() {
   return "Pumpkinian";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/npc_intelligent.c ===
#include <npc/events.h>
inherit "/obj/monster";
inherit "/std/npc/goals_inherit";
int _last_hp;
protected int check_heart_beat_results();
void create() {
   goals_inherit::create();
   monster::create();
}
void heart_beat() {
   int hp;
   ::heart_beat();
   call_out((: check_heart_beat_results :), 0);
}
protected int check_heart_beat_results() {
   hp = query_hp();
   if (hp != _last_hp) {
      if (hp > _last_hp) {
         notify_npc_event(EVENT_GAIN_HPS, hp - _last_hp, hp);
      } else {
         notify_npc_event(EVENT_LOSE_HPS, _last_hp - hp, hp);
      }
      _last_hp = hp;
   }
}
mixed *stats() {
   return monster::stats() + goals_inherit::stats();
}
int move(mixed dest, string messin, string messout) {
   int ret;
   object from;
   from = environment();
   ret = ::move(dest, messin, messout);
   if (from) {
      call_out((: notify_npc_event :), 0, EVENT_MOVED, from);
   }
   return ret;
}
void event_enter(object moving, string mess, object from) {
   if (living(from)) {
      call_out((: notify_npc_event :), 0, EVENT_GIVEN, moving);
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/goal_inherit.h ===
#ifndef __GOAL_INHERIT_H__
#define __GOAL_INHERIT_H__
#define PLAN_ARRAY_SIZE 2
#define PLAN_PLAN 0
#define PLAN_INFO 1
#endif

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/goals_inherit.c ===
#include <npc/goals.h>
#include "goal_inherit.h"
class goal_information {
   mixed data;
   int priority;
   string *events;
}
class plan_info {
   int priority;
   mixed data;
}
private nosave mapping _goals;
private nosave mapping _events;
private nosave mapping _emotions;
private nosave mixed* _plans;
private nosave string  _current_plan;
private class goal_information query_goal_information(string goal);
void remove_goal_event(string goal, string event);
void add_goal_event(string goal, string event);
int query_goal_priority(string goal);
int check_current_plan_finished();
void create() {
   _goals = ([ ]);
   _events = ([ ]);
   _plans = ({ });
}
mapping query_goals() {
   return _goals;
}
mapping query_events() {
   return _events;
}
void add_goal(string goal, mixed data) {
   class goal_information frog;
   if (!goal->invarient(this_object())) {
      return ;
   }
   if (!_goals[goal]) {
      frog = new(class goal_information);
      frog->data = data;
      frog->priority = goal->query_priority(this_object(), data);
      frog->events = ({ });
      _goals[goal] = frog;
      goal->initialise(this_object(), goal, data);
   } else {
      goal->add_again(this_object(), query_goal_information(goal)->data, data);
   }
}
void remove_goal(string goal) {
   class goal_information frog;
   string event;
   frog = query_goal_information(goal);
   if (frog) {
      goal->finalise(this_object(), frog->data);
      foreach (event in frog->events) {
         remove_goal_event(goal, event);
      }
      map_delete(_goals, goal);
   }
}
private class goal_information query_goal_information(string goal) {
   class goal_information frog;
   frog = _goals[goal];
   return frog;
}
mixed query_goal_data(string goal) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog) {
      return frog->data;
   }
   return 0;
}
int set_goal_data(string goal, mixed data) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog) {
      frog->data = data;
      return 1;
   }
   return 0;
}
int query_goal_priority(string goal) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog) {
      return frog->priority;
   }
   return GOAL_INVALID_PRIORITY;
}
void change_goal_priority(string goal) {
   class goal_information frog;
   int new_priority;
   string evt;
   frog = query_goal_information(goal);
   if (frog) {
      new_priority = goal->query_priority(this_object(), frog->data);
      if (new_priority != frog->priority) {
         frog->priority = new_priority;
      }
      foreach (evt in frog->events) {
         remove_goal_event(goal, evt);
         add_goal_event(goal, evt);
      }
   }
}
void add_goal_event(string goal, string event) {
   class goal_information frog;
   string test_goal;
   int i;
   int priority;
   int found;
   frog = query_goal_information(goal);
   if (frog) {
      if (!_events[event]) {
         _events[event] = ({ goal });
      } else if (member_array(goal, _events[event]) == -1) {
         priority = query_goal_priority(goal);
         while (i < sizeof(_events[event])) {
            test_goal = _events[event][i];
            if (query_goal_priority(_events[event][i]) < priority) {
               _events[event] = _events[event][0..i-1] + ({ goal }) +
                                _events[event][i..];
               found = 1;
               break;
            }
            i++;
         }
         if (!found) {
            _events[event] += ({ goal });
         }
      }
      frog->events += ({ event });
   }
}
void remove_goal_event(string goal, string event) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog && _events[event]) {
      _events[event] -= ({ goal });
      if (!sizeof(_events[event])) {
         map_delete(_events, event);
      }
      frog->events -= ({ event });
   }
}
varargs void notify_npc_event(string event, mixed *information ...) {
   string goal;
tell_creator("pinkfish", "%s %O\n", event, _events[event]);
   if (_events[event]) {
      foreach (goal in _events[event]) {
         if (goal->notify_of_event(this_object(),
                                   query_goal_information(goal)->data,
                                   event,
                                   information)) {
            return ;
         }
      }
   }
   if (sizeof(_plans)) {
      if (_plans[PLAN_PLAN]->notify_of_event(this_object(),
                                      ((class plan_info)_plans[PLAN_INFO])->data,
                                      event,
				      information)) {
         check_current_plan_finished();
      }
   }
}
void activate_plan(string plan,
                   string goal,
                   mixed data) {
   int priority;
   int pos;
   int i;
   int old;
   mixed *tmp;
   class plan_info info;
   priority = query_goal_priority(goal);
   pos = member_array(plan, _plans);
   if (pos != -1) {
      info = _plans[pos + PLAN_INFO];
      info->data = plan->combine_plans(info->data, data);
      if (info->priority != priority) {
         old = -1;
         for (i = pos - PLAN_ARRAY_SIZE; i >= 0; i -= PLAN_ARRAY_SIZE) {
            if (priority > ((class plan_info)_plans[i + PLAN_INFO])->priority) {
               old = i;
            } else {
               break;
            }
         }
         if (old != -1) {
            tmp = _plans[pos..pos + PLAN_ARRAY_SIZE];
            _plans = _plans[0..pos - 1] + _plans[pos + PLAN_ARRAY_SIZE..];
            _plans = _plans[0..old - 1] + tmp + _plans[old..];
         } else {
            for (i = pos + PLAN_ARRAY_SIZE; i < sizeof(_plans);
                 i += PLAN_ARRAY_SIZE) {
               if (priority < ((class plan_info)_plans[i + PLAN_INFO])->priority) {
                  old = i;
               } else {
                  break;
               }
            }
            if (old != -1) {
               tmp = _plans[old..old + PLAN_ARRAY_SIZE];
               _plans = _plans[0..old - 1] + _plans[old + PLAN_ARRAY_SIZE..];
               _plans = _plans[0..pos - 1] + tmp + _plans[pos..];
            }
         }
      }
   } else {
      old = -1;
      info = new(class plan_info);
      info->data = data;
      info->priority = priority;
      for (i = 0; i < sizeof(_plans); i += PLAN_ARRAY_SIZE) {
         if (priority > ((class plan_info)_plans[i + PLAN_INFO])->priority) {
            _plans = _plans[0..i - 1] + ({ plan, info }) +
                     _plans[i..];
            old = i + PLAN_ARRAY_SIZE;
            break;
         }
      }
      if (i >= sizeof(_plans)) {
         _plans += ({ plan, info });
      }
   }
tell_creator("pinkfish", "Activating %O, %O, %O\n", _current_plan, _plans[PLAN_PLAN], _plans[PLAN_INFO]);
   if (_plans[PLAN_PLAN] != _current_plan) {
      if (_current_plan) {
         pos = member_array(_current_plan, _plans);
         if (pos != -1) {
            _plans[pos + PLAN_PLAN]->suspend_plan(this_object(),
                                                  ((class plan_info)_plans[pos + PLAN_INFO])->data);
         }
      }
      _plans[PLAN_PLAN]->activate_plan(this_object(),
                                       ((class plan_info)_plans[PLAN_INFO])->data);
      while (check_current_plan_finished());
   }
}
int check_current_plan_finished() {
   if (sizeof(_plans)) {
      if (_plans[PLAN_PLAN]->finished(this_object(),
                                      ((class plan_info)_plans[PLAN_INFO])->data)) {
         _plans = _plans[PLAN_ARRAY_SIZE..];
         if (sizeof(_plans)) {
            _plans[PLAN_PLAN]->activate_plan(this_object(),
                                             ((class plan_info)_plans[PLAN_INFO])->data);
         }
         return 1;
      }
   }
   return 0;
}
void set_plan_data(string plan, mixed data) {
   int pos;
   pos = member_array(plan, _plans);
   if (pos != -1) {
      ((class plan_info)_plans[pos + PLAN_INFO])->data = data;
   }
}
mixed *stats() {
   mixed *ret;
   string goal;
   class goal_information frog;
   int goal_num;
   int i;
   goal_num = 0;
   ret = ({ });
   foreach (goal in keys(_goals)) {
      frog = query_goal_information(goal);
      ret += ({ ({ "Goal " + goal_num + ") name", goal }) });
      ret += ({ ({ "Goal " + goal_num + ") events",
                   query_multiple_short(frog->events) }) });
      ret += ({ ({ "Goal " + goal_num + ") priority",  frog->priority }) });
      goal_num++;
   }
   for (i = 0; i < sizeof(_plans); i += PLAN_ARRAY_SIZE) {
      ret += ({ ({ "Plan " + goal_num + ") name", _plans[i + PLAN_PLAN] }) });
      ret += ({ ({ "Plan " + goal_num + ") priority",
                   ((class plan_info)_plans[i + PLAN_INFO])->priority }) });
   }
   return ret;
}
void set_goal_plan_data(string goal, string plan, mixed data) {
   mixed goal_data;
   goal_data = query_goal_data(goal);
   goal->set_plan_data(this_object(), goal_data, plan, data);
}
mixed query_goal_plan_data(string goal, string plan) {
   mixed goal_data;
   goal_data = query_goal_data(goal);
   return goal->query_plan_data(this_object(), goal_data, plan);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/surface_decorator.c ===
#include <money.h>
inherit "/obj/monster";
private mapping fitted_surfaces = ([ ]);
private string *allowed_surfaces = ({ });
private string *allowed_domains = ({ });
private string *responses = ({
        "'I don't fit those kinds of surfaces.",
        "'I don't fit that kind of decor.",
        "'You don't own this place, sorry!",
        "'I can't decorate surfaces here!",
        "'Something went horribly wrong!",
        "'All finished!",
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$.",
        "'I can fit $allowed$ with any of the following:",
        "'I don't have any stock right now.",
        "'Ok, I'll get right on with it.",
        "'What?  Did somebody say something?",
        "'I've already been hired by $employer$.",
        "'Ok, take me to the room you want decorated and ask me to "
        "fit something when we get there.",
        "'Sorry, I don't go there."
    });
private string under_construction_mess = "covered in dust and dirt" ;
private int work_time = 10;
private object employer;
private string last_ok;
int do_ask( string surface, string decor );
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if (!do_setup) {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("/doc/object/surface_decorator");
    add_enter_commands("#check_domain");
}
void init() {
    ::init();
    this_player()->add_command( "ask", this_object(), "<direct:object> to "
        "fit the <string'surface'> with <string'decor'>",
        (: do_ask($4[1], $4[2])  :) );
    this_player()->add_command( "list", this_object(), "goods from "
        "<direct:object>" );
    this_player()->add_command( "hire", this_object(), "<direct:object>");
}
int do_list() {
    int i;
    string thing;
    i=1;
    if( !sizeof( fitted_surfaces ) ) {
        init_command( responses[8], 1 );
        return 1;
    }
    init_command( replace( responses[7], ({
            "$allowed$", query_multiple_short( map( allowed_surfaces,
                (: pluralize($1) :) ) )
        }) ), i );
    foreach( thing in keys( fitted_surfaces ) ) {
        i++;
        init_command("'" + capitalize(thing) + " for " +
            MONEY_HAND->money_value_string(fitted_surfaces[thing][1],
            query_property("place")) + ".", i);
    }
    return 1;
}
int do_hire() {
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D about "
        + this_object()->query_possessive() + " services.\n", ({ }) );
    if( !this_player()->query_visible( this_object() ) ) {
        init_command( responses[10], 1 );
        return 1;
    }
    if( employer &&
        environment( employer ) == environment( this_object() ) &&
        this_player() != employer ) {
        init_command( replace( responses[11], ({ "$employer$", "$C$" +
            employer->query_name() }) ), 1 );
        return 1;
    }
    employer = this_player();
    do_command("unfollow everyone");
    employer->add_follower(this_object());
    init_command( responses[12], 1 );
    return 1;
}
int do_ask( string surface, string decor ) {
    string long, allowed, place;
    int fee, can_do;
    object where;
    can_do = 0;
    foreach( allowed in allowed_surfaces ) {
        if( strsrch( surface, allowed ) != -1 ) {
            can_do = 1;
        }
    }
    if( !can_do ) {
        do_command(responses[0]);
        return 1;
    }
    if( member_array( decor, keys( fitted_surfaces ) ) == -1 ) {
        do_command(responses[1]);
        return 1;
    }
    long = fitted_surfaces[decor][0];
    fee  = fitted_surfaces[decor][1];
    where = environment( this_object() );
    if(!where->test_occupier( this_player()->query_name() ) ) {
        do_command(responses[2]);
        return 1;
    }
    if(!function_exists("decorate_surface", where)) {
        do_command(responses[3]);
        return 1;
    }
    place = query_property("place");
    if ( this_player()->query_value_in( place ) < fee ) {
        do_command( replace( responses[6], ({
            "$decor$", decor,
            "$amount$", MONEY_HAND->money_value_string(fee, place)
        }) ) );
        queue_command("stare" + this_player()->query_name());
        return 1;
    }
    if(!where->decorate_surface(surface,under_construction_mess)) {
        do_command(responses[4]);
        return 1;
    }
    call_out( "finish_work", work_time, surface, long, where );
    do_command( responses[9] );
    do_command( "unfollow everyone" );
    this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( fee,
            place ), place);
    this_player()->add_succeeded_mess( this_object(), "$N pay$s $D some "
        "money and " + this_object()->query_pronoun() + " starts to go "
        "about his work on the " + surface + ".\n", ({ }) );
    return 1;
}
void finish_work( string surface, string long, object where ) {
    do_command(":finishes his work.");
    if( employer ) {
        employer->add_follower(this_object());
    }
    if(!where || !where->decorate_surface(surface, long )) {
        do_command(responses[4]);
        return;
    }
    else {
        do_command(responses[5]);
        return;
    }
}
private void go_back() {
    move("/room/rubbish", "$N walk$s in.", "$N walk$s away.");
    if( last_ok ) {
        move(last_ok, "$N walk$s in.", "$N walk$s away.");
    }
}
void check_domain() {
    string allowed, here;
    int ok;
    here = file_name( environment( this_object() ) );
    ok = 0;
    foreach( allowed in allowed_domains ) {
        if( strsrch( here, allowed ) != -1 ) {
            ok = 1;
        }
    }
    if( ok ) {
        last_ok = here;
        return;
    }
    else {
        do_command("unfollow everyone");
        do_command( responses[13] );
        go_back();
        return;
    }
}
void add_fitted_surface( string short, string long, int cost ) {
    fitted_surfaces[ short ] = ({ long, cost });
}
mapping query_fitted_surfaces() { return fitted_surfaces; }
void remove_fitted_surface( string short ) {
    map_delete( fitted_surfaces, short );
}
void remove_all_fitted_surfaces() {
    fitted_surfaces = ([ ]);
}
void add_allowed_surface( string surface ) {
    if( member_array( surface, allowed_surfaces ) == -1 ) {
        allowed_surfaces += ({ surface });
    }
}
string *query_allowed_surfaces() { return allowed_surfaces; }
void add_allowed_domain( string domain ) {
    if( member_array( domain, allowed_domains ) == -1 ) {
        allowed_domains += ({ domain });
    }
}
string *query_allowed_domains() { return allowed_domains; }
void set_responses( string *the_responses ) {
    if( sizeof(the_responses) != sizeof(responses) ) {
        return 0;
    }
    else {
        responses = the_responses;
    }
}
string *query_responses() { return responses; }
void set_under_construction_mess( string mess ) {
    under_construction_mess = mess;
}
string query_under_construction_mess() { return under_construction_mess; }
void set_work_time( int time ) {
    work_time = time;
}
int query_work_time() { return work_time; }
void set_employer( object player ) {
    employer = player;
}
object query_employer() { return employer; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/taliswoman.c ===
inherit "/obj/clothing";
#include "/d/guilds/witches/include/taliswoman.h"
void setup();
void init();
void high_level();
void set_destination(string city);
int go_granny( string *args );
nosave mapping _city_destinations = ([
   "default" : AM,
   "klk" : KLK,
   "stolat" : STO_LAT,
]);
nosave private string set_destination;
string _city;
void setup() {
    set_name( "taliswoman" );
    add_alias( ({ "stone", "ass", "thong" }) );
    set_short( "taliswoman" );
    add_adjective( ({ "small", "surly", "ass", "smooth", "leather", "thin",
        "witches'", "witches", "guild", "stone" }) );
    add_property( "talisman", "no one" );
    add_property( "no recycling", 1 );
    set_main_plural( "taliswomen" );
    set_long( "This small stone shaped like a small and surly ass has been "
      "worn smooth by frequent handling.  A thin, leather thong has been "
      "threaded through its hole.  " );
    add_extra_look( this_object() );
    set_value(1);
    set_weight(2);
    set_type( "necklace" );
    set_max_cond( 70 );
    set_cond( 70 );
    init_dynamic_arg(query_dynamic_auto_load());
}
string extra_look() {
    if( this_player()->query_name() != query_property( "talisman" ) ) {
        return "\n";
    }
    return "This taliswoman will get you to the Witches Guild to see Granny "
        "Weatherwax if you rub the tail of the ass, and back to "
        "Ankh-Morpork if you rub its head. You can only use it once in "
        "each direction, but you can get a new one from Gennie if you "
        "haven't outgrown them.\n";
}
void init() {
    add_command( "rub" , "{head|tail} of <direct:object'ass'>",
      (: go_granny( $4[0] ) :) );
}
void high_level() {
    string gender;
    switch( this_player()->query_gender() ) {
        case 0:
            gender = "thing";
            break;
        case 1:
            gender = "boy";
            break;
        case 2:
            gender = "girl";
            break;
    }
    add_failed_mess( "$D says \"You are a big " + gender + " now, so you'll "
        "have to manage without me.  Good luck on your adventures!\"\n", );
    set_worn_by(0);
    this_player()->remove_property( "given taliswoman" );
    move( "/room/rubbish", "", "$N vanishes in a puff of smoke." );
}
void set_destination( string city ) {
    _city = "city";
}
mapping query_dynamic_auto_load() {
    return ([
        "::" : ::query_dynamic_auto_load(),
        "new_destination" : _city,
    ]);
}
void init_dynamic_arg( mapping map, object ) {
    if (map["::"]) ::init_dynamic_arg(map["::"]);
    if (map[ "city" ] ]) _city = map["city"];
        else {
            _city = "default";
        }
}
int go_granny( string where ) {
    mixed destination;
    destination = _city;
    if( !query_property( "talisman" ) ) {
        add_failed_mess( "$D blinks rapidly and vanishes in a sudden fit "
            "of quantum insecurity.\n" );
        set_worn_by(0);
        move( "/room/rubbish" );
        return -1;
    }
    if( query_property( "talisman" ) != this_player()->query_name() ) {
        this_player()->add_failed_mess( this_object(), "$D isn't yours!\n"
            "It thumbs its metaphorical nose at you and refuses to do "
            "anything.\n" );
        return -1;
    }
    if( where == "tail" ) {
        if( this_player()->query_level() > 20 ) {
            high_level();
            return -1;
        }
        if( query_property( "been to bad ass" ) ) {
            add_failed_mess( "You have already used $D to travel to the "
                "witches once.\n" );
            return -1;
        }
        if( file_name( environment( this_player() ) ) == destination ) {
            add_failed_mess( "But you are already here!\n" );
            return -1;
        }
        add_succeeded_mess( ({ "$D starts to glow.  The bright glow makes "
            "you blink and when you open your eyes, you're in a new place.\n",
            "$N $V $D.\n" }) );
        if( this_player()->query_guild_ob() != "/std/guilds/witch" ) {
            call_out( (: tell_object( $(this_player()), "The taliswoman "
                "says: To the northwest, then north of here is the home of "
                "Granny Weatherwax.  You need to speak with her about "
                "becoming a witch.  To get into the cottage you will need "
                "the key to the back door; it's hidden in the privy.  To get "
                "back to Ankh-Morpork, you can rub my head or catch the "
                "carriage in Bad Ass to the southeast of here.  "
                "Good luck!\n" ) :), 2 );
            add_property( "been to bad ass", 1 );
        }
    }
    else {
        if( this_player()->query_level() > 20 ) {
            high_level();
            return -1;
        }
        if( query_property( "been to city" ) ) {
            add_failed_mess( "You have already used $D to travel to the "
                "city once.\n" );
            return -1;
        }
        if( file_name( environment( this_player() ) ) == destination ) {
            add_failed_mess( "But you are already here!\n" );
            return -1;
        }
        add_succeeded_mess( ({ "$D starts to glow.  The bright glow makes "
            "you blink and when you open your eyes, you're in a new place.\n",
            "$N $V $D.\n" }) );
        add_property( "been to city", 1 );
    }
    call_out( (: $(this_player())->move_with_look( $(destination),
        "You notice a glimmering light to the side of the road.  As you "
        "watch, the light begins to take the shape of $N as she "
        "arrives from somewhere else.",
        "A bright light surrounds $N.  It dims suddenly, then "
        "vanishes.  It seems to have taken $N with it." ) :), 0 );
    if( query_property( "been to bad ass" ) &&
        query_property( "been to city" ) ) {
        call_out( (: tell_object( $(this_player()), the_short() +
            " says: You have now used me to travel once in each direction, "
            "so our ways part here.  If you need me again, just go see "
            "Gennie.\n" ) :), 1 );
        this_player()->remove_property( "given taliswoman" );
        call_out( (: set_worn_by(0), move( "/room/rubbish", "",
            "$N vanishes in a puff of smoke." ) :), 1 );
    }
    return 1;
}
varargs int add_property( string var, mixed val, int tim ) {
    if( var == "talisman" ) {
        if( query_property( "talisman" ) &&
            query_property( "talisman" ) != "no one" ) {
            call_out( (: tell_object( $(environment()), "The taliswoman "
                "blinks rapidly and vanishes in a sudden fit of quantum "
                "insecurity.\n" ) :), 1 );
            call_out( (: set_worn_by(0), move( "/room/rubbish" ) :), 1 );
        }
    }
    return ::add_property( var, val, tim );
}
string query_destination() {
    return _city;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/locksmith.c ===
#include <armoury.h>
#include <money.h>
#define LOG "/log/LOCKSMITH"
#define LOGGING 1
inherit "/obj/monster";
private void save_killers();
private void load_killers();
private void remove_killer(string name);
private void clear_false_client();
private void payment_timeout();
private int check_owner();
private void unlock(object door);
private string get_price();
private int calc_price();
private void generic_responses();
private void go_back();
private void unlock_all( string path );
private void delay_opening( string env );
void finish_opening( string path, string env );
public void confirmation(string response, object player);
public void free_for_hire();
public string query_client();
public void move_recording();
public string* query_killers();
public string* query_responses();
public string query_domain();
public string query_last_room();
protected int set_savefile(string file);
protected int set_price(int price);
protected int set_currency_region(string region);
protected int set_responses(string *responses);
protected int set_domain(string domain);
public int do_hire( int all );
public int do_pay();
public int do_ask(string exit);
private string _client;
private string* _killers;
private int _price;
private int _paid;
private int _all_doors;
private object _door;
private string _savefile;
private string _region;
private string* _responses;
private string _domain;
private string _last_room;
void create() {
  generic_responses();
  do_setup++;
  ::create();
  do_setup--;
  if (!do_setup)
    this_object()->setup();
  add_enter_commands("#move_recording");
}
void init() {
  ::init();
  if(interactive(this_player())) {
    this_player()->add_command("hire", this_object(), "<direct>",
                                  (: do_hire( 0 ) :) );
    this_player()->add_command("hire", this_object(),
                                   "<direct> to unlock an entire house",
                                   (: do_hire( 1 ) :) );
    this_player()->add_command("pay", this_object(), "<direct>");
    this_player()->add_command("ask", this_object(),
                                "<direct> to {open|unlock} [the] "
                                "<word'exit'> door",
                                (: do_ask($4[2]) :));
    this_player()->add_command("confirm", this_object(), "");
  }
}
void reset() {
  clear_false_client();
}
public void free_for_hire() {
  _client = 0;
  _paid = 0;
  _door = 0;
  _all_doors = 0;
  set_move_after(60, 60);
}
public string query_client() {
  if(!_client)
    return 0;
  return _client;
}
public void move_recording() {
  object room = environment(this_object());
  if(!room) {
    if(query_name() != "object")
      call_out("dest_me", 5);
    return;
  }
  if(_client) {
    if(_domain && base_name(room)[0..5] == _domain) {
      if(!room->query_owner())
        _last_room = base_name(room);
      return;
    }
    do_command("sayto " + _client + " " + _responses[11]);
    go_back();
  }
}
public string* query_killers() {
  return _killers;
}
public string query_domain() {
  return _domain;
}
public string query_last_room() {
  return _last_room;
}
public void confirmation(string response, object player) {
  if(!response || !player)
    return;
  switch(lower_case(response)) {
  case "yes":
  case "y":
    break;
  case "no":
  case "n":
    do_command("nod");
    do_command("follow " + player->query_name());
    _door = 0;
    return;
  default:
    do_command("sayto " + player->query_name() + " " + _responses[0]);
    return;
  }
  if(!_client || player->query_name() != _client) {
    do_command("sayto " + player->query_name() + " " + _responses[1]);
    return;
  }
  if(!check_owner()) {
    do_command("sayto " + player->query_name() + " " + _responses[2]);
#ifdef LOGGING
    log_file(LOG, "%s: %s tried to get %s to unlock door in %s leading "
              "to %s.\n", ctime(time()), _client, query_short(),
              base_name(environment(this_object())),_door->query_dest());
#endif
  } else if( _all_doors == 0 ) {
    queue_command("emote eyes the lock on the door.", 1);
    queue_command("emote fiddles around on the lock with some wires.", 5);
    queue_command("emote seems satisfied.", 5);
    unlock(_door);
    queue_command("sayto " + player->query_name() + " " + _responses[3], 2);
#ifdef LOGGING
    log_file(LOG,
              "%s: %s successfully got %s to unlock door in %s leading %s.\n",
              ctime(time()), _client, query_short(),
              base_name(environment(this_object())), _door->query_dest());
#endif
  } else {
    queue_command("emote eyes the lock on the door.", 1);
    queue_command("emote fiddles around on the lock with some wires.", 5);
    queue_command("'Stand back and wait for me.", 5 );
    queue_command("emote opens the door and disappears into the house, locking "
                      "the door after " + query_objective() + ".", 2 );
    delay_opening( base_name( environment( this_object() ) ) );
    return;
  }
  free_for_hire();
  go_back();
}
public string* query_responses() {
  return _responses;
}
protected int set_savefile(string file) {
  if(!file)
    return 0;
  _savefile = file;
  load_killers();
  return 1;
}
protected int set_price(int price) {
  if(!price)
    return 0;
  _price = price;
  return 1;
}
protected int set_currency_region(string region) {
  if(!region)
    return 0;
  _region = region;
  return 1;
}
protected int set_domain(string domain) {
  if(sizeof(domain) != 6)
    return 0;
  _domain = domain;
}
protected int set_responses(string* responses) {
  if(sizeof(responses) != 13)
    return 0;
  _responses = responses;
}
public int do_hire( int all ) {
  if(!this_player())
    return 0;
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  if(_client && this_player()->query_name() != _client) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[4]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  if(_client && this_player()->query_name() == _client) {
    if(_paid) {
      if(member_array(this_object(), this_player()->query_followers())
          == -1) {
        do_command("nod " + this_player()->query_name());
        do_command("follow " + this_player()->query_name());
        this_player()->add_succeeded_mess(this_object(), "", ({ }));
        return 1;
      }
      do_command("sayto " + this_player()->query_name() + " " +
                  _responses[12]);
      this_player()->add_failed_mess(this_object(), "", ({ }));
      return 0;
    }
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[5]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  _client = this_player()->query_name();
  _all_doors = all;
  queue_command("sayto " + this_player()->query_name() + " " +
                 _responses[6], 1);
  if(member_array(_client, _killers) != -1)
    queue_command("sayto " + this_player()->query_name() +
                   " I remember you... for you it'll be " + get_price() +
                   ".  Up front, of course.", 2);
  else
    queue_command("sayto " + this_player()->query_name() + " That'll be "+
                   get_price() + " up front.", 2);
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  call_out((: payment_timeout() :), 60);
  return 1;
}
public int do_pay() {
  if(!this_player())
    return 0;
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  if(!_client || this_player()->query_name() != _client) {
    do_command("whisper " + this_player()->query_name() + " I appreciate "
                "that you want to give away your cash, but don't you think "
                "should 'hire' me first?");
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  if(_paid) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[7]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  if(this_player()->query_value_in(_region) < _price) {
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[8]);
    free_for_hire();
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  this_player()->pay_money(MONEY_HAND->create_money_array(calc_price(),
                                                            _region), _region);
  _paid = 1;
  set_move_after(1200, 0);
  do_command("emote puts the money into a pocket.");
  do_command("whisper " + this_player()->query_name() + " " + _responses[10]);
  init_command("follow " + this_player()->query_name(), 1);
  this_player()->add_succeeded_mess(this_object(), "$N pay$s $D.\n", ({ }));
#ifdef LOGGING
  log_file(LOG, "%s: %s hired %s for %s" +
      ( (_all_doors == 1)?" (all doors)":"" ) + "\n",
      ctime(time()), _client, query_short(), get_price() );
#endif
  remove_killer(_client);
  return 1;
}
public int do_ask(string exit) {
  object room, door;
  string dest;
  room = environment(this_object());
  if(!this_player() || !exit || !room)
    return 0;
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  if(!_client || this_player()->query_name() != _client) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[1]);
    this_player()->add_failed_mess(this_object(),
                                   "You are not " + the_short() +
                                   "'s client.\n", ({ }));
    return 0;
  }
  do_command("unfollow " + this_player()->query_name());
  dest = this_player()->find_abs(exit);
  if(room->query_destination(dest) == "/room/void") {
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[9]);
    do_command("follow " + this_player()->query_name());
    this_player()->add_failed_mess(this_object(),
                                    "This exit is not valid.\n", ({ }));
    return 0;
  }
  foreach(door in room->query_hidden_objects())
    if(door->query_dest() == room->query_destination(dest)) {
      _door = door;
      break;
    }
  if( _all_doors == 0 )
    do_command("whisper " + this_player()->query_name() + " Can you confirm "
                "that this is your place?  And that you want the " + exit +
                " door opened?");
  else
    do_command("whisper " + this_player()->query_name() + " So that's your "
                "place on the other side?  Can you confirm that you want the " +
                exit + " door and all the others in your house opened?" );
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  tell_object(this_player(), "[y]es/[n]o: ");
  input_to("confirmation", 0, this_player());
  return 1;
}
void event_enter(object ob, string message, object from) {
  if(from && environment(ob) == this_object()) {
    if(ob->query_name() == "coin") {
      do_command("sayto " + file_name(from) + " You have to pay me.");
      do_command("give coins to " + file_name(from));
      return;
    }
    do_command("sayto " + file_name(from) + " I don't take donations.");
    do_command("give " + file_name(ob) + " to " + file_name(from));
  }
}
private void save_killers() {
  string killerstring, killer;
  if(!_savefile)
    return;
  if(!sizeof(_killers)) {
    unguarded((: write_file($(_savefile), "--- no killers ---", 1) :));
    return;
  }
  killerstring = "";
  foreach(killer in _killers)
    killerstring += killer + " ";
  unguarded((: write_file($(_savefile), $(killerstring), 1) :));
}
private void load_killers() {
  string killerstring;
  if(!_savefile)
    return;
  if(file_size(_savefile) == -1) {
    _killers = ({ });
    return;
  }
  killerstring = unguarded((: read_file($(_savefile)) :));
  if( !killerstring || killerstring == "--- no killers ---" ||
      !_killers = explode(killerstring, " "))
    _killers = ({ });
}
varargs object do_death(object killer, object weapon, string attack) {
  if(killer && interactive(killer)) {
    if(member_array(killer->query_name(), _killers) == -1) {
      if (!_killers) {
         _killers = ({ });
      }
      _killers += ({ killer->query_name() });
    }
  }
  save_killers();
  if(weapon && attack)
    return ::do_death(killer, weapon, attack);
  if(weapon)
    return ::do_death(killer, weapon);
  if(killer)
    return ::do_death(killer);
  return ::do_death();
}
private void remove_killer(string name) {
  int index;
  index = member_array(name, _killers);
  if(index == -1)
    return;
  if(sizeof(_killers) == 1)
    _killers = ({ });
  if(index == 0)
    _killers = _killers[ 1.. ];
  if(index == sizeof(_killers))
    _killers = _killers[ 0..(sizeof(_killers) -1) ];
  _killers = _killers[ 0..(index - 1) ] + _killers[ (index + 1).. ];
}
private void clear_false_client() {
  if(_client && find_living(_client) &&
      environment(find_living(_client)) == environment(this_object()))
    return;
  free_for_hire();
}
private void payment_timeout() {
  if(_client && !_paid)
    free_for_hire();
}
private int check_owner() {
  string dest = _door->query_dest();
  if(load_object(dest)->query_owner() == _client)
    return 1;
  return 0;
}
private void unlock(object door) {
  door->set_unlocked();
  event( load_object( door->query_dest() ), "save");
  event( environment(), "save");
}
private string get_price() {
  int price;
  if(member_array(_client, _killers) != -1)
    price = 2 * _price;
  else
    price = _price;
  if( _all_doors == 1 )
    price*= 5;
  return MONEY_HAND->money_string(MONEY_HAND->create_money_array(price,
                                                                 _region));
}
private int calc_price() {
  int price;
  if(member_array(_client, _killers) != -1)
    price = 2 * _price;
  price = _price;
  if( _all_doors == 1 )
    price *= 5;
  return price;
}
private void go_back() {
  object room, door;
  int i;
  if(!room = environment(this_object()))
    return;
  if(!_last_room || base_name(room) == _last_room) {
    do_command(room->query_exits()[random(sizeof(room->query_exits()))]);
    return;
  }
  i = member_array(_last_room, room->query_dest_dir());
  if(i == -1)
    move(_last_room, "$N walk$s in.", "$N walk$s away.");
  else {
    foreach(door in room->query_hidden_objects())
      if(door->query_dest() == _last_room &&
          door->query_locked()) {
        move(_last_room, "$N walk$s in, locking the door.",
              "$N unlock$s the door and leave$s, locking it "
              "again.");
        return;
      }
    do_command(room->query_dest_dir()[i-1]);
  }
}
private void generic_responses() {
  _responses = ({0,0,0,0,0,0,0,0,0,0,0,0,0});
  _responses[0] = "I do not understand.";
  _responses[1] = "You have to hire me.";
  _responses[2] = "This door does not lead to your house.  I cannot help you.";
  _responses[3] = "It has been a pleasure doing business with you.";
  _responses[4] = "I am already hired by someone else.";
  _responses[5] = "You have to 'pay' me.";
  _responses[6] = "You do require my services?";
  _responses[7] = "You already paid me.";
  _responses[8] = "You do not have enough money.";
  _responses[9] = "I cannot find that door.";
  _responses[10] = "Very well.  Please lead me to your house and 'ask' me to "
    "open the door that troubles you.";
  _responses[11] = "I won't leave my beloved home, sorry.  I'll wait there "
    "for a while, if you change your mind and come back.";
  _responses[12] = "You already hired me.";
}
private void unlock_all( string path ) {
    string* files = get_dir( path + "*.c" );
    string file;
    object room, ob;
    if( !sizeof( files ) )
        return;
    foreach( file in files ) {
        room = load_object( path + file );
        if( room ) {
            foreach( ob in room->query_hidden_objects() )
                if( ob->query_dest() )
                     ob->set_unlocked();
            event( room, "save" );
        }
    }
}
private void delay_opening( string env ) {
    string path;
    string* path_bits;
    path_bits = explode( env, "/" );
    path_bits[ sizeof( path_bits ) -1 ] = "";
    path = "/" + implode( path_bits, "/" );
    move( "/room/void" );
    call_out( "finish_opening", 30, path, env );
}
void finish_opening( string path, string env ) {
    unlock_all( path );
#ifdef LOGGING
    log_file(LOG,
              "%s: %s successfully got %s to unlock all doors in %s.\n",
              ctime(time()), _client, query_short(), path );
#endif
    move( env, "$N leaves the house, rubbing " + query_objective() +
           " hands.\n", "" );
    free_for_hire();
    go_back();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/test_npc.c ===
#include <npc/goals.h>
#include <npc/plan.h>
inherit "/std/npc/npc_intelligent";
void setup() {
   string goal;
   set_name("fluff");
   set_short("bit of fluff");
   set_long("A small bit of fluff.");
   set_race("human");
   set_guild("warrior");
   set_level(10);
   goal = GOALS_DIR + "basic/stay_alive_basic";
   goal->add_goal_to_npc(this_object(), ([ ]), 100);
   load_chat(100, ({ 1, "'Scruff!",
                     1, "'Chickens?",
			}));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/goals/base.c ===
#include <npc/goals.h>
private mapping _default_plans;
private int _default_priority;
#define GOAL_PLAN_ARRAY_SIZE 1
#define GOAL_PLAN_PLAN 0
void setup() {
}
void create() {
   _default_plans = ([ ]);
   _default_priority = GOAL_INVALID_PRIORITY;
   setup();
}
void initialise_plans(object npc,
                      string goal_name,
                      mixed data) {
}
void initialise(object npc,
                string goal_name,
                class goal_control control) {
   string name;
   foreach (name in keys(_default_plans)) {
tell_creator("pinkfish", "Adding event hook for %O\n", name);
      npc->add_goal_event(base_name(this_object()), name);
   }
   foreach (name in keys(control->extra_plans)) {
      npc->add_goal_event(base_name(this_object()), name);
   }
   initialise_plans(npc, goal_name, control->data);
}
string query_current_plan(object npc,
                          class goal_control control) {
   return control->current_plan;
}
mixed create_goal_data(object npc,
                       string goal_name,
                       mixed stuff) {
   return stuff;
}
void add_goal_to_npc(object npc,
                     mapping extra_plans,
		     mixed stuff) {
   class goal_control frog;
   mixed value;
   string goal_name;
tell_creator("pinkfish", "Adding goal %O to npc(%O).\n", base_name(this_object()), stuff);
   if (!mapp(extra_plans)) {
      extra_plans = ([ ]);
   }
   goal_name = base_name(this_object());
   frog = new(class goal_control);
   frog->extra_plans = extra_plans;
   frog->current_plan = 0;
   frog->priority = GOAL_DEFAULT_PRIORITY;
   frog->data = create_goal_data(npc, goal_name, stuff);
   frog->plan_info = ([ ]);
   npc->add_goal(goal_name, frog);
}
int query_priority(object npc,
                   class goal_control control) {
   if (control->priority != GOAL_DEFAULT_PRIORITY) {
      return control->priority;
   }
   return _default_priority;
}
int query_default_priority() {
   return _default_priority;
}
protected void set_default_priority(int priority) {
   _default_priority = priority;
}
int notify_of_event(object npc,
                    class goal_control control,
                    string event,
                    mixed *data) {
   int value;
   string plan;
   int max_value;
   string max_plan;
   mixed max_data;
   int i;
   mixed info;
   if (control->extra_plans[event]) {
      for (i = 0; i < sizeof(control->extra_plans[event]);
           i += GOAL_PLAN_ARRAY_SIZE) {
         plan = control->extra_plans[event][i + GOAL_PLAN_PLAN];
         info = control->plan_info[plan];
         if (plan->pre_condition(npc,
                                 base_name(this_object()),
                                 info,
                                 event,
                                 data)) {
            value = plan->query_sutability(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            if (value > max_value) {
               max_value = value;
               max_plan = plan;
               max_data = plan->query_data(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            }
         }
      }
   }
   if (_default_plans[event]) {
      for (i = 0;
           i < sizeof(_default_plans[event]);
           i += GOAL_PLAN_ARRAY_SIZE) {
         plan = _default_plans[event][i + GOAL_PLAN_PLAN];
         info = control->plan_info[plan];
         if (plan->pre_condition(npc,
                                 base_name(this_object()),
                                 info,
                                 event,
                                 data)) {
            value = plan->query_sutability(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            if (value > max_value) {
               max_value = value;
               max_plan = plan;
               max_data = plan->query_data(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            }
         }
      }
   }
   if (max_plan) {
      return npc->activate_plan(max_plan,
                                base_name(this_object()),
                                query_priority(npc, control) +
                                   max_plan->query_priority_offset(),
                                max_data);
   }
   return GOAL_EVENT_NOT_HANDLED;
}
mapping query_default_plans() {
   return _default_plans;
}
protected void add_default_plan(string event_name,
                                string plan) {
   if (!_default_plans[event_name]) {
      _default_plans[event_name] = ({ plan });
   } else if (member_array(plan, _default_plans[event_name]) == -1) {
      _default_plans[event_name] += ({ plan });
   }
}
void set_plan_data(object npc,
                   class goal_control control,
                   string plan,
                   mixed plan_data) {
   control->plan_info[plan] = plan_data;
}
mixed query_plan_data(object npc,
                      class goal_control control,
                      string plan) {
   return control->plan_info[plan];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/goals/basic/stay_alive.c ===
#include <goals.h>
inherit BASE_GOAL;
void create() {
   ::create();
   set_default_priority(GOAL_HIGH_PRIORITY);
   add_default_plan(EVENT_HP_LOST,
                    GOAL_PLAN_DIR + "basic/run_away");
   add_default_plan(EVENT_PLAN_FINISHED,
                    GOAL_PLAN_DIR + "basic/lose_attackers");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/goals/basic/stay_alive_basic.c ===
#include <npc/goals.h>
#include <npc/events.h>
#include <npc/plan.h>
inherit GOAL_BASE_INHERIT;
void setup() {
   set_default_priority(GOAL_HIGH_PRIORITY);
   add_default_plan(EVENT_LOSE_HPS,
                    PLAN_DIR + "basic/run_away");
}
int invarient(object npc) {
   return 1;
}
mixed initialise_plans(object npc,
                       string goal_name,
                       int wimpy) {
tell_creator("pinkfish", "Initialise_plans(%O, %O, %O)\n", npc, goal_name, wimpy);
   npc->set_goal_plan_data(goal_name,
                           PLAN_DIR + "basic/run_away",
                           wimpy);
   return wimpy;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/goals/misc/get_drunk.c ===
#include <npc/goals.h>
#include <npc/events.h>
#include <npc/plan.h>
inherit GOAL_BASE_INHERIT;
void setup() {
   set_default_priority(GOAL_LOW_PRIORITY);
   add_default_plan(EVENT_GIVEN_MONEY,
                    PLAN_DIR + "control/goto_location");
}
int invarient(object npc) {
   return 1;
}
mixed initialise_plans(object npc,
                       string goal_name,
                       int wimpy) {
tell_creator("pinkfish", "Initialise_plans(%O, %O, %O)\n", npc, goal_name, wimpy);
   npc->set_goal_plan_data(goal_name,
                           PLAN_DIR + "basic/run_away",
                           wimpy);
   return wimpy;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/inherit/owned.c ===
private mixed _owner;
object set_owner( mixed owner ){
  if( stringp(owner) )
    _owner = owner;
  if( objectp(owner) && living(owner) ){
    if( userp(owner) )
      _owner = owner->query_name();
    else
      _owner = owner;
  }
  return _owner;
}
object query_owner() {
  if( stringp(_owner) )
    return find_player(_owner);
  else
    return _owner;
}
object query_owner_pk_check() {
   return query_owner();
}
mixed *stats(){
  return ({
    ({ "owner", _owner }),
  });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/plans/base.c ===
#include <npc/plan.h>
private nosave int _sutability;
private nosave mapping _hooked_events;
void setup() {
}
void create() {
   _sutability = PLAN_INVALID_SUTABILITY;
   _hooked_events = ([ ]);
   setup();
}
int pre_condition(object npc,
		  string goal,
                  mixed goal_info,
		  string event,
		  mixed *data) {
   return 0;
}
int finished(object npc,
             mixed *data) {
   return 1;
}
int query_sutability(object npc,
		     string goal,
                     mixed goal_info,
		     string event,
		     mixed *data) {
   return _sutability;
}
void set_sutability(int sutability) {
   _sutability = sutability;
}
int query_data(object npc,
	       string goal,
               mixed goal_info,
	       string event,
	       mixed *data) {
   return 0;
}
mixed create_plan_data() {
   return 0;
}
void add_hooked_event(string event, function func) {
   _hooked_events[event] = func;
}
void remove_hooked_event(string event) {
   map_delete(_hooked_events, event);
}
int notify_event(object npc,
                 mixed plan_data,
                 string event,
                 mixed *data) {
   if (_hooked_events[event]) {
      return evaluate(_hooked_events[event], npc, plan_data, event, data);
   }
   return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/npc/plans/basic/run_away.c ===
#include <npc/plan.h>
#include <npc/events.h>
inherit PLAN_BASE_INHERIT;
int moved_event(object npc,
                mixed plan_data,
                string event,
                mixed *data);
void setup() {
   set_sutability(PLAN_MEDIUM_SUTABILITY);
   add_hooked_event(EVENT_MOVED, (: moved_event :));
}
protected int being_attacked(object npc) {
   object *attackers;
   attackers = filter(npc->query_attacker_list(), (: environment($1) ==
                                                 environment($2) :), npc);
   return sizeof(attackers);
}
void activate_plan(object npc,
                   mixed data) {
   npc->run_away();
}
int pre_condition(object npc,
                  string goal,
                  mixed plan_info,
                  string event,
                  mixed *data) {
   int wimpy_level;
   int percent;
tell_creator("pinkfish", "Precondition!\n");
   if (!plan_info) {
      wimpy_level = 50;
   } else {
      wimpy_level = plan_info;
   }
tell_creator("pinkfish", sprintf("%O: %O, %O\n", event, goal, plan_info));
   percent = (npc->query_hp() * 100) / npc->query_max_hp();
   if (percent < wimpy_level) {
      if (being_attacked(npc) ||
          event == EVENT_LOSE_HPS) {
         return 1;
      }
   }
   return 0;
}
int finished(object npc) {
   return !being_attacked(npc);
}
int moved_event(object npc,
                mixed plan_data,
                string event,
                mixed *data) {
   if (finished(npc)) {
      return 1;
   } else {
      npc->run_away();
   }
   return 0;
}
