
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/case_control.c ===
#define NOMIC_SYSTEM_NO_CLASSES
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
private mapping _open_cases;
private mapping _recently_closed_cases;
private mapping _closed_cases;
private int _next_case_id;
private int _next_note_id;
void save_me();
void send_council_inform(string area, int only_magistrates,
                         string mess);
void create() {
   _open_cases = ([ ]);
   _closed_cases = ([ ]);
   _recently_closed_cases = ([ ]);
   _next_case_id = 1;
   _next_note_id = 1;
}
void create_area(string area) {
   if (_open_cases[area]) {
      return ;
   }
   _open_cases[area] = ({ });
   _closed_cases[area] = ({ });
   _recently_closed_cases[area] = ({ });
}
int* query_open_cases(string area) {
   return _open_cases[area];
}
int* query_closed_cases(string area) {
   return _closed_cases[area];
}
int* query_recently_closed_cases(string area) {
   return _recently_closed_cases[area];
}
string query_case_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("cases/%02d/%d_case", id % 20, id);
}
int query_next_case_id() {
   int next;
   do {
      next = _next_case_id++;
   } while (sizeof(stat(query_case_file_name(next))));
   return next;
}
private void save_case(class nomic_case stuff) {
   string fname;
   string tmp;
   fname = query_case_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp), 1) :));
}
string query_note_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("notes/%02d/%d_note", id % 20, id);
}
int query_next_note_id() {
   int next;
   do {
      next = _next_note_id++;
   } while (sizeof(stat(query_note_file_name(next))));
   return next;
}
private void save_note(class nomic_case_note stuff) {
   string fname;
   string tmp;
   fname = query_note_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp) ) :));
}
private int create_case(string opener, string short, string* people) {
   class nomic_case new_case;
   new_case = new(class nomic_case);
   new_case->id = query_next_case_id();
   new_case->opener = opener;
   new_case->short = short;
   new_case->people = people;
   new_case->notes = ({ });
   new_case->events = ({ });
   new_case->time_opened = time();
   save_case(new_case);
   return new_case->id;
}
private int create_note(string person, string text) {
   class nomic_case_note new_note;
   new_note = new(class nomic_case_note);
   new_note->id = query_next_note_id();
   new_note->person = person;
   new_note->text = text;
   new_note->time_created = time();
   save_note(new_note);
   return new_note->id;
}
private class nomic_case_event create_event(int type, string person,
                                            string mess, mixed data) {
   class nomic_case_event event;
   event = new(class nomic_case_event);
   event->type = type;
   event->mess = mess;
   event->person = person;
   event->event_time = time();
   event->data = data;
   return event;
}
string query_event_name(int type) {
   switch (type) {
   case NOMIC_CASE_EVENT_CLOSE :
      return "closed case";
   case NOMIC_CASE_EVENT_APPEAL :
      return "appealed case";
   case NOMIC_CASE_EVENT_ADD_PERSON :
      return "add person";
   case NOMIC_CASE_EVENT_REMOVE_PERSON :
      return "remove person";
   default :
      return "unknown";
   }
}
class nomic_case query_open_case(string area, int id) {
   string fname;
   string tmp;
   if (!_open_cases[area]) {
      return 0;
   }
   if (member_array(id, _open_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_recently_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_recently_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _recently_closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case_note query_note(int note_num) {
   string fname;
   string tmp;
   fname = query_note_file_name(note_num);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
int add_new_case(string area, string opener, string short, string* people) {
   int case_id;
   if (!_open_cases[area]) {
      return 0;
   }
   case_id = create_case(opener, short, people);
   _open_cases[area] += ({ case_id });
   save_me();
   send_council_inform(area, 1, opener + " opened a case with " +
                      query_multiple_short(people));
   return case_id;
}
int close_case(string area, int id, string closer, string result,
               mixed data) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(result)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_CLOSE, closer, result, data);
   the_case->events += ({ event });
   save_case(the_case);
   _open_cases[area] -= ({ the_case->id });
   _recently_closed_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, closer + " closed a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int appeal_case(string area, int id, string appealer, string reason) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_recently_closed_case(area, id);
   if (!the_case || !stringp(reason)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_APPEAL, appealer, reason, 0);
   the_case->events += ({ event });
   save_case(the_case);
   _recently_closed_cases[area] -= ({ the_case->id });
   _open_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, appealer + " appeals a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int add_note_to_case(string area, int id, string person, string text) {
   class nomic_case the_case;
   int note_id;
   the_case = query_open_case(area, id);
   if (!the_case) {
      return 0;
   }
   note_id = create_note(person, text);
   the_case->notes += ({ note_id });
   save_case(the_case);
   save_me();
   return 1;
}
int add_person_to_case(string area, int id, string adder,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) != -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_ADD_PERSON, adder, text, 0);
   the_case->events += ({ event });
   the_case->people += ({ person });
   save_case(the_case);
   return 1;
}
int remove_person_from_case(string area, int id, string remover,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) == -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_REMOVE_PERSON, remover, text, 0);
   the_case->events += ({ event });
   the_case->people -= ({ person });
   save_case(the_case);
   return 1;
}
void update_recently_closed_cases() {
   string area;
   int* stuff;
   int id;
   class nomic_case the_case;
   class nomic_case_event event;
   int last_close;
   foreach (area, stuff in _recently_closed_cases) {
      foreach (id in stuff) {
         the_case = query_recently_closed_case(area, id);
         last_close = 0;
         foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
               last_close = event->event_time;
            }
         }
         if (last_close < time() - NOMIC_CASE_APPEAL_TIME) {
            _closed_cases[area] += ({ id });
            _recently_closed_cases[area] -= ({ id });
         }
      }
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/distance_handler.c ===
#define BAD_ROOM -1
#define TRAVEL_NOT_ALLOWED -2
#define BAD_DOMAIN -3
int* query_co_ord(string room);
private int difference(int bing, int womble){
   if (womble > bing) {
      return womble - bing;
   }
   return bing - womble;
}
private int filename_check(string one, string two){
   string dom_one;
   string dom_two;
   string alpha;
   log_file("/log/PORTAL", "Unable to get co-ords for %O %O, doing filename based check.\n", one, two);
   dom_one = explode(one, "/")[1];
   dom_two = explode(two, "/")[1];
   alpha = dom_one<dom_two?dom_one+":"+dom_two:dom_two+":"+dom_one;
   switch(alpha){
      case "am:am":
         return 3000;
      case "am:cwc":
         return TRAVEL_NOT_ALLOWED;
      case "am:ram":
         return 3000000;
      case "am:klatch":
         return 1000000;
      case "am:sur":
         return 500000;
      case "am:forn":
         return TRAVEL_NOT_ALLOWED;
      case "am:guilds":
         return 1000;
      case "cwc:ram":
      case "cwc:klatch":
      case "cwc:forn":
      case "cwc:guilds":
      case "cwc:sur":
         return TRAVEL_NOT_ALLOWED;
      case "cwc:cwc":
         return 500000;
      case "forn:forn":
         return TRAVEL_NOT_ALLOWED;
      case "forn:ram":
         return TRAVEL_NOT_ALLOWED;
      case "forn:guilds":
         return TRAVEL_NOT_ALLOWED;
      case "forn:klatch":
         return TRAVEL_NOT_ALLOWED;
      case "forn:sur":
         return TRAVEL_NOT_ALLOWED;
      case "guilds:guilds":
         return 1000;
      case "guilds:klatch":
         return 500000;
      case "guilds:sur":
         return 500000;
      case "guilds:ram":
         return 1500000;
      case "klatch:klatch":
         return 1000;
      case "klatch:sur":
         return 3300000;
      case "klatch:ram":
         return 4000000;
      case "ram:ram":
         return 500000;
      case "ram:sur":
         return 900000;
      case "sur:sur":
         return 500000;
   }
   return BAD_DOMAIN;
}
int query_distance_from_coords(int* co_ord_one, int* co_ord_two){
   float x;
   float y;
   float z;
   float distanceplane;
   float distance;
   x = difference(co_ord_one[0], co_ord_two[0]);
   y = difference(co_ord_one[1], co_ord_two[1]);
   z = difference(co_ord_one[2], co_ord_two[2]);
   distanceplane = sqrt(pow(x, 2) + pow(y, 2));
   distance = sqrt(pow(distanceplane, 2) + pow(z, 2));
   return to_int(distance);
}
int query_distance_from_rooms(mixed one, mixed two){
   mixed co_ord_one;
   mixed co_ord_two;
   if (objectp(one)) {
      one = file_name(one);
   }
   if (objectp(two)) {
      two = file_name(two);
   }
   if (one->query_co_ord()) {
      co_ord_one = one->query_co_ord();
   } else {
      co_ord_one = query_co_ord(one);
   }
   if (two->query_co_ord()) {
      co_ord_two = two->query_co_ord();
   } else {
      co_ord_two = query_co_ord(two);
   }
   if(co_ord_one == 0 || co_ord_two == 0) {
      return filename_check(one, two);
   }
   return query_distance_from_coords(co_ord_one, co_ord_two);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/club_family.c ===
inherit "/obj/handlers/inherit/club_personal";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
#include <player_handler.h>
private nosave mapping _valid_relationships;
private nosave mapping _gender_relationship;
private void add_valid_relationship(string relation,
                                    string relation2,
                                    int flags);
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female);
string* query_gender_relationships(string relationship);
class family_info {
   mapping relationships;
   string *never_join;
   string tmp;
   int tmp2;
}
#define CLUB_INTERFAMILY_FLAG 1
#define CLUB_JOIN_FAMILY_FLAG 2
class relationship_type_data {
   string opposite;
   int flags;
}
void create() {
   _valid_relationships = ([ ]);
   _gender_relationship = ([ ]);
   ::create();
   add_valid_relationship("spouse",
                          "spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "spouse",
                           "husband",
                           "wife");
   add_valid_relationship("lover",
                          "lover",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "lover",
                           "lover",
                           "lover");
   add_valid_relationship("sibling",
                          "sibling",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling",
                           "brother",
                           "sister");
   add_valid_relationship("sibling-in-law",
                          "sibling-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling-in-law",
                           "brother-in-law",
                           "sister-in-law");
   add_valid_relationship("parent-in-law",
                          "child-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "parent-in-law",
                           "father-in-law",
                           "mother-in-law");
   add_gender_relationship("Ankh-Morpork",
                           "child-in-law",
                           "son-in-law",
                           "daughter-in-law");
   add_valid_relationship("child",
                          "parent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "child",
                          "son",
                          "daughter");
   add_gender_relationship("Ankh-Morpork",
                           "parent",
                           "father",
                           "mother");
   add_valid_relationship("grandparent",
                          "grandchild",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "grandparent",
                           "grandfather",
                           "grandmother");
   add_gender_relationship("Ankh-Morpork",
                           "grandchild",
                           "grandson",
                           "granddaughter");
   add_valid_relationship("godchild",
                          "godparent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "godchild",
                           "godson",
                           "goddaughter");
   add_gender_relationship("Ankh-Morpork",
                           "godparent",
                           "godfather",
                           "godmother");
   add_valid_relationship("uncle",
                          "niece",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "uncle",
                           "uncle",
                           "aunt");
   add_gender_relationship("Ankh-Morpork",
                           "niece",
                           "nephew",
                           "niece");
   add_valid_relationship("cousin",
                          "cousin",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "cousin",
                           "cousin",
                           "cousin");
   add_valid_relationship("master",
                          "maid",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "maid",
                           "butler",
                           "maid");
   add_gender_relationship("Ankh-Morpork",
                           "master",
                           "master",
                           "mistress");
   add_valid_relationship("apprentice",
                          "tutor",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "apprentice",
                           "apprentice",
                           "apprentice");
   add_gender_relationship("Ankh-Morpork",
                           "tutor",
                           "tutor",
                           "tutor");
   add_valid_relationship("guardian",
                          "ward",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "guardian",
                           "guardian",
                           "guardian");
   add_gender_relationship("Ankh-Morpork",
                           "ward",
                           "ward",
                           "ward");
   add_valid_relationship("ex-spouse",
                          "ex-spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "ex-spouse",
                           "ex-husband",
                           "ex-wife");
}
protected void create_extra_data(string name) {
   class family_info f_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_FAMILY) {
      f_info = new(class family_info);
      f_info->relationships = ([ ]);
      f_info->never_join = ({ });
      data->extra_data = f_info;
   } else {
      ::create_extra_data(name);
   }
   set_club_changed(name);
}
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      if (is_family(club_name)) {
         return FAMILY_COST_PER_YEAR +
              sizeof(query_members(club_name)) * FAMILY_COST_PER_MEMBER_PER_YEAR;
      } else {
         return ::query_club_cost_per_period(club_name);
      }
   }
   return 0;
}
private class family_info query_family_info(string name) {
   class club_info data;
   if (is_family(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
}
void add_valid_relationship(string relation1,
                            string relation2,
                            int flags) {
   class relationship_type_data frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation2;
   frog->flags = flags;
   _valid_relationships[relation1] = frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation1;
   frog->flags = flags;
   _valid_relationships[relation2] = frog;
}
string query_opposite_relationship(string relation) {
   if (_valid_relationships[relation]) {
      return _valid_relationships[relation]->opposite;
   }
   return 0;
}
int is_valid_relationship(string str) {
   return _valid_relationships[str] != 0;
}
int is_valid_interfamily_relationship(string str) {
   class relationship_type_data frog;
   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_INTERFAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
}
int is_valid_join_family_relationship(string str) {
   class relationship_type_data frog;
   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_JOIN_FAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
}
string *query_all_valid_relationships() {
   return keys(_valid_relationships);
}
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female) {
   _gender_relationship[male] = relationship;
   _gender_relationship[female] = relationship;
   if (!mapp(_gender_relationship[relationship])) {
      _gender_relationship[relationship] = ([ ]);
   }
   _gender_relationship[relationship][region] = ({ male,
                                                   female });
}
string query_ungendered_relationship(string relationship) {
   if (stringp(_gender_relationship[relationship])) {
      return _gender_relationship[relationship];
   }
   if (mapp(_gender_relationship[relationship])) {
      return relationship;
   }
   return 0;
}
string *query_all_relationships() {
   return keys(_gender_relationship);
}
string query_relationship_gender(string relationship,
                                 int female,
                                 string region) {
   string rel;
   rel = query_ungendered_relationship(relationship);
   if (!rel ||
       female < 0 ||
       female > 1) {
      return 0;
   }
   if (!region || !_gender_relationship[rel][region]) {
      region = "Ankh-Morpork";
   }
   return _gender_relationship[rel][region][female];
}
private void real_add_relationship(string name,
                                   string person,
                                   string dest,
                                   string relationship) {
   class family_info womble;
   class relationship_data plum;
   womble = query_family_info(name);
   if (!womble->relationships[person]) {
      womble->relationships[person] = ({ });
   }
   plum = new(class relationship_data);
   plum->related_to = dest;
   plum->relationship = relationship;
   womble->relationships[person] += ({ plum });
   set_club_changed(name);
}
private void real_remove_relationship(string name,
                                      string person,
                                      string dest,
                                      string relationship) {
   class family_info womble;
   int i;
   womble = query_family_info(name);
   for (i = 0; i < sizeof(womble->relationships[person]); i++) {
      if (womble->relationships[person][i]->related_to == dest &&
          womble->relationships[person][i]->relationship == relationship) {
         womble->relationships[person] = womble->relationships[person][0..i-1] +
                                         womble->relationships[person][i+1..];
         set_club_changed(name);
      }
   }
}
int add_relationship(string name,
                     string person,
                     string dest_name,
                     string dest,
                     string relationship) {
   if (is_family(name) &&
       is_family(dest_name) &&
       is_member_of(name, person) &&
       is_member_of(dest_name, dest) &&
       is_valid_relationship(relationship)) {
      real_add_relationship(name,
                            person,
                            dest,
                            relationship);
      real_add_relationship(dest_name,
                            dest,
                            person,
                            query_opposite_relationship(relationship));
      save_club(name);
      return 1;
   }
   return 0;
}
class relationship_data *query_relationships(string name,
                                             string person) {
   class family_info womble;
   if (is_family(name)) {
      womble = query_family_info(name);
      if (womble->relationships[person]) {
         return womble->relationships[person];
      }
   }
   return ({ });
}
int move_family_member(string curr_family,
                       string person,
                       string dest_family) {
  class relationship_data *stuff;
  class family_info womble;
  if (is_family(curr_family) &&
      is_family(dest_family) &&
      is_member_of(curr_family, person)) {
    stuff = query_relationships(curr_family,
                                person);
    womble = query_family_info(curr_family);
    map_delete(womble->relationships, person);
    set_club_changed(curr_family);
    remove_member(curr_family, person);
    add_member(dest_family, person);
    womble = query_family_info(dest_family);
    womble->relationships[person] = stuff;
    set_club_changed(dest_family);
    return 1;
  }
  return 0;
}
string *query_relationships_to(string name,
                               string person,
                               string related) {
   class relationship_data frog;
   string *relationships;
   relationships = ({ });
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related) {
         relationships += ({ frog->relationship });
      }
   }
   return relationships;
}
int is_relationship(string name,
                    string person,
                    string related,
                    string relationship) {
   class relationship_data frog;
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related &&
          frog->relationship == relationship) {
         return 1;
      }
   }
   return 0;
}
int remove_relationship(string name,
            string person,
                        string dest_name,
      string dest,
      string relationship) {
   if (is_relationship(name, person, dest, relationship)) {
      real_remove_relationship(name,
                   person,
             dest,
             relationship);
      if (dest_name) {
         real_remove_relationship(dest_name,
                      dest,
                person,
                      query_opposite_relationship(relationship));
      }
      return 1;
   }
   return 0;
}
protected void check_family_information(string name,
                                        string member,
                                        int startup) {
   class family_info fam_data;
   string family;
   fam_data = query_family_info(name);
   if (fam_data) {
      if (member &&
         fam_data->relationships[member]) {
         family = PLAYER_HANDLER->test_family(member);
         if (!family ||
              normalise_name(family) != name) {
            if (find_player(member)) {
               find_player(member)->set_family_name(family);
            } else {
               log_file("CLUB", ctime(time()) +
                                ": removed " +
                                member + " from " + family +
                                " family deficent.\n");
               remove_member(name, member);
            }
         }
         if (!undefinedp(fam_data->relationships)) {
            map_delete(fam_data->relationships, member);
            set_club_changed(name);
         }
      }
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/club_inherit.c ===
inherit "/obj/handlers/inherit/club_discuss";
#define __CLUBS_H_NO_CLASSES
#define __MAIL_H_NO_CLASSES
#include <mail.h>
#include <clubs.h>
#include <player_handler.h>
#include <broadcaster.h>
#include <player.h>
#include <top_ten_tables.h>
#include <library.h>
#include <player_handler.h>
private nosave int _callout_id;
private nosave int _test_callout_id;
private string _current_test_club;
private int _last_test_time;
protected void check_extra_information(string name, string person, int startup);
void check_clubs(int startup);
class top_ten_tables {
   int num;
   int qp;
   int age;
   int start_time;
   int gender;
   int single_gender;
   int rels;
   int no_pks;
   mapping guild;
}
protected void setup_call_check_clubs(int time, int startup) {
   remove_call_out(_callout_id);
   _callout_id = call_out("check_clubs", time, startup);
}
private void send_low_balance_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         to -= ({ "unknown" });
         if (!sizeof(to)) {
            to = query_members(club);
         }
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   to = filter(to, (: PLAYER_HANDLER->test_user($1) :));
   if (sizeof(to)) {
      MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has fees due.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a reminder from the Patrician's Office "
                           "the " + bit + " '" + query_club_name(club) +
                           "' is currently in remission and "
                           "its balance will need to be updated before "
                           "the next "
                           "pay period or your " + bit + " will be "
                           "disbanded.\n\nYours happily,\nThe Patrician."));
   }
}
private void send_disband_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has been disbanded.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a message from the patricians "
                           "office to you that your " + bit +
                           " '" + query_club_name(club) +
                           "' has been disbanded for having its fees "
                           "in remission."
                           "\n\nYours happily,\nThe Patrician."));
}
protected void check_extra_information(string name,
                                       string member,
                                       int startup) {
   if (is_elected_club(name)) {
      check_elected_information(name, member, startup);
   } else if (is_family(name)) {
      check_family_information(name, member, startup);
   }
}
protected void check_club_members(string club_name,
                                string* members,
                                class top_ten_tables top_info) {
   int i;
   int tmp;
   string member;
   string str;
   string flip;
   class relationship_data *rels;
   class relationship_data frog;
   for (i = 0; i < 1 && i < sizeof(members); i++) {
      member = members[i];
      if (!PLAYER_HANDLER->test_user(member)) {
         log_file("CLUB", ctime(time()) + ": removed " + member +
                          " from " + club_name + " for not existing.\n");
         remove_member(club_name, member);
      } else if (!PLAYER_HANDLER->test_creator(member) &&
                 !PLAYER_HANDLER->test_property(member, "no score")) {
         top_info->num++;
         top_info->qp += LIBRARY->query_quest_points(member);
         tmp = -PLAYER_HANDLER->test_age(member) / (60 * 60);
         top_info->rels += sizeof(CLUB_HANDLER->query_relationships(club_name, member));
         top_info->age += tmp;
         top_info->start_time += PLAYER_HANDLER->test_start_time(member) / (60 * 60);
         str = PLAYER_HANDLER->test_guild(member);
         if (str &&
             str != "") {
            if (top_info->guild[str]) {
               top_info->guild[str]++;
            } else {
               if (file_size(str + ".c") > 0) {
                  flip = str->query_real_guild_object();
                  if (flip) {
                     str = flip;
                  }
                  top_info->guild[str]++;
               }
            }
         }
         if (PLAYER_HANDLER->test_player_killer(member)) {
            top_info->no_pks++;
         }
         if (!top_info->gender) {
            top_info->gender = PLAYER_HANDLER->test_gender(member);
         }
         if (top_info->single_gender != -1 &&
             PLAYER_HANDLER->test_gender(member) != top_info->gender) {
            top_info->single_gender = -1;
         }
      }
      if (is_family(club_name)) {
         check_family_information(club_name, member, 0);
         rels = CLUB_HANDLER->query_relationships(club_name, member);
         foreach (frog in rels) {
            if (!PLAYER_HANDLER->test_family(frog->related_to)) {
               log_file("CLUB", ctime(time()) + ": removed relationship " +
                          member +
                          " <-> " + frog->related_to + " (" +
                          frog->relationship + ") for loosing their "
                          "family.\n");
            }
         }
      }
   }
   members = members[1..];
   if (!sizeof(members)) {
      if (!sizeof(query_members(club_name))) {
         disband_club(club_name);
      } else if (top_info->num > 3) {
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_LARGEST_FAMILY,
                                         top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_FAMILY,
                                         top_info->age / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_QUEST_POINTS,
                                         top_info->qp / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_GUILD,
                                         top_info->guild);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_PKS,
                                         top_info->no_pks);
         if (top_info->single_gender != -1) {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            top_info->num);
         } else {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            0);
         }
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_LOGONS,
                                         top_info->start_time / top_info->num);
      }
      top_info = new(class top_ten_tables);
      top_info->guild = ([ ]);
      i = member_array(_current_test_club, query_clubs());
      if (i < sizeof(query_clubs())) {
         _current_test_club = query_clubs()[i+1];
         _test_callout_id = call_out("check_club_members", 60, _current_test_club, query_members(_current_test_club), top_info);
      } else {
         _current_test_club = 0;
         _test_callout_id = 0;
      }
      save_main();
   } else {
      _test_callout_id = call_out("check_club_members", 60, club_name, members, top_info);
   }
}
private nosave int _specific_callout_id = 0;
private nosave string *_clubs_to_check = ({ });
protected void check_specific_club(string club_name, int startup) {
    class club_info bing;
    bing = (class club_info)query_club_info(club_name);
    if (bing->last_touched < time() - CLUB_TIMEOUT) {
        disband_club(club_name);
        return;
    }
    if (!pointerp(query_members(club_name))) {
        disband_club(club_name);
        return;
    }
    if (query_time_fees_due(club_name) < time()) {
        if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
            send_disband_mail(club_name);
            disband_club(club_name);
            return;
        }
        if (remove_money(club_name, query_club_cost_per_period(club_name),
            CLUB_TRANSACTION_UPKEEP, "Club Dues",
            CLUB_DEFAULT_ACCOUNT_NAME, 0)) {
            int tmp;
            bing = (class club_info)query_club_info(club_name);
            tmp = bing->last_paid;
            bing->last_paid = query_time_fees_due(club_name);
            set_club_changed(club_name);
            if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
               reset_eval_cost();
               send_low_balance_mail(club_name);
            }
        }
    }
    call_out( (: check_extra_information :),  1,  club_name, 0,  startup);
}
protected void check_specific_clubs( int startup, int pos ) {
    string club_name;
    if ( pos >= sizeof( _clubs_to_check ) ) {
        _clubs_to_check = ({ });
        _specific_callout_id = 0;
        pos = 0;
        return;
    }
    club_name = _clubs_to_check[ pos ];
    tell_creator( "taffyd", "Checking club %s (%d)\n", club_name, pos );
    check_specific_club(club_name, startup);
    _specific_callout_id = call_out( (: check_specific_clubs :), 10, startup, ++pos );
}
void check_clubs(int startup) {
   class top_ten_tables blue;
   setup_call_check_clubs(24 * 60 * 60, 0);
   if ( !_specific_callout_id ) {
       _clubs_to_check = query_clubs();
        _specific_callout_id = call_out( (: check_specific_clubs :), 0,
            startup, 0 );
   }
   remove_call_out(_test_callout_id);
   if (!_current_test_club &&
       _last_test_time + 7 * 24 * 60 * 60 < time()) {
      if (sizeof(query_clubs()) > 0) {
         _current_test_club = query_clubs()[0];
      }
      _last_test_time = 0;
      save_main();
   }
   if (_current_test_club) {
      blue = new(class top_ten_tables);
      blue->guild = ([ ]);
      _test_callout_id = call_out("check_club_members",
                                 60,
                                 _current_test_club,
                                 query_members(_current_test_club),
                                 blue);
   }
}
#ifdef OLD_CHECK_CODE
protected void check_specific_club(string club_name, int extra_space,
                                   int startup) {
}
#endif

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/nomic_rules.c ===
#include <nomic_system.h>
private mapping _rules;
void save_me();
int query_can_change_rule(string area, class nomic_rule rule);
class nomic_rule find_nomic_rule(string area, string creator, string text);
void create() {
   _rules = ([ ]);
}
int add_nomic_rule(string area, int type, string creator, string text) {
   int bing;
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, creator, text)) {
      return NOMIC_ERROR;
   }
   nomic_rule = new(class nomic_rule);
   bing = _rules[area]->new_type_num[type];
   nomic_rule->id = bing;
   nomic_rule->creator = creator;
   nomic_rule->type = type;
   nomic_rule->text = text;
   nomic_rule->date_created = time();
   nomic_rule->amendments = ({ });
   _rules[area]->rules += ({ nomic_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int add_nomic_rule_class(string area,
                                   class nomic_rule new_rule,
                                   int type) {
   int bing;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, new_rule->creator, new_rule->text)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   new_rule->id = bing;
   new_rule->type = type;
   _rules[area]->rules += ({ new_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int move_nomic_rule(string area, class nomic_rule rule,
                              int type) {
   int bing;
   int i;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules[i]->id = bing;
         ((class nomic_rule)_rules[area]->rules[i])->type = type;
         _rules[area]->new_type_num[type] = bing + 1;
         save_me();
         return bing;
      }
   }
   return NOMIC_ERROR;
}
int change_nomic_rule(string area, class nomic_rule rule) {
   int i;
   if (!_rules[area]) {
      return 0;
   }
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         rule->type = ((class nomic_rule)_rules[area]->rules[i])->type;
         rule->id = ((class nomic_rule)_rules[area]->rules[i])->id;
         _rules[area]->rules[i] = rule;
         save_me();
         return 1;
      }
   }
   return 0;
}
int remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         if (!query_can_change_rule(area, nomic_rule)) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
int int_remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
class nomic_rule query_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         return copy(nomic_rule);
      }
   }
   return 0;
}
class nomic_rule* query_all_nomic_rules(string area) {
   if (!_rules[area]) {
      return ({ });
   }
   return copy(_rules[area]->rules);
}
class nomic_rule find_nomic_rule(string area, string creator, string text) {
   class nomic_rule rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (rule in _rules[area]->rules) {
      if (rule->creator == creator && rule->text == text) {
         return rule;
      }
   }
   return 0;
}
int create_area(string area) {
   class nomic_area new_area;
   if (_rules[area]) {
       return 0;
   }
   new_area = new(class nomic_area);
   new_area->new_type_num = NOMIC_DEFAULT_TYPE_NUMS;
   new_area->rules = ({ });
   _rules[area] = new_area;
   return 1;
}
int query_type_number(string name) {
   switch (lower_case(name)) {
   case "immutable" :
      return NOMIC_TYPE_IMMUTABLE;
   case "general" :
      return NOMIC_TYPE_GENERAL;
   case "citizen" :
      return NOMIC_TYPE_CITIZEN;
   default :
      return NOMIC_ERROR;
   }
}
string query_type_name(int type_no) {
   switch (type_no) {
   case NOMIC_TYPE_IMMUTABLE :
      return "immutable";
   case NOMIC_TYPE_GENERAL :
      return "general";
   case NOMIC_TYPE_CITIZEN :
      return "citizen";
   default :
      return "error";
   }
}
int query_can_change_rule(string area, class nomic_rule rule) {
   return rule->type != NOMIC_TYPE_IMMUTABLE;
}
string rule_as_string(int indent, class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
          (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + " by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):\n" + rule->text +
          "\n";
   foreach (amend in rule->amendments) {
      ret += "$I$" + (indent + 10) + "=" + sprintf("%*s", indent + 3, "") +
             capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):\n" +
             amend->text + "\n";
   }
   return ret;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/player_council.c ===
inherit "/obj/handlers/inherit/nomic_rules";
inherit "/obj/handlers/inherit/case_control";
inherit "/obj/handlers/inherit/citizen_elections";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#include <player.h>
private mapping _motions;
private mapping _new_citizens;
private int _completion_id;
void save_me();
class nomic_motion find_motion(string area, int rule_no, int type);
void update_immutables(string area);
void send_council_inform(string area, int only_magistrates,
                         string mess);
string motion_as_string(int indent, string area, class nomic_motion motion, int brief);
void create() {
   _motions = ([ ]);
   _new_citizens = ([ ]);
   citizen_elections::create();
   nomic_rules::create();
   case_control::create();
   _completion_id = call_out("check_for_completions",
       (time() - time() % (24 * 60 * 60) + (24 * 60 * 60) + (2 * 60)) - time());
}
void create_area(string area) {
   citizen_elections::create_area(area);
   nomic_rules::create_area(area);
   case_control::create_area(area);
   _motions[area] = ({ });
   _new_citizens[area] = ({ });
   update_immutables(area);
}
void update_immutables(string area) {
   string tmp;
   string type;
   string file;
   int int_type;
   class nomic_rule rule;
   foreach (rule in query_all_nomic_rules(area)) {
      if (rule->type == NOMIC_TYPE_IMMUTABLE) {
         remove_nomic_rule(area, rule->id);
      }
   }
   foreach (file in get_dir(NOMIC_RULE_DEFAULT_DIR)) {
      if (file_size(NOMIC_RULE_DEFAULT_DIR + "/" + file) > 0) {
         tmp = read_file(NOMIC_RULE_DEFAULT_DIR + "/" + file);
         type = explode(tmp, "\n")[0];
         tmp = implode(explode(tmp, "\n")[1..], "\n");
         switch (type) {
         case "immutable" :
            int_type = NOMIC_TYPE_IMMUTABLE;
            break;
         case "citizen" :
            int_type = NOMIC_TYPE_CITIZEN;
            break;
         case "general" :
            int_type = NOMIC_TYPE_GENERAL;
            break;
         default :
            int_type = -1;
            printf("Ignoring file " + file + "\n");
            break;
         }
         if (int_type != -1) {
            add_nomic_rule(area, int_type, area + " administrator", tmp);
         }
      }
   }
   save_me();
}
private int query_next_motion_id(string area) {
   int num;
   class nomic_motion fluff;
   num = 1;
   foreach (fluff in _motions[area]) {
      if (num <= fluff->identifier) {
         num = fluff->identifier + 1;
      }
   }
   return num;
}
int add_create_rule_motion(string area, int type, string text,
                          string creator) {
   class nomic_motion fluff;
   if (!is_magistrate_of(area, creator)) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_ADD;
   fluff->rule = new(class nomic_rule);
   fluff->rule->creator = creator;
   fluff->rule->text = text;
   fluff->rule->type = type;
   fluff->rule->amendments = ({ });
   fluff->rule->date_created = time();
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a new rule motion");
   post_magistrate_message(area, "New: Create rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int add_move_rule_type_motion(string area, int rule_no, int type,
                              string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   if (bing->type == type) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_MOVE);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_MOVE;
   fluff->rule = bing;
   fluff->new_rule_type = type;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a move rule motion");
   post_magistrate_message(area, "New: Move rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int add_amend_rule_motion(string area, int rule_no, string amendment,
                           string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   class nomic_amendment amend;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_AMEND);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_AMEND;
   amend = new (class nomic_amendment);
   amend->amender = creator;
   amend->text = amendment;
   amend->date_amended = time();
   bing->amendments += ({ amend });
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added an add rule motion");
   post_magistrate_message(area, "New: Ammend rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int remove_rule_motion(string area, int rule_no, string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_REMOVE);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_REMOVE;
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a remove rule motion");
   post_magistrate_message(area, "New: Remove rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
class nomic_motion query_motion(string area, int id) {
   class nomic_motion fluff;
   if (!_motions[area]) {
      return 0;
   }
   foreach (fluff in _motions[area]) {
      if (fluff->identifier == id) {
         return fluff;
      }
   }
   return 0;
}
class nomic_motion* query_all_motions(string area) {
   if (!_motions[area]) {
      return ({ });
   }
   return copy(_motions[area]);
}
class nomic_motion find_motion(string area, int rule_no, int type) {
   class nomic_motion motion;
   foreach (motion in _motions[area]) {
      if (motion->rule->id == rule_no &&
          motion->motion_type == type) {
         return motion;
      }
   }
   return 0;
}
int comment_on_motion(string area, int id, string comment_text,
                            string commenter) {
   class nomic_comment comment;
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW &&
       bing->state != NOMIC_STATE_COUNCIL_VOTE) {
      return 0;
   }
   comment = new(class nomic_comment);
   comment->text = comment_text;
   comment->commenter = commenter;
   comment->date_commented = time();
   bing->comments += ({ comment });
   save_me();
   return 1;
}
int amend_motion(string area, int id, string amend_text,
                    string amender) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW) {
      return 0;
   }
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      bing->rule->text = amend_text;
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      return 0;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      bing->rule->amendments[<1]->text = amend_text;
   }
   save_me();
   return 1;
}
int vote_for_motion(string area, int id, int vote_type, string voter) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (member_array(voter, bing->voted) != -1) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_VOTE &&
       bing->state != NOMIC_STATE_CITIZEN_VOTE) {
      return 0;
   }
   switch (vote_type) {
   case NOMIC_VOTE_YES :
      bing->yes_votes++;
      break;
   case NOMIC_VOTE_NO :
      bing->no_votes++;
      break;
   case NOMIC_VOTE_ABSTAIN :
      bing->abstain_votes++;
      break;
   default :
      return 0;
   }
   bing->voted += ({ voter });
   save_me();
   return 1;
}
int has_voted_for_motion(string area, int id, string voter) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   return member_array(voter, bing->voted) != -1;
}
int* query_votes_for_motion(string area, int id) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   return ({ bing->yes_votes, bing->no_votes, bing->abstain_votes });
}
private void remove_motion(string area, class nomic_motion motion) {
   int i;
   for (i = 0; i < sizeof(_motions[area]); i++) {
      if (_motions[area][i] == motion) {
         _motions[area] = _motions[area][0..i-1] + _motions[area][i+1..];
      }
   }
}
void send_council_inform(string area, int only_magistrates,
                         string mess) {
   object *obs;
   if (only_magistrates) {
      obs = filter(users(), (: is_magistrate_of($2, $1->query_name()) :), area);
   } else {
      obs = filter(users(), (: is_citizen_of($2, $1->query_name()) :), area);
   }
   call_other(obs, "event_inform", this_object(), mess, "council");
}
int query_completion_time(string area, class nomic_motion motion) {
   return (motion->date_event - motion->date_event % (24 * 60 * 60) +
           7 * (24 * 60 * 60));
}
int complete_motion(string area, int id) {
   class nomic_motion bing;
   class nomic_motion motion;
   int passed;
   int new_num;
   string mess;
   int only_magistrates;
   string voting_result;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   passed = bing->yes_votes > bing->no_votes;
   voting_result = "Voting Results:\n"
                   "    Yes: " + bing->yes_votes + "\n"
                   "     No: " + bing->no_votes + "\n"
                   "Abstain: " + bing->abstain_votes + "\n";
   mess = "Motion added by " + bing->added_by + " to ";
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      mess += "add a new rule";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      mess += "remove rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      mess += "move rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      mess += "amend rule " + bing->rule->id;
      break;
   }
   if (passed || bing->state == NOMIC_STATE_COUNCIL_REVIEW) {
      switch (bing->state) {
      case NOMIC_STATE_COUNCIL_REVIEW :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_COUNCIL_VOTE;
         mess += " is open for magistrates to vote";
         only_magistrates = 1;
         post_magistrate_message(area, "Motion now in voting phase",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_COUNCIL_VOTE :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_CITIZEN_VOTE;
         bing->comments = ({ });
         mess += " is open for citizens to vote";
         post_magistrate_message(area, "Law passed onto citizens",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                              "\n\n" + voting_result);
         post_citizen_message(area, "New motion for voting on",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_CITIZEN_VOTE :
         switch (bing->motion_type) {
         case NOMIC_MOTION_TYPE_RULE_ADD :
            add_nomic_rule_class(area, bing->rule, bing->motion_type);
            break;
         case NOMIC_MOTION_TYPE_RULE_AMEND :
            change_nomic_rule(area, bing->rule);
            break;
         case NOMIC_MOTION_TYPE_RULE_MOVE :
            new_num = move_nomic_rule(area, bing->rule, bing->new_rule_type);
            foreach (motion in _motions[area]) {
               if (motion->rule->id == bing->rule->id) {
                  motion->rule->id = new_num;
               }
            }
            break;
         case NOMIC_MOTION_TYPE_RULE_REMOVE :
            remove_nomic_rule(area, bing->rule->id);
            break;
         }
         remove_motion(area, bing);
         mess += " is now law";
         post_citizen_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)));
         post_magistrate_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                    "\n\n" + voting_result);
         break;
      }
      bing->date_event = time();
   } else {
      if (bing->state == NOMIC_STATE_COUNCIL_VOTE) {
         mess += " not passed by the magistrates";
         only_magistrates = 1;
         post_magistrate_message(area, "Law not passed onto citizens",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      } else {
         mess += " not ratified by the citizens";
         only_magistrates = 0;
         post_citizen_message(area, "Law not passed",
                              rule_as_string(0, bing->rule));
         post_magistrate_message(area, "Law not passed",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      }
      remove_motion(area, bing);
   }
   save_me();
   send_council_inform(area, only_magistrates, mess);
   return 1;
}
void check_for_completions() {
   string area;
   class nomic_motion* bits;
   class nomic_motion motion;
   foreach (area, bits in _motions) {
      foreach (motion in bits) {
         if (query_completion_time(area, motion) < time()) {
            complete_motion(area, motion->identifier);
         }
      }
   }
   remove_call_out(_completion_id);
   _completion_id = call_out("check_for_completions",
            (time() - time() % (24 * 60 * 60) + (24 * 60 * 60)) - time());
   update_recently_closed_cases();
}
string motion_as_string(int indent, string area, class nomic_motion motion,
                        int brief) {
   string ret;
   class nomic_comment comment;
   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   }
   ret += rule_as_string(5 + indent, motion->rule);
   if (sizeof(motion->comments)) {
      if (!brief) {
         ret += "$I$" + (indent + 5) + "=     Comments:\n";
         foreach (comment in motion->comments) {
            ret += "$I$" + (indent + 11) + "=" + sprintf("%*s", indent + 3, "") +                capitalize(comment->commenter) + " (" +
                   ctime(comment->date_commented) + "):\n" +
                   comment->text + "\n";
         }
      } else {
         ret += "$I$0=" + sprintf("%*s", indent, "") + "     " +
                 sizeof(motion->comments) + " Comments.\n";
      }
   } else {
      ret += "$I$0=" + sprintf("%*s", indent, "") + "     No Comments.\n";
   }
   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being ratified by the citizens.\n";
      break;
   }
   ret += "$I$0=" + sprintf("%*s", indent, "") +
          "The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";
   return ret;
}
string rule_as_html(class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "<i><b>" + (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + "</b> by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):</i>\n"
          "<p style=\"margin-left: 30pt;margin-top: 5pt\">\n" +
          replace_string(rule->text, "\n", "<br>") +
          "<br>\n";
   foreach (amend in rule->amendments) {
      ret += "<i><b>Ammendment</b> by " + capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):</i>\n"
             "<p style=\"margin-left: 60pt;margin-top: 5pt\">\n" +
             replace_string(amend->text, "\n", "<br>") +
             "\n</p>\n";
   }
   ret += "</p>\n";
   return ret;
}
string motion_as_html(string area, class nomic_motion motion) {
   string ret;
   class nomic_comment comment;
   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "<b>" + motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "<b>" + motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "<b>" + motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "<b>" + motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   }
   ret += "<ul>" + rule_as_html(motion->rule) + "</ul>";
   if (sizeof(motion->comments)) {
      ret += "<b>Comments:</b><br>\n";
      foreach (comment in motion->comments) {
         ret += ctime(comment->date_commented) + "):<br>\n" +
                comment->text + "<p>\n";
      }
   }
   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "The item is currently being ratified by the citizens.\n";
      break;
   }
   ret += "<br>The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";
   return ret;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/error_handler.c ===
#include <db.h>
#include <error_handler.h>
#define SAVE_FILE "/save/handlers/error_handler"
#define ERROR_SUMMARY_FIELDS "id, entrydate, filename, type, category, name, reporter, status, directory"
#define ERROR_DETAILS_FIELDS ERROR_SUMMARY_FIELDS \
                      ", report, runtime"
#define ERROR_REPLY_TIMEOUT (60 * 60 * 24 * 7 * 4)
void finish_update(int type, mixed data, function finished, string query);
private string _db;
private string _user;
private string _password;
void create() {
   unguarded( (: restore_object(SAVE_FILE) :) );
   DB_HANDLER->make_sql_request(_db, _user, _password,
                 "delete from error_replies where senddate < " +
                 (time() - ERROR_REPLY_TIMEOUT), (: 1 :));
}
protected void setup_error_handler(string user, string db, string password) {
   _user = user;
   _db = db;
   _password = password;
   save_object(SAVE_FILE);
}
protected string build_sql_query(string select_rows, class error_query query) {
   string* restrict;
   string name;
   string tmp;
   restrict = ({ });
   if (query->id != 0) {
      restrict += ({ "id = " + query->id });
   }
   if (query->dir) {
      if (query->dir[<1] == '/') {
         query->dir = query->dir[0..<2];
      }
      if (query->recursive) {
         restrict += ({ "directory like '" + query->dir + "%'" });
      } else {
         restrict += ({ "directory = '" + query->dir + "'" });
      }
   }
   if (query->assigned_to) {
      restrict += ({ "AssignedTo = '" + query->assigned_to + "'" });
   }
   if (query->reporter) {
      restrict += ({ "Reporter = '" + query->reporter + "'" });
   }
   if (query->file_name) {
      restrict += ({ "FileName = '" + query->file_name + "'" });
   }
   if (sizeof(query->type)) {
      tmp = "Type in (";
      foreach (name in query->type) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->status)) {
      tmp = "Status in (";
      foreach (name in query->status) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->category)) {
      tmp = "Category in (";
      foreach (name in query->category) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(restrict)) {
      tmp = "select " + lower_case(select_rows) + " from errors where " +
             implode(restrict, " and ");
      switch (query->order_by) {
      case ERROR_ORDER_BY_FILENAME :
         tmp += " order by filename, entrydate";
         break;
      case ERROR_ORDER_BY_DATE :
         tmp += " order by entrydate";
         break;
      case ERROR_ORDER_BY_REPORTER :
         tmp += " order by reporter, entrydate";
         break;
      case ERROR_ORDER_BY_DIRECTORY :
      default :
         tmp += " order by directory, filename, entrydate";
         break;
      }
      return tmp + " limit 150";
   }
   return 0;
}
string build_sql_update(int id, string field, mixed value) {
   string ret;
   ret = "update errors set " + field + " = ";
   if (stringp(value)) {
      ret += "'" + value + "'";
   } else {
      ret += "" + value;
   }
   ret += " where id = " + id;
   return ret;
}
class error_forward create_error_forward(mapping map) {
   class error_forward newy;
   newy = new(class error_forward);
   newy->date = map["forwarddate"];
   newy->forwarder = map["forwarder"];
   newy->old_directory = map["olddirectory"];
   return newy;
}
class error_comment create_error_comment(mapping map) {
   class error_comment newy;
   newy = new(class error_comment);
   newy->date = map["commentdate"];
   newy->commenter = map["commenter"];
   newy->comment = map["comment"];
   return newy;
}
class error_summary create_error_summary(mapping map) {
   class error_summary newy;
   newy = new(class error_summary);
   newy->id = map["id"];
   newy->entry_date = map["entrydate"];
   newy->filename = map["filename"];
   newy->category = map["category"];
   newy->assigned_to = map["assignedto"];
   newy->reporter = map["reporter"];
   newy->status = map["status"];
   newy->type = map["type"];
   newy->directory = map["directory"];
   return newy;
}
class error_details create_error_details(mapping map) {
   class error_details newy;
   newy = new(class error_details);
   newy->summary = create_error_summary(map);
   newy->fix_date = map["fixdate"];
   newy->fixer = map["fixer"];
   newy->report = map["report"];
   newy->runtime = map["runtime"];
   return newy;
}
class error_complete create_error_complete(class error_details details) {
   class error_complete newy;
   newy = new(class error_complete);
   newy->details = details;
   newy->comments = ({ });
   newy->forwards = ({ });
   newy->replies = ({ });
   return newy;
}
class error_replies create_error_replies(mapping map) {
   class error_replies reply;
   reply = new(class error_replies);
   reply->id = map["id"];
   reply->bug_id = map["bug_id"];
   reply->sender = map["sender"];
   reply->status = map["status"];
   reply->recipient = map["recipient"];
   reply->senddate = map["senddate"];
   reply->subject = map["subject"];
   reply->message = map["message"];
   return reply;
}
void finish_summary(int type, mixed data, function finished, string query) {
   class error_summary* errors;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      foreach (map in data) {
         errors += ({ create_error_summary(map) });
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_forwards(int type, mixed data, function finished,
                     class error_complete* errors, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->forwards += ({ create_error_forward(map) });
            }
         }
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_details_error_replies(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["bug_id"]) {
               detail->replies += ({ create_error_replies(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select id,forwarddate,forwarder,olddirectory from "
                     "forwards where id in " + ids +
                     " order by forwarddate",
                     (: finish_forwards($1, $2, $(finished), $(errors), $(query)) :));
   }
}
void finish_comments(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->comments += ({ create_error_comment(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select * from "
                     "error_replies where bug_id in " + ids +
                     " order by senddate",
                     (: finish_details_error_replies($1, $2, $(finished), $(errors), $(ids), $(query)) :));
   }
}
void finish_details(int type, mixed data, function finished, string query) {
   class error_complete* errors;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      str = "(";
      foreach (map in data) {
         errors += ({ create_error_complete(create_error_details(map)) });
         str += map["id"] + ",";
      }
      str = str[0..<2] + ")";
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select commentdate,commenter,comment,id "
                     "from comments where id in " + str +
                     " order by commentdate desc",
                     (: finish_comments($1, $2, $(finished), $(errors), $(str), $(query)) :));
   }
}
void finish_forward_query(int type, mixed data, function finished,
                          string user, string newdir) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (error->details->summary->directory != newdir) {
         str = "insert into forwards (id,forwarddate,forwarder,olddirectory) " +
               "values (" + error->details->summary->id + ", " + time() + ", '" +
               db_escape(user) + "', '" +
               db_escape(error->details->summary->directory) +
               "')";
         DB_HANDLER->make_sql_request(_db, _user, _password,
                     str, (: 1 :));
         str = build_sql_update(error->details->summary->id, "directory", newdir);
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                 (: finish_update($1, $2, $(finished), $(str)) :));
      } else {
         evaluate(finished, type, data);
      }
   }
}
void finish_status_query(int type, mixed data, function finished,
                         string status,
                         int nomail, string user, string subject,
                         string message) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (!nomail) {
         str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
               "values (" +
               error->details->summary->id + ", 'NEW', '" + user + "', '" +
               error->details->summary->reporter + "', " +
               time() + ", '" +
               "Change status from " + error->details->summary->status +
               " to " + status +
               "\n" + db_escape(message) + "', '" + db_escape(subject) + "')";
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                 (: 1 :) );
      }
      str = build_sql_update(error->details->summary->id, "status", status);
      if (!str) {
         return 0;
      }
      DB_HANDLER->make_sql_request(_db, _user, _password, str,
                            (: finish_update($1, $2, $(finished), $(str)) :));
   }
}
void finish_update(int type, mixed data, function finished, string query) {
   evaluate(finished, type, data, query);
}
void finish_error_replies(int type, mixed data, function finished, string query) {
   class error_replies* replies;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      replies = ({ });
      foreach (map in data) {
         replies += ({ create_error_replies(map) });
      }
      evaluate(finished, type, replies);
   }
}
int do_query_bug_summary(class error_query query, function finished) {
   string str;
   str = build_sql_query(ERROR_SUMMARY_FIELDS,
                         query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                   (: finish_summary($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_bug_details(int bug_id, function finished) {
   string str;
   class error_query query;
   query = new(class error_query);
   query->id = bug_id;
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_details($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_open_bugs_in_dir(string dir, function finished) {
   class error_query query;
   query = new(class error_query);
   query->dir = dir;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_for_fname(string fname, function finished) {
   class error_query query;
   query = new(class error_query);
   query->file_name = fname;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_by_reporter(string reporter, function finished) {
   class error_query query;
   query = new(class error_query);
   query->reporter = reporter;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_change_type(int id, string type, function finished) {
   string str;
   str = build_sql_update(id, "type", type);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_category(int id, string category, function finished) {
   string str;
   str = build_sql_update(id, "category", category);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_assign_bug_to(int id, string assigned_to, function finished) {
   string str;
   str = build_sql_update(id, "assignedto", assigned_to);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_status(int id, string status, int nomail, string subject,
                     string user, string message, function finished) {
   string str;
   class error_query query;
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_status_query($1, $2, $(finished), $(status),
                                    $(nomail), $(user), $(subject),
                                     $(message)) :));
   return 1;
}
int do_forward(int id, string user, string dir, function finished) {
   string str;
   class error_query query;
   if (!strlen(dir)) {
      return 0;
   }
   if (dir[0] != '/') {
      dir = "/" + dir;
   }
   if (dir[<1] == '/') {
      dir = dir[0..<2];
   }
   if (file_size(dir) != -2 || dir == "/") {
      return 0;
   }
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_forward_query($1, $2, $(finished), $(user), $(dir)) :));
   return 1;
}
int do_comment(int id, string user, string comment, function finished) {
   string str;
   str = "insert into comments (id,commentdate,commenter,comment) values (" +
         id + ", " + time() + ", '" + user + "', '" + db_escape(comment) +
         "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                             (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_error_replies(string recipient, int only_new, function finished) {
   string str;
   str = "select * from error_replies where recipient = '" + recipient +
         "'";
   if (only_new) {
      str += " and status = 'NEW'";
   } else {
      str += " and status != 'DELETED'";
   }
   str += " order by senddate";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_error_replies($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_status_error_reply(int id, string status, function finished) {
   string str;
   str = "update error_replies set status = '" + status + "' where id = " +
         id;
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_add_error_reply(int bug_id, string from, string to, string subject, string message) {
   string str;
   str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
         "values (" + bug_id + ", 'NEW', '" + from + "', '" + to + "', " +
         time() + ", '" +
         db_escape(message) + "', '" + db_escape(subject) + "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
           (: 1 :) );
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inherit/club_personal.c ===
inherit "/obj/handlers/inherit/club_basic";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
class personal_info {
}
protected void create_extra_data(string name) {
   class personal_info p_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_PERSONAL) {
         p_info = new(class personal_info);
      data->extra_data = p_info;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
}
private class personal_info query_personal_info(string name) {
   class club_info data;
   if (is_personal_club(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
   return 0;
}
