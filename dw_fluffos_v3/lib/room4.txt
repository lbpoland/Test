
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/council_treasury.c ===
inherit "/std/room";
inherit "/std/room/inherit/council_base";
#define TWO_WEEKS (60 * 60 * 24 * 7 * 2)
#define READ_LOG 1
#define DEPOSIT 2
#define MAGISTRATE 2
#define CITIZEN 1
#define ANYONE 0
#define COUNCIL_LOG_WITHDRAW_INDEX 0
#define COUNCIL_LOG_DEPOSIT_INDEX  1
#include <money.h>
#include <move_failures.h>
#include <nomic_system.h>
private nosave string _save_file;
private nosave string _archive;
private int _balance = 200;
private int _read;
private int _dep;
private int *_log;
int do_withdraw(int,
                string,
                string);
int do_deposit(int);
int do_check();
class transaction {
   string person;
   int amount;
   string reason;
   int date;
   string action;
}
class transaction *transactions = ({ });
void save_me()
{
   if (!_save_file) {
      debug_printf("Error: No save file set.\n");
      return;
   }
   unguarded((: save_object, _save_file :));
   return;
}
void load_me()
{
   if (!_save_file)
      return;
   if (file_size(_save_file + ".o") > 0) {
      unguarded((: restore_object, _save_file :));
      return;
   }
   return;
}
int security_check(object player,
                   int type)
{
   int person;
   int tmp;
   if (!type)
      return -1;
   if (!player)
      return -1;
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(), this_player()->query_name())) {
      person = 2;
   }
   if (NOMIC_HANDLER->is_citizen_of(query_council_area(), this_player()->query_name())) {
      person = 1;
   } else {
      person = 0;
   }
   if (type == READ_LOG)
      tmp = _read;
   if (type == DEPOSIT)
      tmp = _dep;
   switch (tmp) {
   case MAGISTRATE:
      return (person == 2);
      break;
   case CITIZEN:
      return (person >= 1);
      break;
   case ANYONE:
      return 1;
   }
}
void check_time()
{
   string str;
   while (transactions[0]->date + TWO_WEEKS < time()) {
      str =
         capitalize(transactions[0]->person) + " " + transactions[0]->action +
         " " + MONEY_HAND->money_value_string(transactions[0]->amount, query_property("place"));
      str +=
         (transactions[0]->action ==
          "withdrew" ? " for " + transactions[0]->reason : "");
      str += " on " + amtime(transactions[0]->date) + ".\n";
      log_file(_archive, str, 0);
      transactions = transactions[1..];
   }
}
void log_action(object player,
                int amount,
                string action,
                string word)
{
   string reason = (word ? word : "no reason specified");
   class transaction new_trans;
   if (!player)
      return;
   if (!amount)
      return;
   if (!action)
      return;
 new_trans = new (class transaction, person: player->query_name(), amount: amount, reason: reason, date: time(), action:action);
   transactions += ({ new_trans });
   check_time();
   save_me();
}
varargs int view_transactions(string player)
{
   int i;
   int f;
   string ret;
   if (!security_check(this_player(), READ_LOG)) {
      return
         add_failed_mess("You aren't allowed to view the transactions.\n");
   }
   ret = "A peek at the log book reveals:\nTransactions\n---\n\n";
   if (!sizeof(transactions)) {
      ret += "None so far.\n";
      write("$P$Transactions$P$" + ret);
      return 1;
   }
   if(player) {
      for(i = 0; i <sizeof(transactions); i++) {
         if (transactions[i]->person != lower_case(player)) {
            continue;
         }
            ret += capitalize(transactions[i]->person) + " " +
                transactions[i]->action + " " +
                MONEY_HAND->money_value_string(transactions[i]->amount,
                query_property("place")) +
                (transactions[i]->action ==
                "withdrew" ? " for " + transactions[i]->reason : "") +
                " on " + amtime(transactions[i]->date)
                + ".\n";
      }
   } else {
      for (i = 0; i < sizeof(transactions); i++) {
      ret += capitalize(transactions[i]->person) + " " +
          transactions[i]->action + " " +
          MONEY_HAND->money_value_string(transactions[i]->amount,
          query_property("place")) +
          (transactions[i]->action ==
          "withdrew" ? " for " + transactions[i]->reason : "") +
          " on " + amtime(transactions[i]->date)
          + ".\n";
      }
   }
   write("$P$Transactions$P$" + ret);
   return 1;
}
void create()
{
   set_short("council treasury");
   set_long("This is the treasury for the council.\n");
   ::create();
   load_me();
   add_help_file( "council_treasury" );
}
void init()
{
   ::init();
   this_player()->add_command("withdraw", this_object(), "<number'amount'> "
                              "<string'type'> for <string'reason'>",
                              (: do_withdraw($4[0], $4[1], $4[2]) :));
   this_player()->add_command("deposit", this_object(), "<string>",
                              (: do_deposit($4[0]) :));
   this_player()->add_command("check", this_object(), "balance");
   this_player()->add_command("view", this_object(),
                              "transactions",
                              (: view_transactions() :));
   this_player()->add_command("view", this_object(),
                              "transactions [by] <word'player'>",
                              (: view_transactions($4[0]) :));
}
void set_save_file(string file)
{
   _save_file = file;
}
void set_place(string word)
{
   add_property("place", word);
}
int do_check()
{
   write("The treasury contains " + MONEY_HAND->money_value_string(_balance,
                                                                   query_property("place")) +
         ".\n");
   return 1;
}
int do_withdraw(int number,
                string type,
                string reason)
{
   int amount;
   int best;
   object money;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(), this_player()->query_name())) {
      notify_fail("You must be a magistrate to withdraw funds.\n");
      return 0;
   }
   if (number <= 0) {
      notify_fail("You must withdraw something.\n");
      return 0;
   }
   money = clone_object(MONEY_OBJECT);
   money->set_money_array((mixed *) MONEY_HAND->query_values_in(query_property("place")));
   if ((best = (int) money->find_best_fit(type)) == -1) {
      notify_fail("That currency is not legal tender here.  Sorry.\n");
      money->dest_me();
      return 0;
   }
   type = ((mixed *) money->query_money_array())[best];
   amount = number * ((mixed *) money->query_money_array())[best + 1];
   if ((amount > _balance) || (amount < 0)) {
      notify_fail("There isn't that much in the account.\n");
      money->dest_me();
      return 0;
   }
   money->set_money_array(({ type, number }));
   _balance -= amount;
   save_me();
   this_player()->add_succeeded_mess(this_object(),
                                     ({ "You withdraw " +
                                        (string) money->short() + ".\n" +
                                        "There is " +
                                        (string) MONEY_HAND->
                                        money_value_string(_balance,
                                                           query_property("place")) +
                                        " in your account after the withdrawal.\n",
                                        "$N withdraws some money from the treasury.\n" }),
                                     ({ }));
   if ((int) money->move(this_player()) != MOVE_OK) {
      write
         ("You are too heavily burdened to collect the money, so the teller "
          + "puts it on the counter for you.\n");
      money->move(this_object());
   }
   if (_log[COUNCIL_LOG_WITHDRAW_INDEX]) {
      log_action(this_player(), amount, "withdrew", reason);
   }
   this_player()->save();
   return 1;
}
int do_deposit(string words)
{
   int amount;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;
   if (!security_check(this_player(), DEPOSIT)) {
      return add_failed_mess("You are not allowed to deposit.\n");
   }
   money = (mixed) MONEY_HAND->parse_money(words, this_player(), query_property("place"));
   if (intp(money)) {
      switch (money) {
      case NO_MATCH:
         return notify_fail("You do not have \"" + words + "\".\n");
      case NO_MONEY:
         return notify_fail("You can only deposit money.\n");
      default:
         return notify_fail("You can only deposit legal tender.\n");
      }
   }
   tender = MONEY_HAND->filter_legal_tender(money, query_property("place"));
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
      amount = legal->query_value_in(query_property("place"));
      if (amount < 200) {
         legal->move(this_player());
         if (illegal) {
            illegal->move(this_player());
         }
         add_failed_mess("That is too small an amount to deposit.\n");
         return 0;
      }
      _balance += amount;
      save_me();
   }
   if (illegal) {
      illegal->move(this_player());
   }
   if (legal) {
      howmuch = legal->the_short();
      legal->move("/room/rubbish");
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }
   write("You give the teller " + howmuch + ".\n");
   this_player()->add_succeeded_mess(this_object(),
                                     ({ "$N $V " + words + ".\n"
                                        "This gives a total of " +
                                        MONEY_HAND->
                                        money_value_string(_balance,
                                                           query_property("place")) +
                                        " in the treasury.\n",
                                        "$N deposits some money into the treasury.\n" }),
                                     ({ }));
   if (_log[COUNCIL_LOG_DEPOSIT_INDEX])
      log_action(this_player(), amount, "deposited", "");
   return 1;
}
void set_security_levels(int read_log,
                         int deposits,
                         int *logging)
{
   _read = read_log;
   _dep = deposits;
   _log = logging;
}
void set_archive(string word)
{
   _archive = word;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/rooftop.c ===
#include <tasks.h>
#define TOO_SOON "too soon to proceed from rooftop"
inherit "/std/room/outside";
#define DEBUG
#define ROCK "other.movement.climbing.rock"
#define ROPE "other.movement.climbing.rope"
void   set_death_reason( string );
void   set_fall_damage( string, int );
mixed  query_fall_damage( string );
int    calc_fall_damage( string );
void   set_weak_roof( int, string );
void   set_slope( int, string, string );
string process_string( string, mapping );
string process_mess( string, object, string );
mapping  damages;
string * damage_types;
int      roof_max_weight;
int      gradient;
string   weak_roof_dest;
string   slope_dest;
string   place;
string   death_reason;
string * weak_messages;
string * slope_messages;
string * step_messages;
string * jump_tm_messages;
string * jump_success_messages;
string * jump_failure_messages;
string * ghost_fall_messages;
string * item_slope_messages;
string * corpse_slope_messages;
mapping jump_info;
mapping translations;
void init() {
   ::init();
   add_command( "jump", "<word'direction'>",
     (: this_object()->do_roofjump( $4[0] ) :) );
}
void create() {
   do_setup++;
   ::create();
   do_setup--;
   weak_messages = ({
     "The roof collapses! This is going to be painful...\n",
     "$short$ crashes down through a weak spot in the roof.",
     "$short$ comes crashing to the ground, landing in a rain of debris.",
     "You hear an ominous creak.\n"
   });
   slope_messages = ({
     "The roof is too steep for you to stand on! It's time to make friends "
       "with the floor...\n",
     "$short$ gets in touch with gravity and slides over the edge of the "
       "roof.",
     "$short$ comes crashing to the ground, landing in a heap."
   });
   step_messages = ({
     "You step off the edge of the roof into midair.\n",
     "$short$ steps off the edge of the roof and plummets earthwards.",
     "$short$ comes crashing to the ground, landing in a heap."
   });
   jump_tm_messages = ({
     "You leap more gracefully through the air.",
     "You feel more able to leap tall buildings in a single bound.",
     "You jump like a mountain goat."
   });
   jump_success_messages = ({
     "You launch yourself off the edge of the roof and land gracefully on "
       "the other side.\n",
     "$short$ jumps gracefully across the gap to the $dir$.",
     "$short$ jumps in from across the gap to the $opp_dir$."
   });
   jump_failure_messages = ({
     "You launch yourself off the edge of the roof!\nUnfortunately you "
       "misjudge the distance and plummet earthwards. This is going to "
       "hurt...\n",
     "$short$ jumps off to the $dir$, but misjudges and plummets "
       "earthwards.",
     "$short$ plummets to the ground, landing in a heap."
   });
   ghost_fall_messages = ({
      "You find your consciousness drifting earthwards.\n",
      "$the_short$ drifts earthwards.",
      "$the_short$ drifts in from above, looking somewhat dazed."
   });
   item_slope_messages = ({
     "$the_short$ tumbles over the edge and plummets to the ground.\n",
     "Hearing a noise, you look up just as $a_short$ falls off the edge "
       "of the roof and hits the ground.\n"
   });
   corpse_slope_messages = ({
     "$the_short$ tumbles over the edge and plummets to the ground with "
       "a sickening thud.\n",
     "Hearing a noise, you look up just as $the_short$ tumbles over the "
       "edge of the roof and hits the ground with a sickening thud.\n"
   });
   damages = ([ ]);
   damage_types = ({ "weak", "slope", "step", "jump" });
   translations = ([ ]);
   jump_info = ([ ]);
   this_object()->setup();
}
void set_weak_messages( string player, string from, string to, string warn ) {
   weak_messages = ({ player, from, to, warn });
}
void set_slope_messages( string player, string from, string to ) {
   slope_messages = ({ player, from, to });
}
void set_step_messages( string player, string from, string to ) {
   step_messages = ({ player, from, to });
}
void set_jump_tm_messages( string * messages ) {
   jump_success_messages = messages;
}
void set_jump_success_messages( string player, string from, string to ) {
   jump_success_messages = ({ player, from, to });
}
void set_jump_failure_messages( string player, string from, string to ) {
   jump_failure_messages = ({ player, from, to });
}
void set_ghost_fall_messages( string player, string from, string to ) {
   ghost_fall_messages = ({ player, from, to });
}
void set_corpse_slope_messages( string from, string to ) {
  corpse_slope_messages = ({ from, to });
}
void set_item_slope_messages( string from, string to ) {
   item_slope_messages = ({ from, to });
}
void set_fall_damage( string type, int damage ) {
   if( damage < 0 )
      damage = -damage;
   if( type == "all" ) {
      foreach( type in damage_types )
         damages[type] = damage;
   } else if( member_array( type, damage_types ) >= 0 ) {
      damages[type] = damage;
   } else
      return;
}
mixed query_fall_damage( string type ) {
   if( type == "all" )
      return damages;
   else
      return damages[type];
}
int calc_fall_damage( string type ) {
   if( type == "all" )
      return 0;
   return query_fall_damage( type ) + random( query_fall_damage( type ) );
}
void set_weak_roof( int maxweight, string dest ) {
   roof_max_weight = maxweight;
   weak_roof_dest = dest;
}
void set_slope( int angle, string loc, string dest ) {
   gradient = ( angle * 100 ) / 90;
   place = loc;
   slope_dest = dest;
}
int set_jump( mixed dir, string dest, string fall_dest, int distance ) {
   string * dirs;
   mixed foo;
   string bar;
   if( stringp( dir ) ) {
      dirs = ({ dir });
   } else if( arrayp(dir) ) {
      foreach( foo in dir )
         if( !stringp( foo ) )
            return 0;
      dirs = sort_array( dir, 1 );
   }
   foreach( bar in dir )
      if( !undefinedp( translations[bar] ) )
         return -1;
   jump_info[ dir[0] ] = ({ dest, fall_dest, distance });
   foreach( bar in dir )
      translations[bar] = dir[0];
   if( !query_exit( dir[0] ) )
      add_exit( dir[0], dest, "roof" );
   modify_exit( dir[0], ({
     "closed", 1,
     "function", (: this_object()->silly_move( $1, $2, $3,
       jump_info[ translations[$1] ][1], "step", step_messages ) :),
     "look", "You'll have to jump across to see what's on the other side."
   }) );
   return 1;
}
int silly_move( string verb, object ob, string special, mixed dest,
  string dam_type, string * messages ) {
   this_object()->do_fall( ob, dest, dam_type, messages, 0 );
   return notify_fail( "" );
}
void do_fall( object obj, mixed dest, string dam_type, string * messages,
  string dir ) {
   int damage, i;
   object destob;
   obj->remove_property( TOO_SOON );
   for( i = 0; i < sizeof( messages ); i++ )
      messages[i] = process_mess( messages[i], obj, dir );
   if( stringp( dest ) ) {
      if( !(destob = load_object( dest ) ) ) {
         tell_object( obj, "Cannot find " + dest + ".\n"
           "Moving you to the void - Please contact a creator.\n" );
         obj->move_with_look( "/room/void", "Poof. $N appears.\n",
           "$N plummets earthwards.\n" );
         return;
      }
   } else if( objectp( dest ) ) {
      destob = dest;
   } else {
      return;
   }
   tell_object( obj, messages[0] );
   obj->move_with_look( destob, messages[2], messages[1] );
   if( obj->query_property( "dead" ) )
      return;
   damage = calc_fall_damage( dam_type );
   if( damage >= obj->query_hp() ) {
      set_death_reason( "plummeting from the rooftops" );
      obj->attack_by( this_object() );
      obj->do_death();
   } else
      obj->adjust_hp( -damage );
}
void event_enter( object obj, object from ) {
   int totalweight, objectweight, i;
   float encum, diff;
   int fall;
   object * contents;
   object destination;
   if( !obj ) return;
   if( obj->query_property( "demon" )
     || obj->query_property( "floating" ) ) {
      return;
   }
   obj->add_property( TOO_SOON, 1, 5 );
   if( roof_max_weight ) {
      contents = all_inventory( this_object() );
      for( i = 0; i < sizeof(contents); i++ ) {
         objectweight = contents[i]->query_weight();
         objectweight += contents[i]->query_loc_weight();
         totalweight += objectweight;
#ifdef DEBUG
         debug_printf( "event_enter: Total weight of %s is %d units.\n",
           obj->query_name(), objectweight );
#endif
      }
#ifdef DEBUG
      debug_printf( "event_enter: The current weight on this roof is %d "
        "units. Max weight is set to %d.\n", totalweight, roof_max_weight );
#endif
      if( totalweight > roof_max_weight ) {
         fall = 1;
         tell_room( environment( obj ), weak_messages[3] );
         if( !(destination = load_object( weak_roof_dest ) ) ) {
            tell_room( this_object(), "Error loading room "
              + weak_roof_dest + ", moving you to the void.\n"
              "Please contact a creator.\n" );
            for( i = 0; i < sizeof(contents); i++ )
               contents[i]->move_with_look( "/room/void" );
            return;
         }
         for( i = 0; i < sizeof(contents); i++ ) {
            call_out( "do_fall", 1, contents[i], destination, "weak",
              weak_messages, 0 );
         }
         return;
      }
   }
   if( gradient && !fall ) {
      if( living( obj ) ) {
         if( ( obj->query_property( "dead" ) )
           || !( obj->query_max_weight() ) ) {
            call_out( "do_fall", 1, obj, slope_dest, "step",
              ghost_fall_messages );
            return;
         }
         encum = ( 100 * to_float( obj->query_loc_weight() ) )
           / to_float( obj->query_max_weight() );
         diff = to_int( sin( ( 3.1415926536 / 180.0 ) * gradient )
           * ( encum * 10 ) );
         call_out( "gradient_check", 1, obj, slope_dest,
           to_int( diff + ( gradient * 2 ) ) );
      } else {
         if( member_array( obj->query_name(),
           ({ "death", "binky" }) ) >= 0 )
            return;
         if( gradient > 3 ) {
            if( obj->query_corpse() ) {
               obj->move( slope_dest,
                 process_mess( corpse_slope_messages[1], obj, 0 ),
                 process_mess( corpse_slope_messages[0], obj, 0 ) );
            } else {
               obj->move( slope_dest,
                 process_mess( item_slope_messages[1], obj, 0 ),
                 process_mess( item_slope_messages[0], obj, 0 ) );
            }
         }
      }
      return;
   }
   obj->remove_property( TOO_SOON );
}
void gradient_check( object obj, string destination, int diff ) {
   object destob;
#ifdef DEBUG
   debug_printf( "gradient_check( %s, \"%s\", %d )",
     obj->query_name(), destination, diff );
#endif
   obj->remove_property( TOO_SOON );
   switch( TASKER->perform_task( obj, ROCK, diff + 1, TM_FIXED ) ) {
   case AWARD:
      tell_object( obj, "%^YELLOW%^" + ({
        "You balance more confidently on the " + place + ".",
        "Climbing becomes easier."
      })[ random(2) ] + "%^RESET%^\n" );
   case SUCCEED:
      tell_object( obj, "The " + place + " is steep, but you manage "
        "not to fall.\n" );
      break;
   case FAIL:
      if( !( destob = load_object( destination ) ) ) {
         tell_object( obj, "Error loading room " + destination +
           ", moving you to the void.\nPlease contact a creator.\n" );
         obj->move_with_look( "/room/void" );
      } else
         do_fall( obj, destob, "slope", slope_messages, 0 );
      break;
   default:
      write( "Gnaaaaaaaaaaaah! You should not be getting this message.  "
        "Please contact a creator.\n" );
      break;
   }
}
int do_roofjump( string dir ){
   mixed * info;
   int distance;
   float weight, max_weight;
   object destination, fall_destination;
   string key;
   if( !( key = translations[dir] ) || !( info = jump_info[key] ) ) {
      add_failed_mess( "You can't jump there!\n" );
      return 0;
   }
   if( !(destination = load_object( info[0] ) ) ) {
      add_failed_mess( "Error! The file " + info[0] + " does not exist "
        "or does not load. Please contact a creator.\n" );
      return 0;
   }
   if( !(fall_destination = load_object( info[1] ) ) ) {
      add_failed_mess( "Error! The file " + info[1] + " does not exist "
        "or does not load. Please contact a creator.\n" );
      return 0;
   }
   distance = info[2];
   if( distance ) {
      weight = to_float( this_player()->query_loc_weight() );
      max_weight = to_float( this_player()->query_max_weight() );
      distance *= to_float( ( to_float(weight) * 7) /
           to_float(max_weight) ) + 15;
      switch( TASKER->perform_task( this_player(), ROCK, distance, TM_FIXED ) ) {
         case AWARD:
            write( "%^YELLOW%^"
              + jump_tm_messages[ random( sizeof( jump_tm_messages ) ) ]
              + "%^RESET%^\n" );
         case SUCCEED:
            write( process_mess( jump_success_messages[0], this_player(), dir ) );
            this_player()->move_with_look( destination,
              process_mess( jump_success_messages[2], this_player(), dir ),
              process_mess( jump_success_messages[1], this_player(), dir ), );
            break;
         case FAIL:
            write( process_mess( jump_failure_messages[0], this_player(), dir ) );
            do_fall( this_player(), fall_destination, "jump",
              jump_failure_messages, dir );
            break;
         default:
            write( "Oh dear. Something is broken. Please inform a "
              "creator.\n" );
      }
      return 1;
   }
}
string query_death_reason() {
   call_out( (: death_reason = 0 :), 2 );
   if( death_reason )
      return "/global/player"->convert_message( death_reason );
   return "a rooftop (" + file_name( this_object() )
     + ") with an incorrectly set death message";
}
void set_death_reason( string str ) {
   death_reason = str;
}
string process_string( string str, mapping transforms ) {
   string foo, bar;
   foreach( foo, bar in transforms )
      if( bar ) str = replace_string( str, foo, bar );
   return "/global/player"->convert_message( str );
}
string process_mess( string str, object ob, string direction ) {
   string opp_dir;
   string * directions = ({ "north", "northeast", "east", "southeast",
     "south", "southwest", "west", "northwest" });
   if( !str || ( str == "" ) )
      return "";
   if( stringp( direction ) ) {
      if( member_array( direction, directions ) < 0 ) {
         opp_dir = 0;
      } else {
         opp_dir =
           directions[ ( member_array( direction, directions ) + 4 ) % 8 ];
      }
   }
   str = process_string( str, ([
     "$dir$"       : direction,
     "$opp_dir$"   : opp_dir,
     "$short$"     : ob->query_short(),
     "$poss$"      : ob->query_possessive(),
     "$pronoun$"   : ob->query_pronoun(),
     "$obj$"       : ob->query_objective(),
     "$a_short$"   : ob->a_short(),
     "$the_short$" : ob->the_short(),
     "$one_short$" : ob->one_short()
   ]) );
   return implode( explode( str, ". " ),
     (: "$C$" + $1 + ". " + "$C$" + $2 :) );
}
int test_remove( object ob, int flag, mixed dest ) {
   if( !living(ob) ) {
      return ::test_remove( ob, flag, dest );
   }
   if( objectp(dest) )
      dest = file_name(dest);
   if( !stringp(dest) || dest == "/room/rubbish" )
      return 1;
   if( ob->query_property( TOO_SOON ) ) {
      tell_object( ob, "You haven't quite caught your balance yet.\n" );
      notify_fail( "" );
      return 0;
   }
   return ::test_remove( ob, flag, dest );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/club_control_room.c ===
inherit "/std/room/basic_room";
inherit "/std/room/inherit/club_control_room";
void create() {
    do_setup++;
    basic_room::create();
    club_control_room::create();
    do_setup--;
    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
}
void init() {
    basic_room::init();
    club_control_room::init();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/guild.c ===
inherit "/std/room/basic_room";
inherit "/std/room/inherit/guild";
void create() {
  guild::create();
  basic_room::create();
}
void init() {
  basic_room::init();
  guild::init();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic_room.c ===
#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <weather.h>
#include <nroff.h>
inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";
inherit "/std/basic/effects";
nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string long_exit_mxp;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *_exits;
nosave object item;
private nosave object chatter;
nosave object sitchanger;
nosave object linker;
nosave object terrain;
nosave object wall;
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;
private nosave string *variablelongs;
private nosave mixed variablechats;
private nosave mixed variableitems;
private nosave int is_day = -1;
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
private void setup_room_chat( );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );
protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;
   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   effects::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   _exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
               catch(replace_program(fname));
           }
         }, 0, inhs[0]);
      }
   }
}
int query_is_room()
{
  return 1;
}
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }
  return enchant_level;
}
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }
  if (previous_object()==this_object()) {
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
}
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
}
void set_background_enchant( int number ) {
  background_enchant = number;
}
void set_dynamic_enchant( float number ) {
  dynamic_enchant = number;
  enchant_time = time();
}
int query_background_enchant() {
  return background_enchant;
}
float query_dynamic_enchant() {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
}
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
}
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
}
void flush_co_ord() {
    co_ord = 0;
    co_ord_calculated = 0;
}
int query_co_ord_calculated() { return co_ord_calculated; }
string query_long_exit() { return long_exit; }
string query_long_exit_mxp() { return long_exit_mxp; }
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    long_exit_mxp = mxp_expire("Exits") + "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ] + ".";
    long_exit_mxp = mxp_expire("Exits") +
                    "There is one obvious exit: "+ mxp_tag("Exit", words[ 0 ], 1) + ".";
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
    long_exit_mxp = mxp_expire("Exits") +
      "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( map(words, (: mxp_tag("Exit", $1, 1) :) ) ) +
      ".";
  }
}
string query_theft_handler() { return theft_handler; }
void set_theft_handler( string word ) { theft_handler = word; }
string *query_aliases() { return copy( aliases ); }
void add_alias( mixed names, string word ) {
  string name;
  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
}
void remove_alias( mixed names, string word ) {
  int i;
  string name;
  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );
    }
  }
}
string *query_exits() { return copy(_exits); }
void reset_exits() { _exits = ({ }); }
object query_item() { return item; }
object query_chatter() { return chatter; }
object query_situation_changer() { return sitchanger; }
object query_linker() { return linker; }
object query_terrain() { return terrain; }
object query_wall() { return wall; }
object *query_hidden_objects() { return hidden_objects + ({ }); }
int add_hidden_object( object thing ) {
  if ( !hidden_objects ) {
    hidden_objects = ({ });
  }
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
}
int remove_hidden_object( object thing ) {
  int i;
  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
}
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
}
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
}
object* query_use_internal_objects() {
   return _use_internal_objects;
}
varargs mixed query_door_control( string direc, string name ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   if (name) {
      return door_control[ direc + " " + name ];
   }
   return door_control[ direc ];
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
}
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
}
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
}
string query_destination( string exit ) {
   int i;
   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
}
int test_add( object thing, int flag ) { return 1; }
int test_remove( object thing, int flag, mixed dest ) { return 1; }
int add_weight( int number ) { return 1; }
int query_no_writing() { return 1; }
int query_decay() { return 10; }
int query_day() { return is_day; }
int attack_speed() { return 15; }
string query_dark_mess() {
  mixed dark_mess;
  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
}
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
}
string query_bright_mess() {
  mixed bright_mess;
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
}
void set_bright_mess( string word ) { add_property( "bright mess", word ); }
mixed query_room_size() {
   mixed room_size;
   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
}
int *query_room_size_array() {
   mixed room_size;
   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
}
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
}
int id( string word ) { return 0; }
string expand_alias( string word ) {
   int i;
   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
}
string calc_short_exit_string() {
   int i, add;
   string *words;
   int pos;
   string tmp_dir;
   mixed tmp;
   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               pos = strsrch(dest_other[i], " ");
               if (pos != -1) {
                  tmp_dir = dest_other[i][pos + 1..];
                  tmp = SHORTEN[tmp_dir];
                  if (tmp) {
                     tmp_dir = tmp;
                  }
                  words += ({ dest_other[i][0..pos] + tmp_dir });
               } else {
                  words += ({ dest_other[i] });
               }
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
}
string query_short_exit_string() {
   string tmp;
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
}
string enchant_string() {
   string words;
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
}
string long( string word, int dark ) {
   string ret;
   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = mxp_tag("RoomDesc", this_object()->query_dark_mess(), this_player()) +"\n";
      } else {
         ret = mxp_tag("RoomDesc", this_object()->query_bright_mess(), this_player()) +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ mxp_tag("RoomName", a_short(), this_player()) +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +
           mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }
      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret = mxp_tag("RoomDesc", ret, this_player());
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
         mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
         +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return mxp_secure(this_player()) + ret + mxp_open(this_player());
}
string pretty_short( object thing ) {
   int dark;
   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
}
int query_visibility() {
   return 100;
}
int can_use_for_co_ords(string other) {
   return 1;
}
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
  mixed* std_orders = STD_ORDERS;
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
       continue;
    }
    if ( other->query_do_not_use_coords()) {
       continue;
    }
    if (stringp(other) && other[0..2] == "/w/") {
       continue;
    }
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }
    if (!other_co_ord[0] && !other_co_ord[1] && !other_co_ord[2]) {
      continue;
    }
    if (!can_use_for_co_ords(other)) {
       continue;
    }
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, std_orders);
      }
    }
    if (j == -1) {
      j = member_array( dest_other[ i ], std_orders );
      if ( j == -1 ) {
        continue;
      }
    }
    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += std_orders[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
}
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;
   _exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, _exits ) == -1 ) {
         _exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            _exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, _exits ) == -1 ) {
               _exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
}
void init() {
  object ob;
  int i;
  if(this_player() && interactive(this_player())) {
    if(((!last_visited && uptime() > 1800 + random(3600)) ||
      (last_visited && (time() - last_visited > random(900) + 900)))) {
      if(clonep(this_object()))
        this_player()->adjust_xp(random(random(50)), 0);
      else
        this_player()->adjust_xp(random(random(500)), 0);
    }
    last_visited = time();
  }
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    setup_room_chat();
  }
  if(chatter) {
    chatter->check_chat();
  }
  if(sitchanger) {
    sitchanger->check_situations();
  }
  if(!sizeof(_exits)) {
    calc_exits();
  }
  if(!pointerp(co_ord)) {
    this_object()->calc_co_ord();
  }
  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }
  if (this_player() && userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }
  if(item) {
    item->init();
  }
}
string *query_zones() {
  string *zones;
  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
}
void add_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
}
void remove_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      return;
   } else {
      zones -= ({ zone });
   }
   add_property( "room zone", zones );
}
void set_zone( string zone ) {
   add_zone(zone);
}
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
}
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;
   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   stuff = ROOM_HANDLER->query_door_type( type, direc,
                                                         dest );
   if ( stuff ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      if (door_control[ direc ]->query_door_name()) {
         door_control[ dest + " " + door_control[ direc ]->query_door_name()] = direc;
      } else {
         door_control[ dest ] = direc;
      }
   }
   if ( find_call_out( "calc_exits" ) == -1 ) {
      call_out( "calc_exits", 1 );
   }
   long_exit = 0;
   short_exit = 0;
   return 1;
}
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
         if (door_control[ direc ]->query_door_name()) {
            door_control[ data[ j + 1 ] + " " + door_control[ direc ]->query_door_name()] = direc;
         }
       }
       break;
     case "door name" :
       if ( objectp( door_control[ direc ] ) ) {
          map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
          door_control[ direc ]->set_door_name( data[ j + 1 ] );
          door_control[ door_control[ direc ]->query_dest() + " " + data[ j + 1 ]] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "lock owner" :
       if ( objectp( door_control[ direc ] ) ) {
          door_control[ direc ]->set_lock_owner( data[ j + 1 ] );
       }
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_closed();
         } else {
            door_control[ direc ]->set_open();
         }
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_open();
         } else {
            door_control[ direc ]->set_closed();
         }
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] + " " +
                                   door_control[ direc ]->query_door_name() );
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         map_delete( door_control, direc );
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
       }
       break;
     case "no follow" :
       if (data[j + 1]) {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 1;
       } else {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 0;
       }
       break;
     }
   }
   return 1;
}
int remove_exit( string direc ) {
  int i;
  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
}
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
}
int query_relative( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
}
string query_look( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
}
mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
}
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
}
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() )[4..18], (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
}
int query_last_visited() { return last_visited; }
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }
  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
}
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
}
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
}
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
}
int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
}
void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
}
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
}
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
}
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
}
void dest_me() {
  object thing;
  if ( file_name( this_object() ) != ROOM_VOID ) {
    foreach( thing in all_inventory( this_object() ) ) {
      if ( userp( thing ) ) {
        thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
        continue;
      }
      thing->dest_me();
    }
  }
  if ( chatter )
    chatter->dest_me();
  if ( sitchanger )
    sitchanger->dest_me();
  if ( linker )
    linker->destruct_shadow( linker );
  if ( terrain )
    terrain->destruct_shadow( terrain );
  if(wall)
    wall->destruct_shadow(wall);
  if ( item )
    item->dest_me();
  if(door_control)
    foreach(thing in keys(door_control))
      if(objectp(thing))
        catch(thing->dest_me());
  if ( sizeof( hidden_objects ) )
    foreach( thing in hidden_objects ) {
      if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
        catch( thing->dest_me() );
    }
  destruct( this_object() );
}
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
}
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (this_object()->query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
}
int real_clean() {
   object thing;
   foreach ( thing in all_inventory( this_object() ) ) {
     if(thing->query_property("transient")) {
       if(thing->query_property("hospital"))
         thing->move(thing->query_property("hospital"), "$N wander$s in.",
                     "$N wander$s out.");
       else
         thing->move("/room/rubbish", "$N wander$s in.", "$N wander$s out.");
     }
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
}
int filter_inventory(object item, object looker) {
  return item && item->short(0) && (!looker || item->query_visible(looker));
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }
   if (looker && userp(looker)) {
      things = filter(things, "filter_inventory", this_object(), looker);
   }
   if ( item ) {
      things += ({ item });
   }
   return things;
}
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;
  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(implode(map(sign_name[1..], (: explode($1, " ")[<1] :)),
           (: $1 | ({ $2 }) :), ({ })));
    sign->add_plural(implode(map(sign_name[1..],
           (: pluralize(explode($1, " ")[<1]) :)), (: $1 | ({ $2 }) :), ({ })));
    sign->add_adjective(implode(map(sign_name[1..],
           (: explode($1, " ")[0..<2] :)), (: $1 | ({ $2 }) :), ({ })));
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else {
    hidden_objects += ({ sign });
    bits = sign->query_adjectives();
    if (sizeof(bits) > 0)
      sign->set_short(implode(bits, " ") + " " + sign->query_name());
    else
      sign->set_short(sign->query_name());
  }
  return sign;
}
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
}
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
}
string query_door( mixed dest, string name ) {
   int i;
   string direc;
   mixed bing;
   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if (name) {
      bing = door_control[ dest + " " + name];
      if (!bing) {
         bing = door_control[ dest ];
      }
   } else {
      bing = door_control[ dest ];
   }
   if ( bing ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
}
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
}
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}
void add_room_chats( string *new_chats ) {
  if (chatter) {
    chatter->add_room_chats( new_chats );
  }
}
void remove_room_chats( string *dead_chats ) {
  if (chatter) {
    chatter->remove_room_chats( dead_chats );
  }
}
mixed *query_room_chats() {
  if (chatter) {
    return chatter->query_room_chats();
  }
  return 0;
}
private void setup_room_chat() {
  mixed* chats;
  if (!chatter) {
    chatter = clone_object( CHATTER_OBJECT );
    if(base_name(this_object()) == "/d/sur/Maps/basic_rooms/plains/plains")
      log_file("CHATTER", "%s cloned chatter: %O\n",
               file_name(this_object()), chatter);
  }
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if (!variablechats) {
    variablechats = allocate(3);
  }
  if (is_day) {
    chats = variablechats[ROOM_DAY_INDEX];
  } else {
    chats = variablechats[ROOM_NIGHT_INDEX];
  }
  if (!chats) {
    chats = variablechats[ROOM_DEFAULT_INDEX];
  } else if (variablechats[ROOM_DEFAULT_INDEX]) {
    chats[2] += variablechats[ROOM_DEFAULT_INDEX][2];
  }
  chatter->setup_chatter( this_object(), chats );
}
varargs void room_chat( mixed *args, object chatobj ) {
   if (!args)  {
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
   if (!chatter && objectp(chatobj)) {
     chatter = chatobj;
   }
   if (!variablechats) {
      variablechats = allocate(3);
   }
   variablechats[ROOM_DEFAULT_INDEX] = args;
   setup_room_chat();
}
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );
  } else if (objectp(changer)) {
    sitchanger = changer;
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
}
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
}
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
}
void start_situation(int label, int do_start_mess) {
  if (sitchanger)
    sitchanger->start_situation( label, do_start_mess );
}
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
}
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger)
    return sitchanger->change_situation(label,duration,words,0);
  return 0;
}
varargs void automate_situation( mixed label, mixed duration, mixed when,
    mixed chance, mixed category ) {
  if (sitchanger)
    sitchanger->automate_situation(label,duration,when,chance,category);
}
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
}
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
}
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
}
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
}
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + effects::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
}
void set_day_long( string str ) {
  if(!variablelongs) {
    variablelongs = allocate(2);
  }
  variablelongs[ROOM_DAY_INDEX] = str;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    set_long(str);
  }
}
string query_day_long() {
   if(variablelongs && strlen(variablelongs[ROOM_DAY_INDEX]))
     return variablelongs[ROOM_DAY_INDEX];
   return this_object()->query_long();
}
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[ROOM_NIGHT_INDEX] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_NIGHT_INDEX)
    set_long(str);
}
string query_night_long() {
   if(variablelongs && strlen(variablelongs[ROOM_NIGHT_INDEX]))
     return variablelongs[ROOM_NIGHT_INDEX];
   return this_object()->query_long();
}
private string return_long(mixed desc) {
  int ma;
  if(!pointerp(desc))
    return (string)desc;
  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  return (string)desc[ma+1];
}
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[ROOM_DAY_INDEX] += ({ the_item, return_long(desc) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_DAY_INDEX)
    return add_item(shorts, desc, no_plural);
  return 1;
}
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[ROOM_NIGHT_INDEX] += ({ the_item, return_long( desc ) });
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX)  {
    return add_item(shorts, desc, no_plural);
  }
  return 1;
}
void room_day_chat(mixed *args) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  variablechats[ROOM_DAY_INDEX] = args;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    setup_room_chat();
  }
}
void room_night_chat( mixed *args ) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  variablechats[ROOM_NIGHT_INDEX] = args;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX) {
    setup_room_chat();
  }
}
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
}
mixed* query_room_night_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_NIGHT_INDEX];
  }
  return ({ });
}
mixed* query_room_day_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_DAY_INDEX];
  }
  return ({ });
}
mixed* query_room_default_chats() {
   if (sizeof(variablechats)) {
      return variablechats[ROOM_DEFAULT_INDEX];
   }
   return ({ });
}
mixed* query_day_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_DAY_INDEX];
  }
  return ({ });
}
mixed* query_night_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_NIGHT_INDEX];
  }
  return ({ });
}
