
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/guild.c ===
#include <money.h>
#include <skills.h>
#include <tune.h>
#include <config.h>
private int cost_div;
private int cost_mult;
private string our_guild;
private string start_pos;
private mapping spells;
private mapping commands;
private object teaching_person;
void check_spells_commands(string *sk, int lvl);
int do_cost_primaries();
int do_cost_all(int brief);
int do_cost_to(string skill, int level);
int do_cost_by(string skill, int level);
int do_cost(string skill);
int do_advance(string skill);
int do_advance_to(string skill, int num);
int do_advance_by(string skill, int num);
void create()
{
   cost_div = COST_DIV;
   cost_mult = 100;
   spells = ([ ]);
   commands = ([ ]);
   this_object()->add_help_file("guild");
}
void init()
{
   this_player()->add_command("advance", this_object(),
                              "<string>", (: do_advance($4[0]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> to <number>",
                              (: do_advance_to($4[0], $4[1]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> by <number>",
                              (: do_advance_by($4[0], $4[1]) :));
   this_player()->add_command("join", this_object(), "");
   this_player()->add_command("info", this_object(), "");
   this_player()->add_command("cost", this_object(),
                              "primaries", (: do_cost_primaries() :));
   this_player()->add_command("cost", this_object(),
                              "all", (: do_cost_all(0) :));
   this_player()->add_command("cost", this_object(),
                              "all brief", (: do_cost_all(1) :));
   this_player()->add_command("cost", this_object(),
                              "<string>", (: do_cost($4[0]) :));
   this_player()->add_command("cost", this_object(),
                              "<string> to <number>",
                              (: do_cost_to($4[0], $4[1]) :));
   this_player()->add_command("cost", this_object(), "<string> by <number>",
                              (: do_cost_by($4[0], $4[1]) :));
   if ((string) this_player()->query_guild_ob() == our_guild) {
      if (stringp(start_pos) && !clonep(this_object())) {
         this_player()->add_start(file_name(this_object()), start_pos);
      }
   }
}
varargs void set_guild(string word1, string word2)
{
   our_guild = word1;
   start_pos = word2;
}
void set_cost_div(int number)
{
   cost_div = number;
   if (!cost_div)
      cost_mult = 1000;
   else
      cost_mult = 10 + (990 * cost_div) / (10 * COST_DIV + cost_div);
}
int query_skill_cost(string skill, int offset)
{
   int i;
   int total;
   string *next;
   next = (string *) SKILL_OB->query_immediate_children(skill);
   if (!sizeof(next)) {
      if (!this_player()->query_guild_ob())
         total = DEFAULT_COST;
      else
         total = (int) our_guild->query_skill_cost(skill);
      total *= (STD_COST * cost_mult) / 500;
      total *= ((int) this_player()->query_skill(skill) + offset) /
         LEVEL_DIV + 1;
      total = to_int(total * exp((this_player()->query_skill(skill) +
                                  offset) / 150.0));
      return total;
   }
   for (i = 0; i < sizeof(next); i++)
      total += query_skill_cost(next[i], offset);
   return total;
}
int do_advance_internal(string skill, int to, int by)
{
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   int lvl;
   int max_lvl;
   int tmp;
   int total_xp;
   int total_cost;
   int tmp_cost;
   int p_val;
   int i, j;
   int round_value;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You cannot advance here!  Go to your own guild.\n");
      return 0;
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("The skill " + skill + " does not exist.\n");
      return 0;
   }
   bits = SKILL_OB->query_inactive_skills();
   for(j=0; j<sizeof(bits); j++)
     if(strsrch(skill, bits[j]) != -1)
       return add_failed_mess("The skill " + skill + " is inactive at "
                              "present and cannot be taught.\n");
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by <= 0) {
      if (by == 0) {
         add_failed_mess("You are already at level " + lvl + " at " +
                         skill_name + ".\n");
      } else {
         add_failed_mess("You cannot regress below your current "
                         "skill level!\n");
      }
      return 0;
   }
   if (SKILL_OB->query_only_leaf(skill_name)) {
      if (sizeof((mixed *)SKILL_OB->query_immediate_children(skill_name))) {
         add_failed_mess("You can only advance the outer skills "
                         "(eg: other.movement.riding.horse), "
                         "not the internal "
                         "skills (eg: other.movement.riding, or other).\n");
         return 0;
      }
   } else {
      bits = explode(skill_name, ".");
      if (sizeof(bits) > 1) {
         outer_name = implode(bits[0..<2], ".");
         if (!SKILL_OB->is_skill_ignored(outer_name) &&
             ((sizeof(bits) - 1) * 5) >
             (int) this_player()->query_skill(outer_name)) {
            add_failed_mess("You are not at a high enough level in " +
                            outer_name +
                            " to advance " + skill_name + " yet.\n");
            return 0;
         }
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("You cannot advance in " + skill_name +
                      " any further here.\n");
      return 0;
   }
   p_val = (int) this_player()->query_value_in(place);
   if (place != "default") {
      p_val += (int) this_player()->query_value_in("default");
   }
   round_value = MONEY_HAND->query_smallest_value_in(place);
   total_cost = 0;
   for (i = 0; i < by; i++) {
      tmp = query_skill_cost(skill_name, i);
      if ((int) this_player()->query_xp() < tmp + total_xp) {
         if (!i) {
            add_failed_mess("Your lack of experience prevents you improving "
                            + skill_name + ".\n");
            return 0;
         } else {
            write("Your lack of experience prevents you taking all the "
                  "advancement you requested in " + skill_name + ".  You are "
                  "only trained up to level " + (i + lvl) + ".\n");
         }
         break;
      }
      if ((lvl + i) >= max_lvl) {
         write("Your guild hasn't the resources to train you as far as " +
               "you requested in " + skill_name +
               ".  It trains you to level " + max_lvl + ".\n");
         break;
      }
      if (cost_div) {
         tmp_cost = ( total_xp + tmp ) / cost_div;
         tmp_cost -= (tmp_cost % round_value);
         if ( tmp_cost > p_val ) {
            if (!i) {
               add_failed_mess
                  ("Due to your lack of money, the guild cannot train " +
                   "you in " + skill_name + ": it would have cost you " +
                   MONEY_HAND->money_value_string( tmp_cost, place ) + ".\n" );
               return 0;
            } else {
               write("Due to your sad lack of money the guild cannot train " +
                     "you in " + skill_name + " to level " + (by + lvl) +
                     ".  It trains you to level " + (i + lvl) + " instead.\n");
            }
            break;
         }
      }
      total_xp += tmp;
      total_cost = tmp_cost;
   }
   if (!total_xp) {
      return add_failed_mess("Oops, something has gone wrong.\n");
   }
   this_player()->adjust_xp(-total_xp);
   if (total_cost) {
      this_player()->pay_money((mixed *) MONEY_HAND->
                               create_money_array(total_cost, place), place);
   }
   this_player()->add_skill_level(skill_name, i, total_xp);
   this_player()->reset_all();
   this_player()->dest_hide_shadow();
   event(this_object(), "guild_advance", bits, lvl, lvl + i);
   check_spells_commands(bits, lvl + i);
   write("You advance your skill in " + skill_name + " from " + lvl + " to " +
         (lvl + i) + " for " + total_xp + " xp" + (total_cost ? " and " +
                                                   (string) MONEY_HAND->
                                                   money_value_string
                                                   (total_cost,
                                                    place) : "") + ".\n");
   say((string) this_player()->one_short() + " $V$0=advances,advance$V$ " +
       "$V$0=" + this_player()->query_possessive() + ",their$V$ skills.\n");
   return 1;
}
int do_advance(string skill)
{
   return do_advance_internal(skill, 0, 1);
}
int do_advance_by(string skill,
                  int num)
{
   return do_advance_internal(skill, 0, num);
}
int do_advance_to(string skill,
                  int num)
{
   return do_advance_internal(skill, num, 0);
}
int do_join(string str)
{
   if ((string) this_player()->query_guild_ob() == our_guild) {
      add_failed_mess("You're already in this guild.\n");
      return 0;
   }
   if (this_player()->query_guild_ob()) {
      add_failed_mess("You cannot join a guild while a member of another.\n");
      return 0;
   }
   write("You will only ever get to join one guild.  Are you sure? ");
   input_to("join2");
   return 1;
}
int join2(string str)
{
   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write("I do not understand.  Yes or no? ");
      input_to("join2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not joining the " + our_guild->query_name() + " guild.\n");
      return 1;
   }
   this_player()->set_guild_ob(our_guild);
   if (stringp(start_pos) && !clonep(environment(this_player())))
      this_player()->add_start(file_name(environment(this_player())),
                               start_pos);
   this_player()->race_guild_commands();
   write("You are now a member of the " + our_guild->query_name() +
         " guild.\n");
   say(this_player()->one_short() + " joins the " + our_guild->query_name() +
       " guild.\n");
   event(this_object(), "guild_join");
   event(users(), "inform",
         this_player()->query_cap_name() + " is now a member " + "of " +
         our_guild->query_name(), "guild");
   return 1;
}
int do_leave(string str)
{
   if (str != "guild") {
      add_failed_mess("Syntax : leave guild\n");
      return 0;
   }
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("How can you leave a guild if you aren't in it.\n");
      return 0;
   }
   if ((int) this_player()->query_level() > 5) {
      add_failed_mess("You are too high a level to leave this guild.\n");
      return 0;
   }
   write("Are you sure you want to leave the guild (Y/N) : ");
   input_to("confirm_leave");
   return 1;
}
void confirm_leave(string str)
{
   str = lower_case(str);
   if (str != "y") {
      write("You are still in the guild.\n");
      return;
   }
   write("Goodbye.\n");
   call_other(our_guild, "leaving_guild");
   this_player()->set_start_pos(CONFIG_START_LOCATION);
   this_player()->set_guild_ob(0);
   this_player()->set_guild_data(0);
   this_player()->guild_commands();
   this_player()->save_me();
}
int check_primaries(string lpath, string g_o)
{
   int i;
   string dummy,
    *primaries;
   primaries = (string *) g_o->query_skills();
   if (member_array(lpath, primaries) != -1)
      return 1;
   for (i = 0; i < sizeof(primaries); i++)
      if (sscanf(primaries[i], lpath + ".%s", dummy))
         return 1;
   return 0;
}
mixed *filter_primaries(mixed *tmp_skills, string skill_path,
                        string *primaries)
{
   int i;
   string test_skill;
   for (i = 0; i < sizeof(tmp_skills); i += SKILL_ARR_SIZE)  {
      test_skill = skill_path + tmp_skills[i];
      if (sizeof(tmp_skills[i + SKILL_BIT]) != 0)
         tmp_skills[i + SKILL_BIT] =
            filter_primaries(tmp_skills[i + SKILL_BIT], test_skill + ".",
                             primaries);
      if (member_array(test_skill, primaries) == -1  &&
          sizeof(tmp_skills[i + SKILL_BIT]) == 0)
      {
         tmp_skills = tmp_skills[0 .. (i - 1)] +
                      tmp_skills[(i + SKILL_ARR_SIZE) .. ];
         i -= SKILL_ARR_SIZE;
      }
   }
   return tmp_skills;
}
private string rec_cost(mixed *arr, string path, int depth, string guild,
                        int brief)
{
   int i;
   int depth_gap;
   int ndots;
   int lvl;
   int max_lvl;
   int only_leaf;
   int tmp;
   string str;
   string sub_str;
   string lpath;
   str = "";
   depth_gap = (depth - 1) * 2;
   ndots = 19 - depth_gap;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      lpath = path + arr[i];
      lvl = this_player()->query_skill(lpath);
      if (!guild) {
         max_lvl = 5;
      } else {
         max_lvl = guild->query_skill_max_level(lpath);
      }
      only_leaf = SKILL_OB->query_only_leaf(lpath);
      if (only_leaf  &&  sizeof(arr[i + SKILL_BIT]) > 0)  {
         sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                            guild, brief);
         if (sub_str != "")  {
            str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                           ndots + 18, arr[i]) + sub_str;
            continue;
         }
      }
      else if (SKILL_OB->query_allowed_to_teach(lpath))  {
         if (lvl >= max_lvl)  {
            if (brief)  {
               sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                                  guild, brief);
               if (sub_str != "")  {
                  str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                                 ndots + 18, arr[i]) + sub_str;
                  continue;
               }
            }
            else str += sprintf("%*'| 's%-*'.'s%4d/%3d  mastered\n", depth_gap,
                                "", ndots, arr[i], lvl, max_lvl);
         }
         else if (SKILL_OB->query_allowed_to_teach(lpath))  {
            tmp = query_skill_cost(lpath, 0);
            str += sprintf("%*'| 's%-*'.'s%4d/%3d %6d xp\n", depth_gap, "",
                           ndots, arr[i], lvl, max_lvl, tmp);
         }
      }
      if (lvl >= depth * 5  ||  only_leaf) {
         reset_eval_cost();
         str += rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1, guild,
                         brief);
      }
   }
   return str;
}
int do_cost_all(int brief)
{
   mixed *arr;
   string list;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols(),
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols() + 1,
                   rec_cost(arr, "", 1, our_guild, brief));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols(),
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "All", 1);
   return 1;
}
int do_cost_primaries()
{
   mixed *arr;
   string list;
   string *primaries;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols(),
                   rec_cost(arr, "", 1, our_guild, 0));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "Primaries", 1);
   return 1;
}
int do_cost_internal(string skill, int to, int by)  {
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   string cost_str;
   int lvl;
   int max_lvl;
   int i;
   int tmp;
   int cost;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by == 0) {
      add_failed_mess
         ("It won't cost you anything to stay at the same level!\n");
      return 0;
   }
   if (by < 0) {
      add_failed_mess("We can't give refund xp for regressing skills!\n");
      return 0;
   }
   bits = explode(skill_name, ".");
   if (sizeof(bits) > 1  &&  !SKILL_OB->query_only_leaf(skill_name)) {
      outer_name = implode(bits[0 .. <2], ".");
      if (!SKILL_OB->is_skill_ignored(outer_name) &&
          ((sizeof(bits) - 1) * 5) > this_player()->query_skill(outer_name))
      {
         add_failed_mess("You are not at a high enough level in " +
                         outer_name + " to advance " + skill_name +
                         " yet.\n");
         return 0;
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("Your guild prevents you even considering advancing " +
                      skill_name + " above level " + max_lvl + ".\n");
      return 0;
   }
   for (i = 0; i < by; i++) {
      if ((lvl + i) >= max_lvl) {
         write("Your guild prevents you considering all the advancement you "
               + "requested.  You can only advance up to level " + max_lvl +
               " in " + skill_name + " here.\n");
         break;
      }
      tmp += query_skill_cost(skill_name, i);
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   cost_str = "";
   if (cost_div) {
      cost = tmp / cost_div;
      cost += cost % MONEY_HAND->query_smallest_value_in(place);
      if (cost)
         cost_str = " and " + MONEY_HAND->money_value_string(cost, place);
   }
   printf("It would cost you %d xp%s to raise %s from level %d to %d.\n",
          tmp, cost_str, skill_name, lvl, (lvl + i));
   return 1;
}
int do_cost(string skill)
{
   mixed *arr;
   int i;
   int depth;
   string list;
   string exp_skill;
   string *sub_skills;
   int only_leaf;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   exp_skill =
      SKILL_OB->query_skill(explode(implode(explode(skill, " "), "."), "."));
   if (!exp_skill)  {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   if (SKILL_OB->query_allowed_to_teach(exp_skill))  {
      i = member_array(exp_skill, arr);
      only_leaf = SKILL_OB->query_only_leaf(exp_skill);
      if (only_leaf)  {
         sub_skills = explode(exp_skill, ".");
         foreach (skill in sub_skills[0 .. < 2])  {
            i = member_array(skill, arr);
            arr = arr[i + 3];
         }
         i = member_array(sub_skills[<1], arr);
         depth = sizeof(sub_skills) + 1;
      }
      else depth = 2;
      if (sizeof(arr[i + 3]) > 0)  {
         list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                        "======SKILLS=======Cur/Max==For Next") +
                sprintf("%#*-s\n", (int) this_player()->query_cols(),
                         rec_cost(arr[i + SKILL_BIT], exp_skill + ".", depth,
                         our_guild, 0)) +
                sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                         "> You have " + (int) this_player()->query_xp() +
                         " points to spend <");
         this_player()->more_string(list, capitalize(exp_skill), 1);
         return 1;
      }
   }
   return do_cost_internal(exp_skill, 0, 1);
}
int do_cost_to(string skill, int num)
{
   return do_cost_internal(skill, num, 0);
}
int do_cost_by(string skill, int num)
{
   return do_cost_internal(skill, 0, num);
}
int do_info()
{
   mixed *arr;
   string *primaries;
   write(our_guild->long() +
         "\nThis guild's primary skills and costs are:\n");
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   printf("%-*'='s\n", this_player()->query_cols() - 1,
          "======SKILLS=======Cur/Max==For Next");
   printf("%#*-s\n", this_player()->query_cols(),
          rec_cost(arr, "", 1, our_guild, 0));
   printf("%*'='|s\n", this_player()->query_cols() - 1, "> You have " +
          this_player()->query_xp() + " points to spend <");
   return 1;
}
void set_teaching_person(object ob)
{
   teaching_person = ob;
}
object query_teaching_person()
{
   return teaching_person;
}
void add_spell(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!spells[path])
      spells[path] = ({ name, lvl });
   else
      spells[path] += ({ name, lvl });
}
void add_command(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!commands)
      commands = ([ ]);
   if (!commands[path])
      commands[path] = ({ name, lvl });
   else
      commands[path] += ({ name, lvl });
}
void check_spells_commands(string *sk, int lvl)
{
   string *bits;
   int val;
   int i;
   int j;
   if (!teaching_person)
      return;
   bits = keys(spells);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(spells[bits[i]]); j += 2)
         if ((spells[bits[i]][j + 1] < val) &&
             !(this_player()->query_spell(spells[bits[i]][j])))
            teaching_person->init_command("teach " + spells[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
   bits = keys(commands);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(commands[bits[i]]); j += 2)
         if ((commands[bits[i]][j + 1] < val) &&
             !(this_player()->query_known_command(commands[bits[i]][j])))
            teaching_person->init_command("teach " + commands[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
}
mapping query_spells()
{
   return spells + ([ ]);
}
mapping query_commands()
{
   return commands + ([ ]);
}
string query_start_pos()
{
   return start_pos;
}
string query_our_guild()
{
   return our_guild;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/council_base.c ===
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
private nosave string _council_area;
string query_council_area() {
   return _council_area;
}
void set_council_area(string area) {
   _council_area = area;
}
void send_council_inform(int magistrate_only, string message) {
   NOMIC_HANDLER->send_council_inform(query_council_area(),
                                       magistrate_only, message);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/club_discuss.c ===
#include <clubs.h>
#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 30
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"
private void discuss_finish_description(string str, int open);
protected int do_discuss(int open, string type, string club_name);
class memo_item {
   string club_name;
   string subject;
   string description;
   string *choices;
   int timeout;
   int open;
}
void init() {
   add_command("discuss",
               "[open] {description|add position|"
               "change position name|memo|secret|"
               "remove member|no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                (: do_discuss(1, $4[0], $4[1]) :));
   add_command("discuss",
               "committee {description|add position|"
               "change position name|memo|secret|remove member|"
               "no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                     (: do_discuss(0, $4[0], $4[1]) :));
}
protected void discussion_finish_information(string info,
                                             mixed *data) {
   int type;
   string short;
   string name;
   string optional;
   string club_name;
   club_name = data[0];
   short = data[1];
   type = data[2];
   name = data[3];
   optional = data[4];
   write("Discussion item: " + short + ".\n");
   if (!info) {
      write("No description used.\n");
   } else {
      write(info);
   }
   write("\nDo you wish to add this? ");
   input_to("discussion_finish_confirm",
            0,
            club_name,
            short,
            type,
            name,
            info,
            optional);
}
protected void discussion_finish_confirm(string str,
                                         string club_name,
                                         string short,
                                         int type,
                                         string name,
                                         string info,
                                         string optional) {
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         type,
                                         this_player()->query_cap_name(),
                                         name,
                                         info,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         optional)) {
      write("Added in the discussion item: " + short + ".\n");
   } else {
      write("Unable to add in the discussion item: " + short + ".\n");
   }
}
protected int do_discuss_description(int open,
                                     string club_name) {
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_DESCRIPTION,
                                                   0)) {
      add_failed_mess("A description is already being discussed, you can only "
                      "discuss one description at a time.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Please enter the description you wish to have discussed as the "
         "new description of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discuss_finish_description :),
                          0,
                          0,
                          ({ open,
                             club_name }));
   return 1;
}
private void discuss_finish_description(string str, mixed *junk) {
   int open;
   string club_name;
   if (!str) {
      write("Description aborted.\n");
      return ;
   }
   open = junk[0];
   club_name = junk[1];
   write("Adding the description:\n" + str +
         "\nIs this the correct description (yes/no/edit)? ");
   input_to("description_confirm", 0, str, open, club_name);
}
protected void description_confirm(string confirm, string str, int open, string club_name) {
   confirm = lower_case(confirm);
   if (strlen(confirm) &&
       confirm[0] == 'e') {
      this_player()->do_edit(str,
                             (: discuss_finish_description :),
                             0,
                             0,
                             ({ open, club_name }));
      return ;
   }
   if (!strlen(confirm) ||
       confirm[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         CLUB_DISCUSS_DESCRIPTION | open,
                                         this_player()->query_name(),
                                         "Change club description",
                                         str,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         0)) {
      write("Successfuly added the item for discussion.\n");
   } else {
      write("Unable to add the item for discussion.\n");
   }
}
protected int do_discuss_add_position(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What committee position do you wish to add to the club '" +
         club_name + "'? ");
   input_to("discussion_add_name", 0, open, club_name);
   return 1;
}
protected void discussion_add_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The position '" + str + "' already exists in the club.  You "
            "cannot add it.\nAborting.\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, it can be a "
            "maximum length of " + CLUB_MAX_POSITION_NAME +
            ".\nAborting.\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What message do you wish display as to why you wish this position "
         "added?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Adding the position " + str,
                                CLUB_DISCUSS_NEW_POSITION | open,
                                str,
                                0 }) );
}
protected int do_discuss_remove_member(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which member to do you wish to try and remove? ");
   input_to("discussion_remove_member_name", 0, open, club_name);
   return 1;
}
protected void discussion_remove_member_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   if (!CLUB_HANDLER->is_member_of(club_name,
                                   str)) {
      write("The person " + str + " is not a member of the club " +
            CLUB_HANDLER->query_club_name(club_name) +
            " and therefor you cannot remove them.\nAborting.\n");
      return ;
   }
   write("What do you want to say about removing " + str + "?\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Removing the member " + str,
                                CLUB_DISCUSS_MEMBER_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_secret(int open, string club_name) {
   string short;
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_SECRET_TYPE)) {
      notify_fail("There is already a discussion item to change this club's "
                  "secret status.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   if (CLUB_HANDLER->query_club_secret(club_name)) {
      write("What description to wish to use to make the club open?\n");
      short = "make the club open";
   } else {
      write("What description to wish to use to make the club secret?\n");
      short = "make the club secret";
   }
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                short,
                                CLUB_DISCUSS_SECRET_TYPE | open,
                                "Change to be secret",
                                0 }) );
   return 1;
}
protected int do_discuss_remove_position(int open, string club_name) {
   string *choices;
   string *ok;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   ok = filter(choices, (: !CLUB_HANDLER->is_basic_position($(club_name),
                                                            $1) :));
   if (!sizeof(ok)) {
      add_failed_mess("You cannot remove the basic positions of " +
                      query_multiple_short(choices) + ".\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to remove?\n");
   foreach (bing in ok) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("remove_position", 0, open, club_name, ok);
   return 1;
}
protected void remove_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (CLUB_HANDLER->is_basic_position(club_name,
                                       str)) {
      write("Unable to remove the basic positions from the club.\n");
      return ;
   }
   write("What description do you wish to associate with removing the "
         "position " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Remove the positon " + str,
                                CLUB_DISCUSS_POSITION_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_change_position_name(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to change?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("change_position", 0, open, club_name);
   return 1;
}
protected void change_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   write("What name do you wish to change '" + str + "' to? ");
   input_to("change_position_new_name", 0, str, open, club_name);
}
protected void change_position_new_name(string str,
                                        string position,
                                        int open, string club_name) {
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The name '" + str + "' already exists in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, the maximum is " +
            CLUB_MAX_POSITION_NAME + ".\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What description to you wish to give for changing the position " +
         position + " to " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "change the position " + position + " to " + str,
                                CLUB_DISCUSS_POSITION_NAME | open,
                                position,
                                str }) );
}
protected int do_discuss_no_confidence(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to add a no confidence "
         "vote in?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("   " + CLUB_ALL_POSITIONS + "\n");
   write("Choice? ");
   input_to("no_confidence", 0, open, club_name);
   return 1;
}
protected void no_confidence(string str,
                             int open, string club_name) {
   string bing;
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name, str) &&
       str != CLUB_ALL_POSITIONS) {
      write("Sorry, '" + str + "' is not a valid position in " +
            CLUB_HANDLER->query_club_name(club_name) +
            ".\n");
      return ;
   }
   if (str == CLUB_ALL_POSITIONS) {
      bing = 0;
   } else {
      bing = str;
   }
   write("What description do you wish to give for a vote of no confidence "
         "in " + str + "?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "no confidence in " + str,
                                CLUB_DISCUSS_NO_CONFIDENCE | open,
                                bing,
                                0 }) );
}
protected int do_discuss_remove_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to close? ");
   input_to("remove_account", 0, open, club_name);
   return 1;
}
protected void remove_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot remove an account that doesn't exist.\n");
      return ;
   }
   if (str == CLUB_DEFAULT_ACCOUNT_NAME) {
      write("You cannot remove the default account name.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_REMOVE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected int do_discuss_create_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to open? ");
   input_to("create_account", 0, open, club_name);
   return 1;
}
protected void create_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot create an account that already exists.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_CREATE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected void discuss_memo_show(class memo_item memo) {
   write("The memo in club " +
         CLUB_HANDLER->query_club_name(memo->club_name) +
         " will complete in " + memo->timeout + " days.\n");
   if (memo->subject) {
      write("Subject: " + memo->subject + "\n");
   } else {
      write("No subject set.\n");
   }
   if (sizeof(memo->choices)) {
      write("Choices: " + query_multiple_short(memo->choices) + "\n");
   } else {
      write("No choices set.\n");
   }
   if (memo->description) {
      write("Description:\n" + memo->description + "\n");
   } else {
      write("No description set.\n");
   }
}
protected void discuss_memo_menu(class memo_item memo) {
   discuss_memo_show(memo);
   write("\n");
   write("a) Set subject\n");
   write("b) Make a yes/no memo item\n");
   write("c) Add new choice\n");
   write("d) Remove choice\n");
   write("e) Set completion time\n");
   if (memo->description) {
      write("f) Change description\n");
      write("g) Zap description\n");
   } else {
      write("f) Add description\n");
   }
   write("m) Redisplay this menu\n");
   write("s) Save and Quit\n");
   write("q) Quit\n\n");
   write("Choice: ");
   input_to("discuss_memo_menu_choice", 0, memo);
}
protected void discuss_memo_subject(class memo_item memo) {
   write("What do you wish the new subject to be? ");
   input_to("discuss_memo_subject_name", 0, memo);
}
protected void discuss_memo_subject_name(string name,
                                         class memo_item memo) {
   if (!strlen(name)) {
      write("Not changing the subject.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(name) > MAX_SUBJECT_LEN) {
      write("The subject name is too long, the maximum "
            "length is " + MAX_SUBJECT_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->subject = name;
   discuss_memo_menu(memo);
}
protected void discuss_memo_add_choice(class memo_item memo) {
   write("What is the name of the choice you wish to add? ");
   input_to("discuss_memo_add_choice_response", 0, memo);
}
protected void discuss_memo_add_choice_response(string response,
                                                class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   response = strip_colours(response);
   if (!strlen(response)) {
      write("Not adding any choices.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(response) > MAX_CHOICE_LEN) {
      write("The choice name " + response + " is too long, maximum "
            "length is " + MAX_CHOICE_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (member_array(response, memo->choices) != -1) {
      write("The choice name " + response + " is already in the list of "
            "choices.  Current choices are " +
            query_multiple_short(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices += ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_remove_choice(class memo_item memo) {
   write("What is the name of the choice you wish to remove? ");
   input_to("discuss_memo_remove_choice_response", 0, memo);
}
protected void discuss_memo_remove_choice_response(string response,
                                                   class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   if (member_array(response, memo->choices) == -1) {
      write("The choice '" + response + "' is not in current memo.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices -= ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_timeout(class memo_item memo) {
   write("What do you wish to change the length of the item to (in days)? ");
   input_to("discuss_memo_timeout_response", 0, memo);
}
protected void discuss_memo_timeout_response(string str,
                                             class memo_item memo) {
   int tim;
   if (sscanf(str, "%d", tim) != 1) {
      write("Must specify a number.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim < MIN_TIMEOUT) {
      write("The timeout " + tim + " is lower than the minimum allowed "
            "length of " + MIN_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim > MAX_TIMEOUT) {
      write("The timeout " + tim + " is higher than the maximum allowed "
            "length of " + MAX_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->timeout = tim;
   discuss_memo_menu(memo);
}
protected void discuss_memo_finish_description(string desc,
                                               class memo_item memo) {
   if (!desc) {
      write("Not changing the description.\n");
   } else {
      memo->description = desc;
   }
   discuss_memo_menu(memo);
}
protected void discuss_memo_description(class memo_item memo) {
   if (memo->description) {
      write("Edit your description.\n");
   } else {
      write("Add your description.\n");
   }
   this_player()->do_edit(memo->description,
                          (: discuss_memo_finish_description :),
                          0,
                          0,
                          memo);
}
protected void discuss_memo_save(class memo_item memo) {
   if (!memo->subject) {
      write("The memo must have a subject to save it!\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (sizeof(memo->choices) < 2) {
      write("The memo must have at least two choices!  Currently you have " +
            sizeof(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(memo->club_name,
                                         CLUB_DISCUSS_MEMO | memo->open,
                                         this_player()->query_name(),
                                         memo->subject,
                                         memo->description,
                                         memo->choices,
                                         memo->timeout * 24 * 60 * 60,
                                         0)) {
      write("Successfuly added the memo item.\n");
   } else {
      write("Unable to add the memo item for some reason.\n");
   }
}
protected void discuss_memo_menu_choice(string str, class memo_item memo) {
   str = lower_case(str);
   if (!strlen(str)) {
      write("Invalid choice\nChoice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   switch (str[0]) {
      case 'a' :
         discuss_memo_subject(memo);
         break;
      case 'b' :
         memo->choices = ({ "yes", "no", "abstain" });
         discuss_memo_menu(memo);
         break;
      case 'c' :
         discuss_memo_add_choice(memo);
         break;
      case 'd' :
         discuss_memo_remove_choice(memo);
         break;
      case 'e' :
         discuss_memo_timeout(memo);
         break;
      case 'f' :
         discuss_memo_description(memo);
         break;
      case 'g' :
         memo->description = 0;
         write("Description zapped.\n");
         discuss_memo_menu(memo);
         break;
      case 'q' :
         write("Quiting memo addition!\n");
         break;
      case 's' :
         discuss_memo_save(memo);
         break;
      case 'm' :
         discuss_memo_menu(memo);
         break;
      default :
         write("Invalid choice\nChoice: ");
         input_to("discuss_memo_menu_choice", 0, memo);
         break;
   }
}
protected int do_discuss_memo(int op, string club_name) {
   discuss_memo_menu(new(class memo_item, choices : ({ }),
                                          timeout : 14,
                                          club_name : club_name,
                                          open : op));
   return 1;
}
int do_discuss(int open, string type, string club_name) {
   if (open) {
      open = CLUB_DISCUSS_OPEN;
   }
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("No such club '" + club_name + "'.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_elected_club(club_name)) {
      add_failed_mess("The club " + CLUB_HANDLER->query_club_name(club_name) +
                      " is not an elected club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->holds_any_position_of(club_name, this_player()->query_name())) {
      if (type != "no confidence" &&
          type != "remove member") {
         add_failed_mess("Non elected officals can only add discussion items "
                         "of 'no confidence' and 'remove member'.\n");
         return 0;
      }
   }
   switch (type) {
      case "description" :
         return do_discuss_description(open, club_name);
      case "add position" :
         return do_discuss_add_position(open, club_name);
      case "change position name" :
         return do_discuss_change_position_name(open, club_name);
      case "memo" :
         return do_discuss_memo(open, club_name);
      case "remove member" :
         return do_discuss_remove_member(open, club_name);
      case "secret" :
         return do_discuss_secret(open, club_name);
      case "remove position" :
         return do_discuss_remove_position(open, club_name);
      case "no confidence" :
         return do_discuss_no_confidence(open, club_name);
      case "create account" :
         return do_discuss_create_account(open, club_name);
      case "remove account" :
         return do_discuss_remove_account(open, club_name);
      default :
         add_failed_mess("Horrible, horrible error.  The worms!  "
                         "The worms!\n");
         return 0;
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/topography/milestone.c ===
#include <dirs.h>
#include <room.h>
mapping milestone_dirs = ([ ]);
mapping milestone_index = ([ ]);
mapping shorten = SHORTEN;
string topo_handler;
int *actual_room_size;
string motion_verb = "walk", short_mse;
string iroom_exit_mess = "$N $V$s away to the $T.";
string iroom_enter_mess = "$N $V$s in from the $F.";
string iroom_move_mess = "You $V a little to the $T.\n";
string *pass_mess = ({
  "You $V a long while.",
  "$N passes by heading $T.",
  "  On the way you pass $O.\n"
});
mixed other_exits = ({ });
string *other_types = ({ });
mapping look_mess = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
void add_topo_exits_int();
void set_area_handler(string s) { topo_handler = s; }
void set_topo_handler(string s) { topo_handler = s; }
string query_topo_handler() { return topo_handler; }
void set_actual_room_size(int *s) { actual_room_size = copy(s); }
int *query_actual_room_size() { return actual_room_size; }
void set_motion_verb(string s) { motion_verb = s; }
string query_motion_verb() { return motion_verb; }
void set_iroom_exit_mess(string s) { iroom_exit_mess = s; }
string query_iroom_exit_mess() { return iroom_exit_mess; }
void set_iroom_enter_mess(string s) { iroom_enter_mess = s; }
string query_iroom_enter_mess() { return iroom_enter_mess; }
void set_iroom_move_mess(string s) { iroom_move_mess = s; }
string query_iroom_move_mess() { return iroom_move_mess; }
void set_pass_mess(string *s) { pass_mess = s; }
string *query_pass_mess() { return pass_mess; }
void add_look_mess(mapping m) { look_mess += m; }
mapping query_look_mess() { return look_mess; }
void add_milestone_dir(string handler, string dir) {
  if (undefinedp(milestone_dirs[handler])) {
    milestone_dirs[handler] = ({ dir });
  } else {
    milestone_dirs[handler] += ({ dir });
  }
}
mixed query(string s) { return fetch_variable(s); }
varargs void set_milestone_index(string handler, int index) {
  milestone_index[handler] = index;
}
void setup_milestone() {
  string handler;
  foreach (handler in keys(milestone_index)) {
    handler->setup_milestone(this_object());
  }
  add_topo_exits_int();
}
int add_milestone_exit(string s, string dest, string type) {
  string ss, em, xm, mm;
  add_exit(s, dest, type);
  add_exit(motion_verb + " " + s, "interroom", "hidden");
  if (!undefinedp(shorten[s])) {
    ss = shorten[s];
    add_alias(motion_verb + " " + ss, motion_verb + " " + s);
  } else {
    ss = s;
  }
  if (type != "hidden") {
    remove_exit(motion_verb + " <" + short_mse + ">");
    if (!short_mse) {
      short_mse = ss;
    } else {
      short_mse += "/" + ss;
    }
    add_exit(motion_verb + " <" + short_mse + ">", "interroom", type);
  }
  em = replace(iroom_enter_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  xm = replace(iroom_exit_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  mm = replace(iroom_move_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  modify_exit(motion_verb + " " + s, ({
    "exit mess", "$N " + motion_verb + "$s away to the " + s + ".",
    "enter mess", "$N " + motion_verb + "$s in from the " + opposites[s] + ".",
    "move mess", "You " + motion_verb + " a little to the " + s + ".\n"
  }));
  return modify_exit(s, ({ "function", "passing_mess" }) );
}
int passing_mess(string dir, object ob, string special_mess) {
  int i;
  object *obs, passed;
  string mess1, mess2, handler;
  foreach (handler in keys(milestone_dirs)) {
    i = member_array(dir, milestone_dirs[handler]);
    if (i < 0) {
      continue;
    }
    obs = handler->query_irooms_inv(milestone_index[handler], -1, i);
    if (stringp(pass_mess[0])) {
      mess1 = replace(pass_mess[0], ({ "$V", motion_verb, "$T", dir, "$F",
                                         opposites[dir] }));
      if (stringp(pass_mess[2]) && sizeof(obs)) {
        mess1 += replace(pass_mess[2], "$O", query_multiple_short(obs));
      }
      mess1 += "\n";
      tell_object(ob, mess1);
    }
    if (stringp(pass_mess[1])) {
      mess2 = replace(pass_mess[1], ({ "$V", motion_verb, "$T", dir, "$F",
                                         opposites[dir], "$N",
                                         ob->a_short() }));
      foreach (passed in obs) {
        if (living(passed) && ob->query_visible(passed)) {
          tell_object(passed, mess2 + "\n");
        }
      }
    }
    return 1;
  }
  return 1;
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  string verb, rest, *words, handler;
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return ::query_dest_other(direc);
  }
  words = explode(direc, " ");
  verb = words[0];
  if (verb != motion_verb) {
    ret = ::query_dest_other(direc);
    if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
    (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
      room = (topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                               direc);
      if (!objectp(room)) {
        return 0;
      }
      ret[ROOM_DEST] = file_name(room);
    }
    return ret;
  }
  if (sizeof(words) < 2) {
    notify_fail(motion_verb + " which way?\n");
    return 0;
  }
  rest = implode(words[1..], " ");
  foreach (handler in keys(milestone_dirs)) {
    i = member_array(rest, milestone_dirs[handler]);
    if (i < 0) {
      continue;
    }
    if (i == 0) {
      room = handler->find_room_at_index(milestone_index[handler] - 1, -2);
    } else {
      room = handler->find_room_at_index(milestone_index[handler], 0);
    }
    if (!objectp(room)) {
      return 0;
    }
    ret = ::query_dest_other(direc);
    if (!sizeof(ret)) {
      return 0;
    }
    ret[ROOM_DEST] = file_name(room);
    return ret;
  }
  return 0;
}
string query_look(string direc) {
  int i, dark;
  string s, direc_s, h;
  mixed dest;
  direc_s = direc;
  foreach (h in keys(milestone_dirs)) {
    i = member_array(direc_s, milestone_dirs[h]);
    if (i >= 0) {
      direc_s = motion_verb + " " + direc_s;
      break;
    }
  }
  if (s = ::query_look(direc_s)) {
    return s;
  }
  if (s = look_mess[direc_s]) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      return s[0..<2];
    }
    return s;
  }
  return 0;
}
void add_topo_exits(string *e, string type) {
  other_exits += ({ e });
  other_types += ({ type });
}
void add_topo_exits_int() {
  int i;
  string s;
  for (i = 0; i < sizeof(other_exits); i++) {
    foreach (s in other_exits[i]) {
      if ((s == "compass4") || (s == "compass8")) {
        if (!query_exit("north")) add_exit("north", "/topography",
                                           other_types[i]);
        if (!query_exit("south")) add_exit("south", "/topography",
                                           other_types[i]);
        if (!query_exit("east")) add_exit("east", "/topography",
                                          other_types[i]);
        if (!query_exit("west")) add_exit("west", "/topography",
                                          other_types[i]);
        if (s == "compass8") {
          if (!query_exit("northeast")) add_exit("northeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("northwest")) add_exit("northwest", "/topography",
                                                 other_types[i]);
          if (!query_exit("southeast")) add_exit("southeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("southwest")) add_exit("southwest", "/topography",
                                                 other_types[i]);
        }
      } else {
        add_exit(s, "/topography", other_types[i]);
      }
    }
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/topography/iroom.c ===
#include <dirs.h>
#include <room.h>
int *milestone_index;
string *milestone_dirs = ({ });
string iroom_handler;
mapping shorten = SHORTEN;
string topo_handler;
string motion_verb = "walk", exit_type = "road", short_mse;
string iroom_exit_mess = "$N $V$s away to the $T.";
string iroom_enter_mess = "$N $V$s in from the $F.";
string iroom_move_mess = "You $V a little to the $T.\n";
string *pass_mess = ({
  "You $V a long while.",
  "$N passes by heading $T.",
  "  On the way you pass $O.\n"
});
mixed other_exits = ({ });
string *other_types = ({ });
mapping look_mess = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
void set_area_handler(string s) { topo_handler = s; }
void set_topo_handler(string s) { topo_handler = s; }
string query_topo_handler() { return topo_handler; }
void set_iroom_handler(string s) { iroom_handler = s; }
string query_iroom_handler() { return iroom_handler; }
void set_motion_verb(string s) { motion_verb = s; }
string query_motion_verb() { return motion_verb; }
void set_iroom_exit_mess(string s) { iroom_exit_mess = s; }
string query_iroom_exit_mess() { return iroom_exit_mess; }
void set_iroom_enter_mess(string s) { iroom_enter_mess = s; }
string query_iroom_enter_mess() { return iroom_enter_mess; }
void set_iroom_move_mess(string s) { iroom_move_mess = s; }
string query_iroom_move_mess() { return iroom_move_mess; }
void set_pass_mess(string *s) { pass_mess = s; }
string *query_pass_mess() { return pass_mess; }
void add_look_mess(mapping m) { look_mess += m; }
mapping query_look_mess() { return look_mess; }
void set_exit_type(string s) { exit_type = s; }
string query_exit_type() { return exit_type; }
void set_milestone_index(int *i) { milestone_index = i; }
int *query_milestone_index() { return milestone_index; }
void add_milestone_dir(string s) {
  int i;
  string ss, em, xm, mm;
  i = sizeof(milestone_dirs);
  milestone_dirs += ({ s });
  if (!(iroom_handler)->query_endpoint(milestone_index[0],
                                       milestone_index[1], i)) {
    modify_exit(s, ({ "function", "passing_mess" }) );
  }
  add_exit(motion_verb + " " + s, "interroom", "hidden");
  if (!undefinedp(shorten[s])) {
    ss = shorten[s];
    add_alias(motion_verb + " " + ss, motion_verb + " " + s);
  } else {
    ss = s;
  }
  remove_exit(motion_verb + " <" + short_mse + ">");
  if (!short_mse) {
    short_mse = ss;
  } else {
    short_mse += "/" + ss;
  }
  add_exit(motion_verb + " <" + short_mse + ">", "interroom", exit_type);
  em = replace(iroom_enter_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  xm = replace(iroom_exit_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  mm = replace(iroom_move_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  modify_exit(motion_verb + " " + s, ({
    "exit mess", xm,
    "enter mess", em,
    "move mess", mm
  }));
}
string *query_milestone_dirs() { return milestone_dirs; }
int passing_mess(string dir, object ob, string special_mess) {
  int i;
  object *obs, passed;
  string mess1, mess2;
  i = member_array(dir, milestone_dirs);
  if (i < 0) {
    return 0;
  }
  obs = (iroom_handler)->query_irooms_inv(milestone_index[0],
                                          milestone_index[1], i);
  if (stringp(pass_mess[0])) {
    mess1 = replace(pass_mess[0], ({ "$V", motion_verb, "$T", dir, "$F",
                                       opposites[dir] }));
    if (stringp(pass_mess[2]) && sizeof(obs)) {
      mess1 += replace(pass_mess[2], "$O", query_multiple_short(obs));
    }
    mess1 += "\n";
    tell_object(ob, mess1);
  }
  if (stringp(pass_mess[1])) {
    mess2 = replace(pass_mess[1], ({ "$V", motion_verb, "$T", dir, "$F",
                                       opposites[dir], "$N", ob->a_short() }));
    foreach (passed in obs) {
      if (living(passed) && ob->query_visible(passed)) {
        tell_object(passed, mess2 + "\n");
      }
    }
  }
  return 1;
}
mixed query_quit_handler() {
  string s;
  s = explode(file_name(environment(this_player())), "#")[0];
  return ({ s, query_co_ord() });
}
void enter(object player) {
  object new_room;
  if (sizeof(explode(file_name(this_object()), "#")) > 1) {
    return;
  }
  new_room = (iroom_handler)->find_room_at_coord(
                 player->query_saved_co_ords());
  if (!objectp(new_room)) {
    tell_creator("jeremy", "Couldn't find iroom for %O at %O...\n",
                 player, player->query_saved_co_ords());
    player->move(player->query_start_pos());
    return;
  }
  tell_creator("jeremy", "Moving %O to %O...\n",
               player, new_room);
  player->move(new_room);
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  string verb, rest, *words;
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return ::query_dest_other(direc);
  }
  words = explode(direc, " ");
  verb = words[0];
  if (verb != motion_verb) {
    ret = ::query_dest_other(direc);
    if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
    (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
      room = (topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                               direc);
      if (!objectp(room)) {
        return 0;
      }
      ret[ROOM_DEST] = file_name(room);
    }
    return ret;
  }
  if (sizeof(words) < 2) {
    notify_fail(motion_verb + " which way?\n");
    return 0;
  }
  rest = implode(words[1..], " ");
  i = member_array(rest, milestone_dirs);
  if (i < 0) {
    notify_fail("You can't " + motion_verb + " that way.\n");
    return 0;
  }
  room = (iroom_handler)->find_room_at_index(milestone_index[0],
                                              milestone_index[1]+2*i-1);
  if (!objectp(room)) {
    return 0;
  }
  ret = ::query_dest_other(direc);
  if (!sizeof(ret)) {
    return 0;
  }
  ret[ROOM_DEST] = file_name(room);
  return ret;
}
string query_look(string direc) {
  int i, dark;
  string s, direc_s;
  mixed dest;
  direc_s = direc;
  i = member_array(direc_s, milestone_dirs);
  if (i >= 0) {
    direc_s = motion_verb + " " + direc_s;
  }
  if (s = ::query_look(direc_s)) {
    return s;
  }
  if (s = look_mess[direc_s]) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      return s[0..<2];
    }
    return s;
  }
  return 0;
}
void add_topo_exits(string *e, string type) {
  other_exits += ({ e });
  other_types += ({ type });
}
void add_topo_exits_int() {
  int i;
  string s;
  for (i = 0; i < sizeof(other_exits); i++) {
    foreach (s in other_exits[i]) {
      if ((s == "compass4") || (s == "compass8")) {
        if (!query_exit("north")) add_exit("north", "/topography",
                                           other_types[i]);
        if (!query_exit("south")) add_exit("south", "/topography",
                                           other_types[i]);
        if (!query_exit("east")) add_exit("east", "/topography",
                                          other_types[i]);
        if (!query_exit("west")) add_exit("west", "/topography",
                                          other_types[i]);
        if (s == "compass8") {
          if (!query_exit("northeast")) add_exit("northeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("northwest")) add_exit("northwest", "/topography",
                                                 other_types[i]);
          if (!query_exit("southeast")) add_exit("southeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("southwest")) add_exit("southwest", "/topography",
                                                 other_types[i]);
        }
      } else {
        add_exit(s, "/topography", other_types[i]);
      }
    }
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/topography/aroom.c ===
#include <dirs.h>
#include <room.h>
private string _topo_handler;
private mapping _look_mess = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
int* query_co_ord();
mixed* query_dest_other(string direc);
int query_door_open(string direc);
int query_exit(string str);
void add_exit(string dir, string location, string type);
void set_area_handler(string s) { _topo_handler = s; }
void set_topo_handler(string s) { _topo_handler = s; }
string query_topo_handler() { return _topo_handler; }
void add_look_mess(mapping m) { _look_mess += m; }
mapping query_look_mess() { return _look_mess; }
mixed query_quit_handler() {
  string s;
  s = explode(file_name(environment(this_player())), "#")[0];
  return ({ s, query_co_ord() });
}
void enter(object player) {
  object new_room;
  if (sizeof(explode(file_name(this_object()), "#")) > 1) {
    return;
  }
  new_room = (_topo_handler)->find_room_at_coord(
                 player->query_saved_co_ords());
  if (!objectp(new_room)) {
    tell_creator("jeremy", "Couldn't find area room for %O at %O...\n",
                 player, player->query_saved_co_ords());
    player->move(player->query_start_pos());
    return;
  }
  tell_creator("jeremy", "Moving %O to %O...\n",
               player, new_room);
  player->move(new_room);
}
varargs mixed *query_dest_other( string direc, mixed* other_res) {
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return other_res;
  }
  room = (_topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                           direc);
  if (!objectp(room)) {
    return 0;
  }
  ret = other_res;
  if (!sizeof(ret)) {
    return 0;
  }
  ret[ROOM_DEST] = file_name(room);
  return ret;
}
string query_look(string direc, string other_result) {
  int dark;
  string s;
  string direc_s;
  mixed dest;
  direc_s = direc;
  if (other_result) {
    return s;
  }
  s = _look_mess[direc_s];
  if (s) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      return s[0..<2];
    }
    return s;
  }
  return 0;
}
void add_topo_exits(string *other_exits, string other_types) {
  string s;
  foreach (s in other_exits) {
    if ((s == "compass4") || (s == "compass8")) {
      if (!query_exit("north")) {
        add_exit("north", "/topography", other_types);
      }
      if (!query_exit("south")) {
        add_exit("south", "/topography", other_types);
      }
      if (!query_exit("east")) {
        add_exit("east", "/topography", other_types);
      }
      if (!query_exit("west")) {
        add_exit("west", "/topography", other_types);
      }
      if (s == "compass8") {
        if (!query_exit("northeast")) {
          add_exit("northeast", "/topography", other_types);
        }
        if (!query_exit("northwest")) {
          add_exit("northwest", "/topography", other_types);
        }
        if (!query_exit("southeast")) {
          add_exit("southeast", "/topography", other_types);
        }
        if (!query_exit("southwest")) {
          add_exit("southwest", "/topography", other_types);
        }
      }
    } else {
      add_exit(s, "/topography", other_types);
    }
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/feature_base.c ===
inherit "/std/room/inherit/terrain_map/distance_str";
private int _max_range;
private int _max_day_range;
private int _max_night_range;
private int _min_range = -1;
private int _range_offset;
private int _blocking;
private object _region;
class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}
void set_region(mixed region) {
   if (_region) {
      _region->dest_me();
   }
   if (stringp(region)) {
      _region = clone_object(region);
   } else if (objectp(region)) {
      _region = region;
   }
}
object query_region_ob() {
   return _region;
}
void set_range_offset(int offset) {
   _range_offset = offset;
}
int query_range_offset() {
   return _range_offset;
}
void set_max_day_range(int range) {
  _max_day_range = range;
   if (_max_day_range > _max_range) {
      _max_range = _max_day_range;
   }
}
int query_max_day_range() {
   return _max_day_range;
}
void set_max_night_range(int range) {
   _max_night_range = range;
   if (_max_night_range > _max_range) {
      _max_range = _max_night_range;
   }
}
int query_max_night_range() {
   return _max_night_range;
}
void set_min_range(int range) {
  _min_range = range;
}
int query_min_range() {
   return _min_range;
}
int query_max_range() {
   return _max_range;
}
int set_blocking(int blocking) {
   _blocking = blocking;
}
int query_blocking() {
   return _blocking;
}
string calc_feature_desc(mapping direc, int night, int visibility) {
   return "This needs to be set.";
}
mapping filter_distances(mapping direcs) {
   return filter(direcs, (: $2 <= _max_range :));
}
mapping query_feature_desc_from(int x, int y, int z, int no_filter) {
   mapping bits;
   if (_region) {
      bits = _region->query_feature_desc_from(x, y, z);
      if (bits) {
        if(no_filter)
          return bits;
        else
          return filter_distances(bits);
      }
   }
   return ([ ]);
}
int is_inside_region(int x1, int y1, int x2, int y2) {
   return _region->is_inside_region(x1, y1, x2, y2, query_max_range());
}
void dest_me() {
   if (_region) {
      _region->dest_me();
   }
   destruct(this_object());
}
