
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/terrain_things/dungeon_maker.c ===
#include <dirs.h>
#include <terrain.h>
#define END 0
#define TWO 1
#define FOUR 2
#define ROOM 3
#define HALF 0
#define FULL 1
#define DIRS ({ "north", "northeast", "east", "southeast", \
      "south", "southwest", "west", "northwest" })
inherit "/std/object";
int max, size, *clear, *c_probs, *p_probs, *r_probs, *start;
string terrain_name, *passage_files, *room_files;
object easel;
mixed *passages, *room_entries;
void setup() {
   set_name( "box" );
   set_short( "green box" );
   add_adjective( "green" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
   reset_get();
   start = allocate( 3 );
   passages = ({ });
   room_entries = ({ });
}
void dest_me() {
   if ( easel )
      easel->dest_me();
   ::dest_me();
}
int query_max_locations() { return max; }
void set_max_locations( mixed arg ) { max = to_int( arg ); }
int *query_junction_clearance() { return clear; }
void set_junction_clearance( mixed *args ) {
   int i;
   clear = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      clear[ i ] = to_int( args[ i ] );
}
int *query_continue_probabilities() { return c_probs; }
void set_continue_probabilities( mixed *args ) {
   int i;
   c_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      c_probs[ i ] = to_int( args[ i ] );
}
int *query_passage_probabilities() { return p_probs; }
void set_passage_probabilities( mixed *args ) {
   int i;
   p_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      p_probs[ i ] = to_int( args[ i ] );
}
int *query_room_probabilities() { return r_probs; }
void set_room_probabilities( mixed *args ) {
   int i;
   r_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      r_probs[ i ] = to_int( args[ i ] );
}
int *query_start_co_ord() { return start; }
void set_start_co_ord( mixed *args ) {
   int i;
   if ( sizeof( args ) != 3 )
      return;
   for ( i = 0; i < sizeof( args ); i++ )
      start[ i ] = to_int( args[ i ] );
}
string query_terrain_name() { return terrain_name; }
void set_terrain_name( string word ) { terrain_name = word; }
string *query_passage_files() { return passage_files; }
void set_passage_files( string *words ) { passage_files = words; }
string *query_room_files() { return room_files; }
void set_room_files( string *words ) { room_files = words; }
object query_easel() { return easel; }
mixed *query_passages() { return passages; }
mixed *query_room_entries() { return room_entries; }
int do_generate(string);
void init() {
   add_command( "generate", "<word'terrainname'>", (:do_generate($4[0]):));
}
void mark_passage( int *co_ord ) {
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] ) / size,
         ( start[ 0 ] - co_ord[ 0 ] ) / size }), ({ "#" }) );
}
void mark_room( int *co_ord, string room ) {
   int width;
   width = (int)room->query_room_size();
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] - width - size / 2 ) / size,
         ( start[ 0 ] - co_ord[ 0 ] - width - size / 2 ) / size }),
         (string *)easel->make_block( ( 2 * width ) / size + 2 ) );
}
int do_generate( string word ) {
   int i;
   string data, direc, *lines;
   mixed *parameters;
   if ( easel )
      return notify_fail( "The generator is working on "+
            terrain_name +".\n" );
   if ( file_size( word ) < 0 )
      return notify_fail( "File "+ word +" does not exist.\n" );
   lines = explode( read_file( word ), "\n" );
   for ( i = 0; i < sizeof( lines ); i++ ) {
      if ( lines[ i ] == "" )
         continue;
       if ( lines[ i ][ 0 .. 0 ] == "#" )
         continue;
      parameters = explode( lines[ i ], " " );
      if ( !stringp( parameters[ 0 ] ) ) {
         printf( "%s line %d: %O is not a string.\n", word, i,
               parameters[ 0 ] );
         continue;
      }
      if ( sizeof( parameters ) == 2 )
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 ] );
      else
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 .. sizeof( parameters ) - 1 ] );
      printf( "Set %s to %O.\n", parameters[ 0 ], call_other( this_object(),
            "query_"+ parameters[ 0 ] ) );
   }
   if ( file_size( RESTORE_PATH + terrain_name +".o" ) > 0 )
      return notify_fail( "Terrain "+ terrain_name +" already exists.\n" );
   easel = clone_object( "/obj/misc/easel" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\nIt seems "+
         "to be humming quietly but in a very powerful way.\n" );
   write( "Working on "+ terrain_name +".\n" );
   direc = DIRS[ random( 8 ) ];
   for ( i = 0; i < 4; i++ )
      passages += ({ ({ DIRS[ ( member_array( direc, DIRS ) + 2 * i ) % 8 ],
            passage_files[ random( sizeof( passage_files ) ) ],
            start, 0, 0, 1 + clear[ 0 ] + random( clear[ 1 ] ) }) });
   size = 2 * (int)passage_files[ 0 ]->query_room_size();
   TERRAIN_MAP->add_floating_location( terrain_name, passage_files[ 0 ],
         start, 0 );
   call_out( "process_passages", 2 );
   return 1;
}
void stop_working() {
   tell_room( environment(), "The box stops humming as it extrudes an "+
         "easel from a slot in one side.\n" );
   easel->add_shape( ({ 0, 0 }), ({ "@" }) );
   write_file( "/open/"+ terrain_name +".map",
         implode( (string *)easel->query_lines(), "\n" ) );
   easel->move( environment() );
   easel = 0;
   passages = ({ });
   room_entries = ({ });
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
}
int *shift_in( int *co_ord, string direc, string from, string to ) {
   int i, delta, *new_co_ord, *vector;
   delta = (int)from->query_room_size() + (int)to->query_room_size();
   new_co_ord = allocate( 3 );
   vector = STD_ORDERS[ member_array( direc, STD_ORDERS ) + 1 ];
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = co_ord[ i ] - delta * vector[ i ];
   return new_co_ord;
}
void process_passages() {
   int i, j, k, prob, straight, *co_ord, *new_co_ord;
   string direc, new_direc, type, new_type;
   mixed *last;
   if ( !sizeof( passages ) ) {
      tell_room( environment(), "No passages to process.\n" );
      return stop_working();
   }
   if ( max < 1 ) {
      tell_room( environment(), "Reached maximum.\n" );
      return stop_working();
   }
   max--;
   direc = passages[ 0 ][ 0 ];
   type = passages[ 0 ][ 1 ];
   co_ord = passages[ 0 ][ 2 ];
   last = passages[ 0 ][ 3 .. 4 ];
   straight = passages[ 0 ][ 5 ];
   passages = delete( passages, 0, 1 );
   call_out( "process_passages", 2 );
   for ( i = 0; i < 3; i++ ) {
      new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 + i ) % 8 ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      if ( sizeof( (mixed *)TERRAIN_MAP->
            member_floating_locations( new_co_ord ) ) ) {
         tell_room( environment(), "Passage already at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
      for ( j = 0; j < sizeof( room_entries ); j++ ) {
         for ( k = 0; k < 3; k++ )
            if ( new_co_ord[ k ] != room_entries[ j ][ k ] )
               break;
         if ( k < 3 )
            continue;
         tell_room( environment(), "Room entry at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; "+
               "joining passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         mark_passage( new_co_ord );
         room_entries = delete( room_entries, j, 1 );
         return;
      }
      if ( (int)easel->query_at( ({ ( new_co_ord[ 1 ] - start[ 1 ] ) / size,
            ( start[ 0 ] - new_co_ord[ 0 ] ) / size }) ) != 32 ) {
         tell_room( environment(), "Something at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
   }
   prob = random( 100 );
   if ( prob < p_probs[ END ] ) {
      tell_room( environment(), "Passage going "+ direc +" ends at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ END ];
   if ( ( prob < p_probs[ TWO ] ) && !straight ) {
      if ( random( 100 ) >= c_probs[ HALF ] + c_probs[ FULL ] ) {
         tell_room( environment(), "Passage branching "+ direc +" and " );
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type,
               new_co_ord, 0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
            direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
                  6 * random( 2 ) ) % 8 ];
         else
            direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
                  4 * random( 2 ) ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         tell_room( environment(), direc +" from "+
               co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
         return;
      }
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 1 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 2 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), "Passage branching "+ new_direc +" and " );
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), new_direc +" from "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ TWO ];
   if ( ( prob < p_probs[ FOUR ] ) && !straight ) {
      tell_room( environment(), "Crossroads from "+ direc +" at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      for ( i = 0; i < 3; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 + 2 * i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, new_direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
      }
      return;
   }
   prob -= p_probs[ FOUR ];
   if ( ( prob < p_probs[ ROOM ] ) && !straight ) {
      prob = random( 100 );
      new_type = room_files[ 0 ];
      for ( i = 1; i < sizeof( room_files ); i++ )
         if ( prob < r_probs[ FULL + i ] ) {
            new_type = room_files[ i ];
            break;
         } else
            prob -= r_probs[ FULL + i ];
      new_co_ord = shift_in( co_ord, direc, type, new_type );
      tell_room( environment(), "Room at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
      TERRAIN_MAP->add_floating_location( terrain_name, new_type,
            new_co_ord, 0 );
      mark_room( new_co_ord, new_type );
      mark_passage( co_ord );
      for ( i = 1; i < 8; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 4 + i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         co_ord = shift_in( new_co_ord, new_direc, new_type, type );
         if ( i % 2 ) {
            if ( random( 100 ) < r_probs[ HALF ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         } else {
            if ( random( 100 ) < r_probs[ FULL ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         }
      }
      return;
   }
   prob = random( 100 );
   if ( ( prob < c_probs[ HALF ] ) && !straight ) {
      direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
             6 * random( 2 ) ) % 8 ];
      straight = clear[ 0 ] + random( clear[ 1 ] );
   } else {
      prob -=  c_probs[ HALF ];
      if ( ( prob < c_probs[ FULL ] ) && !straight ) {
         direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
               4 * random( 2 ) ) % 8 ];
         straight = clear[ 0 ] + random( clear[ 1 ] );
      }
   }
   if ( straight > 0 )
      straight--;
   new_co_ord = shift_in( co_ord, direc, type, type );
   tell_room( environment(), "Passage goes "+ direc +" from "+
         co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
   TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
   passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
         straight }) });
   mark_passage( new_co_ord );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/terrain_things/sample_passage_2.c ===
inherit "/std/room";
void setup() {
   set_short( "rock-walled tunnel" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are tunnel with rough-hewn rock walls.  It looks as though "+
         "it has been deserted for a long time.\n" );
   add_item( ({ "rough-hewn rock wall", "rock" }), "The walls are rough, "+
         "where the tunnel was hewn out of the rock." );
}
string query_exit_type( string word ) { return "corridor"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/terrain_things/sample_room_2.c ===
inherit "/std/room";
void setup() {
   set_short( "largish room" );
   set_light( 20 );
   set_room_size( 25 );
   set_long( "You are in a largish room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/terrain_things/sample_passage_1.c ===
inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/autodoc/autodoc_nroff.c ===
#include <autodoc.h>
private void write_single_description(string func, mixed *stuff,
                                      string output, string fn);
private string query_methods(string *funcs, function data,
                           string base_single, string fn);
private string query_func_def(mixed *stuff, string func);
private string query_method_description(mapping docs);
private string parse_string(string inp);
string convert_html(string text, int depth, int preformat, int edge_width);
private string query_defines(mapping defines);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn);
private string query_classes(string base_single,
                           mapping classes,
                           string fn);
void create() {
   seteuid(getuid());
}
void create_nroff_file(object file, string output) {
   mapping stuff;
   string *funcs;
   string *bits;
   string name;
   string base_single;
   string *files;
   string ret;
   int pos;
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   ret = "";
   ret += ".DT\n";
   ret += name + "\n" + mud_name() + " autodoc help\n" + name + "\n\n";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      ret += ".SH Description\n";
      ret += convert_html(implode(stuff["main"], " "), 5, 0, 5);
      ret += ".SP 10 5\n";
      if (stuff["author"]) {
         ret += "\n\nWritten by " +
                    parse_string(query_multiple_short(stuff["author"]));
      }
      if (stuff["started"]) {
         ret += "\n\nStarted " +
                    parse_string(query_multiple_short(stuff["started"]));
      }
      ret += "\n.EP\n\n";
      if (stuff["see"]) {
         ret += "\n\n.SH See also\n.SP 5 5\n" +
                            query_multiple_short(stuff["see"]) + "\n.EP\n";
      }
      if (stuff["changed"]) {
         ret += ".SH Change history\n.SP 5 5\n" +
                            parse_string(implode(stuff["changed"], "\n\n")) +
                            "\n.EP\n\n";
      }
      if (stuff["example"]) {
        ret += ".SH Example\n.SI 5\n" +
               parse_string(implode(stuff["example"], "\n")) + "\n.EI\n";
      }
   }
   if (sizeof(file->query_inherits())) {
      ret += ".SH Inherits\n.SP 5 5\n";
      ret += "This class inherits the following classes " +
                         query_multiple_short(keys(file->query_inherits())) +
                         ".\n.EP\n\n";
   }
   if (sizeof(file->query_includes())) {
      ret += ".SH Includes\n.SP 5 5\n";
      ret += "This class includes the following files " +
                         query_multiple_short(file->query_includes()) +
                         ".\n.EP\n\n";
   }
   funcs = filter(keys(file->query_public_functions()),
                  (: $1 != "create" && $1 != "setup" &&
                   !$(file)->query_public_functions()[$1][AUTO_DOCS]["ignore"] :));
   base_single = file->query_file_name();
   pos = strsrch(base_single, ".", -1);
   if (pos > 0) {
      base_single = base_single[0..pos-1];
   }
   base_single = NROFF_DOC_SINGLE + base_single + "/";
   files = get_dir(base_single + "*");
   if (pointerp(files)) {
      foreach (name in files) {
         if (file_size(base_single + name) >= 0) {
            rm(base_single + name);
         }
      }
   }
   if (sizeof(file->query_class_docs())) {
      ret += ".SH Classes\n\n";
      ret += query_classes(base_single,
                    file->query_class_docs(),
                    file->query_file_name());
      ret += "\n";
   }
   if (sizeof(funcs)) {
      ret += ".SH Public Functions\n" +
                         ".SP 5 5\nThese are functions that everyone can "
                         "access.\n.EP\n\n";
      ret += query_methods(funcs,
                    (: $(file)->query_public_functions()[$1] :),
                    base_single,
                    file->query_file_name());
      ret += "\n";
   }
   funcs = filter(keys(file->query_protected_functions()),
                  (: !$(file)->query_protected_functions()[$1][AUTO_DOCS]["ignore"] :));
   if (sizeof(funcs)) {
      ret += ".SH Protected Functions\n"
                         ".SP 5 5\nThese are functions that only "
                         "objects inheriting the class can access.\n.EP\n\n";
      ret += query_methods(funcs, (: $(file)->query_protected_functions()[$1] :),
                    base_single, file->query_file_name());
      ret += "\n";
   }
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      ret += ".SH Defines\n";
      ret += query_defines(file->query_define_docs());
      ret += "";
   }
   write_file(output, ret);
}
private string query_defines(mapping docs) {
   string name;
   string *names;
   string ret;
   names = sort_array(keys(docs), (: strcasecmp :));
   ret = "";
   foreach (name in names) {
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n" +
                         ".EI\n";
      if (docs[name]["main"]) {
         ret += query_method_description(docs[name]);
      }
      ret += "\n";
   }
   return ret;
}
private string query_classes(string base_single,
                           mapping classes,
                           string fn) {
   string name;
   string *names;
   string ret;
   names = sort_array(keys(classes), (: strcasecmp :) );
   ret = "";
   foreach (name in names) {
      reset_eval_cost();
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n";
      ret += query_class_def(classes[name], name) + "\n.EI\n";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         ret += query_class_description(classes[name][AUTO_CLASS_DOCS]);
         write_single_class_description(name,
                                        classes[name],
                                        base_single + name,
                                        fn);
      }
      ret += "\n";
   }
   return ret;
}
private string query_methods(string *funcs,
                           function data,
                           string base_single,
                           string fn) {
   int i;
   mixed *stuff;
   string ret;
   funcs = sort_array(funcs, (: strcmp($1, $2) :));
   ret = "";
   for (i = 0; i < sizeof(funcs); i++) {
      stuff = evaluate(data, funcs[i]);
      ret += ".SI 3\n* %^BOLD%^" + funcs[i] + "%^RESET%^\n" +
                         ".EI\n.SI 5\n" + query_func_def(stuff, funcs[i]) +
                         "\n.EI\n";
      if (stuff[AUTO_DOCS]["main"]) {
         ret += query_method_description(stuff[AUTO_DOCS]);
         write_single_description(funcs[i], stuff, base_single + funcs[i], fn);
      }
      ret += "\n";
   }
   return ret;
}
private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;
   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
}
private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += ", ";
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_long_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;
   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }
   if (docs["member"]) {
      ret += ".SI 7\n%^BOLD%^Members:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            ret +=  ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   return ret;
}
private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;
   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }
   if (docs["param"]) {
      ret += ".SI 7\n%^BOLD%^Parameters:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            ret += ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   if (docs["return"]) {
      ret +=".SI 7\n%^BOLD%^Returns:%^RESET%^\n.EI\n.SP 9 5\n" +
                         parse_string(implode(docs["return"], " ")) +
                         "\n.EP\n";
   }
   return ret;
}
private void write_single_description(string func, mixed *stuff,
                                      string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;
   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }
   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret += ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Syntax\n.SI 5\n" + query_long_func_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["param"]) {
      ret += ".SH Parameters\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["param"]); i++) {
         if (sscanf(fluff["param"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }
   if (fluff["return"]) {
      ret += ".SH Returns\n.SI 5\n";
      ret += implode(fluff["return"], " ");
      ret += ".EI\n\n";
   }
   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }
   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
}
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;
   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }
   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret +=  ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Definition\n.SI 5\n" +
              query_class_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["member"]) {
      ret += ".SH Members\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["member"]); i++) {
         if (sscanf(fluff["member"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }
   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }
   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
}
private string parse_string(string str) {
   return replace(str, ({ "<p>", "\n\n", "<br>", "\n\n",
                          "<b>", "%^BOLD%^", "</b>", "%^RESET%^",
                          "<i>", "%^CYAN%^", "</i>", "%^RESET%^",
                          "<pre>", "\n\n", "</pre>", "\n\n" }));
}
#define LIST_NONE 0
#define LIST_DYNAMIC 1
#define LIST_ORDERED 2
#define LIST_UNORDERED 3
#define LIST_TYPE 0
#define LIST_DEPTH 1
#define LIST_START 2
#define LIST_ADDITIONAL 3
#define LIST_NUM 4
string convert_html(string text, int depth, int preformat, int edge_width) {
   string ret;
   string *bits;
   mixed *lists;
   string* before_centers;
   string start;
   string new_start;
   string additional;
   string add;
   int i;
   string tag;
   string rest;
   ret = "";
   if (text[0] == '.') {
      text = " " + text;
   }
   bits = explode("#" + text, "<");
   bits[0] = bits[0][1..];
   start = ".SP " + depth + " " + edge_width;
   ret = start + "\n" + bits[0];
   additional = "";
   lists = ({ ({ LIST_NONE, depth, start, additional }) });
   before_centers = ({ });
   for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s>%s", tag, rest) == 2) {
            new_start = start;
            add = 0;
            switch (lower_case(tag)) {
               case "p" :
                  ret += "\n\n" + additional;
                  break;
               case "br" :
                  ret += "\n.E" + start[2..2] + "\n" + start + "\n" + additional;
                  break;
               case "dl" :
                  lists += ({ ({ LIST_DYNAMIC, depth, start, additional }) });
                  break;
               case "/dl" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "u" :
                  ret += "_";
                  break;
               case "/u" :
                  ret += "_";
                  break;
               case "center" :
                  before_centers += ({ start });
                  new_start = ".SC";
                  break;
               case "/center" :
                  new_start = before_centers[<1];
                  before_centers = before_centers[0..<2];
                  break;
               case "ol" :
                  lists += ({ ({ LIST_ORDERED, depth, start, additional, 1 }) });
                  break;
               case "/ol" :
                  if (lists[<1][LIST_TYPE] == LIST_ORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "ul" :
                  lists += ({ ({ LIST_UNORDERED, depth, start, additional }) });
                  break;
               case "/ul" :
                  if (lists[<1][LIST_TYPE] == LIST_UNORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "dd" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 3) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 3;
                     start = start[0..3];
                     additional = "";
                  }
                  break;
               case "dt" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 0) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 0;
                     start = start[0..3];
                     additional = "";
                  }
                  break;
               case "li" :
                  if (lists[<1][LIST_TYPE] != LIST_DYNAMIC) {
                     switch (lists[<1][LIST_TYPE]) {
                        case LIST_ORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 3 -" + (6 + lists[<1][LIST_DEPTH]);
                           add = "\n\t" + (lists[<1][LIST_NUM]++) + ". \t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                        case LIST_UNORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 2 -" + (5 + lists[<1][LIST_DEPTH]);
                           add = "\n\t*\t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                     }
                  }
                  break;
               case "pre" :
                  preformat++;
                  break;
               case "b" :
                  ret += "%^BOLD%^";
                  break;
               case "i" :
                  ret += "%^CYAN%^";
                  break;
               case "/b" :
               case "/i" :
                  ret += "%^RESET%^";
                  break;
               case "/pre" :
                  preformat--;
                  break;
               case "code" :
               case "/code" :
                  break;
               default :
                  rest = "<" + tag + ">" + rest;
                  break;
            }
            if (new_start != start) {
               ret += "\n.E" + start[2..2] + "\n" + new_start + "\n";
               start = new_start;
            }
            if (add) {
               ret += add;
            }
            if (preformat) {
               ret += replace(rest, "\n", "\n.E" + start[2..2] + "\n" +
                                    start + "\n" + additional);
            } else {
               rest = replace(rest, "\n", " ");
               while (strlen(rest) && rest[0] == ' ') {
                  rest = rest[1..];
               }
               while (strsrch(rest, "  ") != -1) {
                  rest = replace_string(rest, "  ", " ");
               }
               ret += rest;
            }
         } else {
            ret += ">" + bits[i];
         }
   }
   ret += "\n.E" + start[2..2] + "\n";
   return ret;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/autodoc/autodoc_file.c ===
#define MASTER_OB "/secure/master.c"
#define EOF -1
#define SAVE_DIR "/save/autodoc/"
nosave mapping private_functions;
mapping public_functions;
mapping protected_functions;
mapping inherits;
mapping main_docs;
mapping define_docs;
mapping includes;
mapping class_docs;
string file_name;
int last_changed;
int num_failed_tries;
nosave string current_comment;
nosave string current_file;
nosave int current_position;
nosave int changed;
nosave mapping defines;
nosave mixed *exclude_methods;
private void setup();
private mapping parse_comment(string stuff);
private void do_parse_file(function func);
private int query_file_position();
private void handle_inherit(mixed *bits);
void create() {
   seteuid(getuid());
   setup();
}
private void setup() {
   changed = 0;
   main_docs = 0;
   file_name = "";
   private_functions = ([ ]);
   public_functions = ([ ]);
   protected_functions = ([ ]);
   inherits = ([ ]);
   defines = ([ ]);
   define_docs = ([ ]);
   includes = ([ ]);
   class_docs = ([ ]);
   current_comment = 0;
   current_file = "";
   current_position = 0;
   last_changed = 0;
   exclude_methods = ({ "setup", "create", "init", "dest_me", "reset" });
}
private int query_file_position() {
   return current_position;
}
private int lookahead_character(int num) {
   if (current_position + num - 1 < strlen(current_file)) {
      return current_file[current_position + num - 1];
   }
   return EOF;
}
private int next_character() {
   if (current_position < strlen(current_file)) {
      return current_file[current_position++];
   }
   return EOF;
}
private int pop_character(int num) {
   current_position += num;
}
private void skip_to_end_of_line() {
   int ch;
   do {
      ch = next_character();
   } while (ch != '\r' && ch != '\n' && ch != EOF);
}
private string skip_to_end_of_comment() {
   string data;
   int ch;
   int ok;
   data = "";
   do {
      ok = 1;
      ch = next_character();
      if (ch == '*' && lookahead_character(1) == '/') {
         ok = 0;
         pop_character(1);
      } else if (ch == '\r' || ch == '\n') {
         data += "\n";
         if (lookahead_character(1) == ' ') {
            pop_character(1);
         }
         if (lookahead_character(1) == '*' && lookahead_character(2) != '/') {
            pop_character(1);
            if (lookahead_character(1) == ' ') {
               pop_character(1);
            }
         }
      } else if (ch == EOF) {
         ok = 0;
      } else if (ch == '\\' && (lookahead_character(1) == '/' ||
                               lookahead_character(1) == '*' ||
                               lookahead_character(1) == '\\')) {
      } else {
         data += sprintf("%c", ch);
      }
   } while (ok);
   return data;
}
private void skip_spaces_and_comments() {
   int ok;
   do {
     switch (lookahead_character(1)) {
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
           ok = 1;
           pop_character(1);
           break;
        case '/' :
           if (lookahead_character(2) == '/') {
              ok = 1;
              skip_to_end_of_line();
           } else if (lookahead_character(2) == '*') {
              ok = 1;
              if (lookahead_character(3) != '*' ||
                  lookahead_character(4) == '*') {
                 pop_character(2);
                 skip_to_end_of_comment();
                 current_comment = 0;
              } else {
                 pop_character(3);
                 if (lookahead_character(1) == ' ') {
                    pop_character(1);
                 }
                 if (!main_docs) {
                    main_docs = parse_comment(skip_to_end_of_comment());
                 } else {
                    current_comment = skip_to_end_of_comment();
                 }
              }
           } else {
              ok = 0;
           }
           break;
        default :
           ok = 0;
           break;
     }
   } while (ok);
}
private string expand_token(string token) {
   if (defines[token]) {
      return defines[token];
   }
   return 0;
}
private string get_word() {
   string data;
   int ok;
   int ch;
   skip_spaces_and_comments();
   ok = 1;
   data = "";
   ch = lookahead_character(1);
   if ((ch >= 'a' && ch <= 'z') ||
       (ch >= 'A' && ch <= 'Z') ||
       (ch == '_')) {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
      if (expand_token(data)) {
         current_file = expand_token(data) + current_file[current_position..];
         current_position = 0;
         return get_word();
      }
   } else if ((ch >= '0' && ch <= '9') ||
              (ch == '-')) {
      if (ch == '-') {
         data += sprintf("%c", next_character());
      }
      do {
         ch = lookahead_character(1);
         if ((ch >= '0' && ch <= '9') ||
             (ch >= '.')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
   } else if (ch == '\"' || ch == '\'') {
      int end_ch;
      end_ch = ch;
      ch = next_character();
      data += sprintf("%c", ch);
      do {
         ch = next_character();
         if (ch == end_ch) {
            ok = 0;
            data += sprintf("%c", ch);
         } else if (ch == '\\') {
            ch = next_character();
            data += sprintf("\\%c", ch);
         } else if (ch == EOF) {
            ok = 0;
         } else {
            data += sprintf("%c", ch);
         }
      } while (ok);
   } else if (ch == '(') {
      if (lookahead_character(2) == '{' ||
          lookahead_character(2) == '[') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == '}' || ch == ']') {
      if (lookahead_character(2) == ')') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == ';' ||
              ch == ')' ||
              ch == '=' ||
              ch == '{' ||
              ch == '}') {
      return sprintf("%c", next_character());
   } else if (ch == EOF) {
      return "";
   } else {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_') ||
             (ch == ' ') ||
             (ch == '\t') ||
             (ch == '\n') ||
             (ch == '(') ||
             (ch == ')') ||
             (ch == EOF) ||
             (ch == ';') ||
             (ch == '=') ||
             (ch == '{') ||
             (ch == '}') ||
             (ch == '\'') ||
             (ch == '\"') ||
             (ch == '\r')) {
            ok = 0;
         } else {
            ch = next_character();
            data += sprintf("%c", ch);
         }
      } while (ok);
   }
   return data;
}
private mixed *get_statement(string start) {
   mixed *bits;
   string curr;
   int depth;
   string temp_comment;
   int last_pos;
   int in_class;
   bits = ({ start });
   do {
      last_pos = query_file_position();
      curr = get_word();
      bits += ({ curr });
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
   } while (curr != ";" && curr != "{" && curr != "");
   if (curr == "{") {
      if (member_array("class", bits) != -1 &&
          member_array("(", bits) == -1) {
         in_class = 1;
      }
      temp_comment = current_comment;
      depth = 1;
      do {
        last_pos = query_file_position();
        curr = get_word();
        if (curr == "{") {
           depth++;
        } else if (curr == "}") {
           depth--;
        } else if (curr == "") {
           depth = 0;
        }
        if (last_pos != query_file_position()) {
           reset_eval_cost();
        }
        if (in_class) {
           bits += ({ curr });
        }
      } while (depth > 0);
      current_comment = temp_comment;
   }
   return bits;
}
private mapping parse_comment(string stuff) {
   string *bits;
   int i;
   mapping frog;
   string name;
   int j;
   int rabbit;
   if (!stuff) {
      return ([ ]);
   }
   if (stuff[0] == '@') {
      stuff = "\n" + stuff;
   } else {
      stuff = "\n@main " + stuff;
   }
   bits = explode(stuff, "\n@");
   frog = ([ ]);
   for (i = 0; i< sizeof(bits); i++) {
      j = strsrch(bits[i], " ");
      rabbit = strsrch(bits[i], "\n");
      if (j == -1 || (rabbit != -1 && rabbit < j)) {
         j = rabbit;
      }
      if (j > 0) {
         name = bits[i][0..j - 1];
         stuff = bits[i][j+1..];
         if (!frog[name]) {
            frog[name] = ({ stuff });
         } else {
            frog[name] += ({ stuff });
         }
      }
   }
   return frog;
}
private void handle_class(mixed *bits) {
   string name;
   int i;
   string *types;
   mapping comm;
   name = bits[1];
   types = ({ });
   i = member_array("{", bits);
   if (i != -1) {
      bits = bits[i + 1..];
      while (sizeof(bits)) {
         i = member_array(";", bits);
         if (i != -1) {
            types += ({ ({ bits[i - 1], bits[0..i - 2] }) });
            bits = bits[i + 1..];
         } else {
            bits = ({ });
         }
      }
      comm = parse_comment(current_comment);
      if (!comm["ignore"]) {
         class_docs[name] = ({ 0, types,
                               parse_comment(current_comment) });
      }
   }
}
private void handle_inherit(mixed *bits) {
   int pos;
   string name;
   pos = member_array("inherit", bits);
   if (pos >= 0) {
      name = implode(map(bits[pos+1.. sizeof(bits)-2],
                         function(string str) {
                            if (str[0] == '\"') {
                               sscanf(str, "\"%s\"", str);
                               return str;
                            }
                            return "";
                         } ), "");
      inherits[name] = bits[0..pos-1];
   }
}
private void handle_function_definition(mixed *bits) {
   int pos;
   int end_pos;
   int new_pos;
   string name;
   string *type;
   mixed *args;
   mapping comm;
   pos = member_array("(", bits);
   if (pos > 0) {
      name = bits[pos-1];
      if (member_array(name, exclude_methods) == -1) {
         type = bits[0..pos-2];
         if (sizeof(type) == 0) {
            type = ({ "int" });
         }
         end_pos = member_array(")", bits, pos);
         args = ({ });
         if (end_pos > pos + 1) {
            pos++;
            while (member_array(",", bits, pos) != -1) {
               new_pos = member_array(",", bits, pos);
               args += ({ bits[pos..new_pos-2], bits[new_pos-1] });
               pos = new_pos + 1;
            }
            args += ({ bits[pos..end_pos -2], bits[end_pos-1] });
         }
         comm = parse_comment(current_comment);
         if (!comm["ignore"]) {
            if (member_array("private", type) != -1) {
               type -= ({ "private" });
               private_functions[name] = ({ type, args,
                                          comm });
            } else if (member_array("protected", type) != -1) {
               type -= ({ "protected" });
               protected_functions[name] = ({ type, args,
                                           comm });
            } else {
               type -= ({ "public" });
               public_functions[name] = ({ type, args,
                                           comm });
            }
         }
      }
      current_comment = 0;
   }
}
private string get_rest_of_line() {
   string value;
   int ch;
   int last_pos;
   value = "";
   ch = lookahead_character(1);
   while (ch == ' ' || ch == '\t') {
      pop_character(1);
      ch = lookahead_character(1);
   }
   do {
      last_pos = query_file_position();
      ch = next_character();
      if (ch == '\\') {
         ch = next_character();
         if (ch == '\r' && lookahead_character(1) == '\n') {
            ch = next_character();
         }
         ch = ' ';
      }
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
      value += sprintf("%c", ch);
   } while (ch != '\n' && ch != '\r' && ch != EOF);
   return value;
}
private void handle_hash() {
   int i;
   string token;
   string name;
   string value;
   string *bits;
   string stuff;
   string inc_name;
   string curr_comm;
   mapping comm;
   token = get_word();
   switch (token) {
      case "define" :
      case "defin" :
         curr_comm = current_comment;
         value = get_rest_of_line();
         if (sscanf(value, "%s %s", name, value) == 2) {
            defines[name] = value;
            if (token == "define") {
               comm = parse_comment(curr_comm);
               if (!comm["ignore"]) {
                  define_docs[name] = comm;
               }
               current_comment = 0;
            }
         }
         break;
      case "include" :
         value = get_rest_of_line();
         if (value[0] == '\"') {
            bits = explode(file_name, "/");
            sscanf(value, "\"%s\"", name);
            stuff = read_file(implode(bits[0..<2], "/") +
                              "/" + name);
            if (stuff) {
               inc_name = "/" + implode(bits[0..<2], "/") +
                              "/" + name;
            }
         } else if (value[0] == '<') {
            sscanf(value, "<%s>", name);
         }
         if (name[0] == '/') {
            stuff = read_file(name);
            if (stuff) {
               inc_name = name;
            }
         }
         bits = MASTER_OB->define_include_dirs();
         while (!stuff && i < sizeof(bits)) {
            stuff = read_file(sprintf(bits[i], name));
            if (stuff) {
               stuff = replace_string(stuff, "
               stuff = replace_string(stuff, "class ", "clas ");
               stuff = replace_string(stuff, "#define ", "#defin ");
               inc_name = sprintf(bits[i], name);
            }
            i++;
         }
         if (inc_name) {
            inc_name = replace(inc_name, "
            if (inc_name[0] != '/') {
               inc_name = "/" + inc_name;
            }
         }
         if (stuff && !includes[inc_name]) {
            current_file = stuff + current_file[current_position..];
            current_position = 0;
            includes[inc_name] = unguarded( (: stat($(inc_name)) :) )[1];
         }
         break;
      default :
         skip_to_end_of_line();
         break;
   }
}
private void next_statement() {
   string token;
   string *bits;
   token = get_word();
   if (token[0] == '#') {
      return handle_hash();
   } else if (token == ";") {
      return ;
   } else if (token != "") {
      bits = get_statement(token);
      if (member_array("inherit", bits) != -1) {
         return handle_inherit(bits);
      } else if (bits[0] == "class" &&
                 member_array("(", bits) == -1) {
         return handle_class(bits);
      } else if (bits[sizeof(bits) - 1] == "{" &&
                 member_array("=", bits) == -1) {
         return handle_function_definition(bits);
      } else {
         return ;
      }
   }
}
void load_file() {
   unguarded((: restore_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
   if (!includes) {
      includes = ([ ]);
   }
   if (!class_docs) {
      class_docs = ([ ]);
   }
}
void save_file() {
   unguarded((: save_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
}
void parse_file(string name, function func, int only_load) {
   int curr_change;
   int my_change;
   string my_name;
   int reload;
   setup();
   file_name = name;
   load_file();
   if (!only_load) {
      if (sizeof(unguarded( (: stat($(name)) :) )) > 1) {
         curr_change = unguarded( (: stat($(name)) :) )[1];
         my_name = file_name(this_object());
         sscanf(my_name, "%s#%*s", my_name);
         my_name += ".c";
         my_change = unguarded( (: stat($(my_name)) :) )[1];
         reload = curr_change > last_changed;
         if (my_change > last_changed &&
             my_change > curr_change) {
            curr_change = my_change;
            reload = 1;
         }
         if (!reload) {
            foreach (my_name, my_change in includes) {
               if ( unguarded( (: stat($(my_name)) :) )[1] != my_change) {
                  reload = 1;
                  break;
               }
            }
         }
         if (reload) {
            setup();
            num_failed_tries = 0;
            file_name = name;
            changed = 1;
            last_changed = curr_change;
            current_file = read_file(name);
            current_position = 0;
            if (catch(do_parse_file(func))) {
               evaluate(func);
            }
         } else {
            if (num_failed_tries) {
               num_failed_tries = 0;
               save_file();
            }
            call_out( (: evaluate($1) :), 2, func);
         }
      } else {
         num_failed_tries++;
         save_file();
         call_out( (: evaluate($1) :), 2, func);
      }
   } else {
      call_out( (: evaluate($1) :), 2, func);
   }
}
private void do_parse_file(function func) {
   int num;
   if (unguarded( (: stat(file_name) :))[1] > last_changed) {
      return parse_file(file_name, func, 0);
   }
   num = 0;
   while (lookahead_character(1) != EOF && num < 2) {
      next_statement();
      num++;
   }
   if (lookahead_character(1) == EOF) {
      save_file();
      call_out((: evaluate($1) :), 2, func);
   } else {
      call_out((: do_parse_file($1) :), 2, func);
   }
}
mapping query_inherits() { return inherits; }
mapping query_private_functions() { return private_functions; }
mapping query_public_functions() { return public_functions; }
mapping query_protected_functions() { return protected_functions; }
mapping query_main_docs() {
   if (main_docs) {
      return main_docs;
   }
   return ([ ]);
}
string query_file_name() { return file_name; }
mapping query_defines() { return defines; }
int query_changed() { return changed; }
int query_num_failed_tries() { return num_failed_tries; }
string *query_includes() { return keys(includes); }
mapping query_define_docs() { return define_docs; }
mapping query_class_docs() { return class_docs; }
void dest_me() {
   destruct(this_object());
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/autodoc/autodoc_handler.c ===
#include <autodoc.h>
#define MAIN_FILE 0
#define INDEX_FILE 1
#define SAVE_FILE (SAVE_DIR "main_rubbish")
string *files;
int file_pos;
int something_changed;
int last_created_index;
nosave function *filters;
nosave int call_id;
nosave mapping summary_map;
nosave mixed *extra_indexes;
mapping help_map;
private void create_nroff_file(object ob, int type);
private void create_html_file(object ob, int type);
private void after_thingy(int no_index);
private void start_processing();
private void do_parse_next_file();
private void create_index();
private void add_to_index(object ob);
private void load();
private void save();
string *query_files();
int remove_file(string fname);
void create() {
   seteuid(getuid());
   filters = ({ (: create_nroff_file($1, $2) :),
                (: create_html_file($1, $2) :) });
   file_pos = 0;
   something_changed = 0;
   files = ({ });
   load();
   do_parse_next_file();
}
private void create_nroff_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   if (type == MAIN_FILE) {
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      rm(NROFF_DOC_DIR + fname);
      AUTODOC_NROFF->create_nroff_file(ob, NROFF_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;
           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      for (i = 0; i < sizeof(stuff); i++) {
         fname = NROFF_DOC_DIR + "index_" + lower_case(stuff[i][0][0][0..0]);
         AUTODOC_NROFF->create_nroff_index_file(stuff[i], fname);
      }
   }
}
private void create_html_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   mapping chars;
   if (type == MAIN_FILE) {
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      fname += ".html";
      rm(HTML_DOC_DIR + fname);
      AUTODOC_HTML->create_html_file(ob, HTML_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;
           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name, "", summary_map[name] });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      chars = ([ ]);
      for (i = 0; i < sizeof(stuff); i++) {
         fname = "index_" + lower_case(stuff[i][0][0][0..0]) + ".html";
         rm(HTML_DOC_DIR + fname);
         AUTODOC_HTML->create_html_index_file(stuff[i], stuff[i][0][0][0..0],
                                       HTML_DOC_DIR + fname);
         reset_eval_cost();
         chars[capitalize(stuff[i][0][0][0..0])] =  fname;
      }
      fname = HTML_DOC_DIR;
      AUTODOC_HTML->create_main_index(chars, fname);
   }
}
private void after_thingy(int no_index) {
   int i;
   if (no_index) {
      printf("Finished recreating the documentation for %O\n",
              previous_object()->query_file_name(),
             previous_object());
   }
   if (previous_object()->query_changed()) {
      something_changed = 1;
   }
   if (previous_object()->query_num_failed_tries() > 1) {
      remove_file(files[file_pos - 1]);
   } else if (previous_object()->query_changed() || no_index) {
      for (i = 0; i < sizeof(filters); i++) {
         call_out((: evaluate($1, $2, $3) :), 0, filters[i],
                  previous_object(), MAIN_FILE);
      }
   }
   call_out((: $1->dest_me() :), 20, previous_object());
   save();
}
private void do_parse_next_file() {
   call_id = call_out((: start_processing() :), 60);
   if (file_pos >= sizeof(files)) {
      file_pos = 0;
   }
   new(AUTODOC_FILE)->parse_file(files[file_pos++], (: after_thingy(0) :));
}
private void start_processing() {
   if (sizeof(files) == 0) {
      return ;
   }
   if (last_created_index + SAVE_INDEX_DELAY < time()) {
      if (something_changed) {
         call_out( (: create_index() :), 2);
      }
      something_changed = 0;
      save();
   }
   call_id = call_out((: do_parse_next_file() :), 360);
}
private string query_short_args_def(mixed *args) {
   string ret;
   int i;
   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
}
private string *process_stuff(string name,
                              string fname,
                              string fn,
                              mapping docs) {
   string blue;
   int i;
   int end;
   mixed *ret;
   mapping fluff;
   if (name != "create" && name != "setup" && name != "init") {
      if (help_map[name]) {
         help_map[name] += ({ fn });
      } else {
         help_map[name] = ({ fn });
      }
   }
   if (docs[name]) {
      if (arrayp(docs[name])) {
         fluff = docs[name][AUTO_DOCS];
         ret =  ({ name, fname, query_short_args_def(docs[name][AUTO_ARGS]) });
      } else {
         ret = ({ name, fname, "" });
         fluff = docs[name];
      }
   } else {
      ret = ({ name, fname, "" });
      if (mapp(docs)) {
         fluff = docs;
      } else {
         fluff = ([ ]);
      }
   }
   if (fluff["main"]) {
      blue = implode(fluff["main"], "\n");
      end = strlen(blue);
      i = strsrch(blue, ".");
      if (i > 0) {
         end = i;
      }
      i = strsrch(blue, "!");
      if (i > 0 && i < end) {
         end = i;
      }
      i = strsrch(blue, "?");
      if (i > 0 && i < end) {
         end = i;
      }
      blue = blue[0..end];
   }
   ret += ({ blue });
   if (fluff["index"]) {
      foreach (blue in fluff["index"]) {
         blue = replace(blue, ({ " ", "", "\n", "" }));
         if (help_map[blue]) {
            help_map[blue] += ({ fn });
         } else {
            help_map[blue] = ({ fn });
         }
         extra_indexes += ({ ({ blue, fname, "", ret[AUTO_INDEX_SUMMARY] }) });
      }
   }
   return ret;
}
private void create_index() {
   int i;
   mixed *index_stuff;
   mixed *rabbit;
   string fname;
   string fn;
   string *bits;
   object parse;
   index_stuff = ({ });
   help_map = ([ ]);
   extra_indexes = ({ });
   summary_map = ([ ]);
   parse = clone_object(AUTODOC_FILE);
   for (i = 0; i < sizeof(files); i++) {
      parse->parse_file(files[i], 0, 1);
      fname = parse->query_file_name();
      if (fname) {
         fn = replace(fname, "/", ".");
         if (fn[0] == '.') {
            fn = fn[1..];
         }
         fn = NROFF_DOC_DIR + fn;
         bits = explode(fname[0..strlen(fname)-3], "/");
         rabbit = process_stuff(bits[sizeof(bits) - 1], "", fn,
                                parse->query_main_docs());
         if (rabbit[AUTO_INDEX_SUMMARY]) {
            summary_map[fname] = rabbit[AUTO_INDEX_SUMMARY];
         } else {
            map_delete(summary_map, fname);
         }
         index_stuff += map(keys(parse->query_public_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_public_functions()) :) );
         index_stuff += map(keys(parse->query_protected_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_protected_functions()) :) );
         index_stuff += map(keys(parse->query_class_docs()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_class_docs()) :) );
         if (sscanf(fname, "%*s.h") == 1) {
            index_stuff += map(keys(parse->query_define_docs()),
                               (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_define_docs()) :) );
         }
      }
      reset_eval_cost();
   }
   index_stuff += extra_indexes;
   extra_indexes = ({ });
   for (i = 0; i < sizeof(filters); i++) {
      reset_eval_cost();
      catch(evaluate(filters[i], index_stuff, INDEX_FILE));
   }
   summary_map = ([ ]);
   last_created_index = time();
   save();
}
int recreate_documentation(string fname) {
   object ob;
   if (member_array(fname, files) != -1) {
      ob = clone_object(AUTODOC_FILE);
      ob->parse_file(fname, (: after_thingy(1) :));
      return 1;
   }
   return 0;
}
void recreate_indexes() {
   unguarded( (: create_index() :));
}
int add_file(string fname) {
   fname = "/" + implode(explode(fname, "/") - ({ "" }), "/");
   if (member_array(fname, files) == -1) {
      if (sizeof(unguarded( (: stat($(fname)) :) ))) {
         files += ({ fname });
         save();
         if (sizeof(files) == 1) {
            start_processing();
         } else {
            call_out((: recreate_documentation($1) :), random(60), fname);
         }
         return 1;
      }
   }
   return 0;
}
int remove_file(string fname) {
   string fn;
   string dfn;
   string *our_files;
   if (member_array(fname, files) != -1) {
      files -= ({ fname });
      file_pos = 0;
      fn = HTML_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      fn = NROFF_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      fn = NROFF_DOC_SINGLE + fname[0..<3] + "/";
      our_files = get_dir(fn);
      if (sizeof(our_files)) {
         foreach (dfn in our_files) {
            dfn =  fn + dfn;
            unguarded( (: rm($(dfn)) :) );
         }
      }
      if (file_size(fn[0..<2]) != -1) {
         unguarded((: rm($(fn[0..<2])) :));
      }
      save();
      if (!sizeof(files)) {
         remove_call_out(call_id);
      }
      return 1;
   }
   return 0;
}
private void load() {
   unguarded( (: restore_object( SAVE_FILE ) :) );
}
private void save() {
   unguarded( (: save_object( SAVE_FILE ) :) );
}
string *query_files() { return files; }
mapping query_help_map() { return help_map; }
string query_help_on(string file, string func) {
   if (file[0] == '/') {
      file = file[1..];
   }
   if (sscanf(file, "%*s.c") == 1) {
      file = file[0..<3];
   }
   file = NROFF_DOC_SINGLE + file + "/" + func;
   if (file_size(file) > 0) {
      return file;
   }
   return 0;
}
mapping query_summary_map() { return summary_map; }
int is_autodoc_file(string name) {
   return member_array(name, files) != -1;
}
